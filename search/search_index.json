{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Read Latest Documentation - Browse GitHub Code Repository isort your imports, so you don't have to. isort is a Python utility / library to sort imports alphabetically, and automatically separated into sections and by type. It provides a command line utility, Python library and plugins for various editors to quickly sort all your imports. It requires Python 3.6+ to run but supports formatting Python 2 code too. Try isort now from your browser! Before isort: from my_lib import Object import os from my_lib import Object3 from my_lib import Object2 import sys from third_party import lib15 , lib1 , lib2 , lib3 , lib4 , lib5 , lib6 , lib7 , lib8 , lib9 , lib10 , lib11 , lib12 , lib13 , lib14 import sys from __future__ import absolute_import from third_party import lib3 print ( \"Hey\" ) print ( \"yo\" ) After isort: from __future__ import absolute_import import os import sys from third_party import ( lib1 , lib2 , lib3 , lib4 , lib5 , lib6 , lib7 , lib8 , lib9 , lib10 , lib11 , lib12 , lib13 , lib14 , lib15 ) from my_lib import Object , Object2 , Object3 print ( \"Hey\" ) print ( \"yo\" ) Installing isort Installing isort is as simple as: pip install isort Install isort with requirements.txt support: pip install isort [ requirements ] Install isort with Pipfile support: pip install isort [ pipfile ] Install isort with both formats support: pip install isort [ requirements,pipfile ] Install isort with support for reading configuration from pyproject.toml : pip install isort [ pyproject ] Using isort From the command line : isort mypythonfile.py mypythonfile2.py or recursively: isort which is equivalent to: isort **/*.py or to see the proposed changes without applying them: isort mypythonfile.py --diff Finally, to atomically run isort against a project, only applying changes if they don't introduce syntax errors do: isort --atomic . (Note: this is disabled by default as it keeps isort from being able to run against code written using a different version of Python) From within Python : import isort isort.file ( \"pythonfile.py\" ) or: import isort sorted_code = isort.code ( \"import b\\nimport a\\n\" ) Installing isort's for your preferred text editor Several plugins have been written that enable to use isort from within a variety of text-editors. You can find a full list of them on the isort wiki . Additionally, I will enthusiastically accept pull requests that include plugins for other text editors and add documentation for them as I am notified. How does isort work? isort parses specified files for global level import lines (imports outside of try / except blocks, functions, etc..) and puts them all at the top of the file grouped together by the type of import: Future Python Standard Library Third Party Current Python Project Explicitly Local (. before import, as in: from . import x ) Custom Separate Sections (Defined by forced_separate list in configuration file) Custom Sections (Defined by sections list in configuration file) Inside of each section the imports are sorted alphabetically. isort automatically removes duplicate python imports, and wraps long from imports to the specified line length (defaults to 79). When will isort not work? If you ever have the situation where you need to have a try / except block in the middle of top-level imports or if your import order is directly linked to precedence. For example: a common practice in Django settings files is importing * from various settings files to form a new settings file. In this case if any of the imports change order you are changing the settings definition itself. However, you can configure isort to skip over just these files - or even to force certain imports to the top. Configuring isort If you find the default isort settings do not work well for your project, isort provides several ways to adjust the behavior. To configure isort for a single user create a ~/.isort.cfg or $XDG_CONFIG_HOME/.isort.cfg file: [settings] line_length = 120 force_to_top = file1.py,file2.py skip = file3.py,file4.py known_future_library = future,pies known_standard_library = std,std2 known_third_party = randomthirdparty known_first_party = mylib1,mylib2 indent = ' ' multi_line_output = 3 length_sort = 1 forced_separate = django.contrib,django.utils default_section = FIRSTPARTY no_lines_before = LOCALFOLDER Additionally, you can specify project level configuration simply by placing a .isort.cfg file at the root of your project. isort will look up to 25 directories up, from the file it is ran against, to find a project specific configuration. Or, if you prefer, you can add an isort or tool:isort section to your project's setup.cfg or tox.ini file with any desired settings. You can also add your desired settings under a [tool.isort] section in your pyproject.toml file. For pyproject.toml support, use pip install isort[pyproject] . You can then override any of these settings by using command line arguments, or by passing in override values to any of the public Python API functions. Finally, as of version 3.0 isort supports editorconfig files using the standard syntax defined here: https://editorconfig.org/ Meaning you place any standard isort configuration parameters within a .editorconfig file under the *.py section and they will be honored. For a full list of isort settings and their meanings take a look at the isort wiki . Multi line output modes You will notice above the \\\"multi_line_output\\\" setting. This setting defines how from imports wrap when they extend past the line_length limit and has 6 possible settings: 0 - Grid from third_party import ( lib1 , lib2 , lib3 , lib4 , lib5 , ... ) 1 - Vertical from third_party import ( lib1 , lib2 , lib3 lib4 , lib5 , ... ) 2 - Hanging Indent from third_party import \\ lib1 , lib2 , lib3 , \\ lib4 , lib5 , lib6 3 - Vertical Hanging Indent from third_party import ( lib1 , lib2 , lib3 , lib4 , ) 4 - Hanging Grid from third_party import ( lib1 , lib2 , lib3 , lib4 , lib5 , ... ) 5 - Hanging Grid Grouped from third_party import ( lib1 , lib2 , lib3 , lib4 , lib5 , ... ) 6 - Hanging Grid Grouped, No Trailing Comma In Mode 5 isort leaves a single extra space to maintain consistency of output when a comma is added at the end. Mode 6 is the same - except that no extra space is maintained leading to the possibility of lines one character longer. You can enforce a trailing comma by using this in conjunction with -tc or include_trailing_comma: True . from third_party import ( lib1 , lib2 , lib3 , lib4 , lib5 ) 7 - NOQA from third_party import lib1 , lib2 , lib3 , ... # NOQA Alternatively, you can set force_single_line to True ( -sl on the command line) and every import will appear on its own line: from third_party import lib1 from third_party import lib2 from third_party import lib3 ... Note: to change the how constant indents appear - simply change the indent property with the following accepted formats: Number of spaces you would like. For example: 4 would cause standard 4 space indentation. Tab A verbatim string with quotes around it. For example: \" \" is equivalent to 4. For the import styles that use parentheses, you can control whether or not to include a trailing comma after the last import with the include_trailing_comma option (defaults to False ). Intelligently Balanced Multi-line Imports As of isort 3.1.0 support for balanced multi-line imports has been added. With this enabled isort will dynamically change the import length to the one that produces the most balanced grid, while staying below the maximum import length defined. Example: from __future__ import ( absolute_import , division , print_function , unicode_literals ) Will be produced instead of: from __future__ import ( absolute_import , division , print_function , unicode_literals ) To enable this set balanced_wrapping to True in your config or pass the -e option into the command line utility. Custom Sections and Ordering You can change the section order with sections option from the default of: FUTURE,STDLIB,THIRDPARTY,FIRSTPARTY,LOCALFOLDER to your preference: sections = FUTURE,STDLIB,FIRSTPARTY,THIRDPARTY,LOCALFOLDER You also can define your own sections and their order. Example: known_django = django known_pandas = pandas,numpy sections = FUTURE,STDLIB,DJANGO,THIRDPARTY,PANDAS,FIRSTPARTY,LOCALFOLDER would create two new sections with the specified known modules. The no_lines_before option will prevent the listed sections from being split from the previous section by an empty line. Example: sections = FUTURE,STDLIB,THIRDPARTY,FIRSTPARTY,LOCALFOLDER no_lines_before = LOCALFOLDER would produce a section with both FIRSTPARTY and LOCALFOLDER modules combined. Auto-comment import sections Some projects prefer to have import sections uniquely titled to aid in identifying the sections quickly when visually scanning. isort can automate this as well. To do this simply set the import_heading_{section_name} setting for each section you wish to have auto commented - to the desired comment. For Example: import_heading_stdlib = Standard Library import_heading_firstparty = My Stuff Would lead to output looking like the following: # Standard Library import os import sys import django.settings # My Stuff import myproject.test Ordering by import length isort also makes it easy to sort your imports by length, simply by setting the length_sort option to True . This will result in the following output style: from evn.util import ( Pool , Dict , Options , Constant , DecayDict , UnexpectedCodePath , ) It is also possible to opt-in to sorting imports by length for only specific sections by using length_sort_ followed by the section name as a configuration item, e.g.: length_sort_stdlib=1 Skip processing of imports (outside of configuration) To make isort ignore a single import simply add a comment at the end of the import line containing the text isort:skip : import module # isort:skip or: from xyz import ( abc , # isort:skip yo , hey ) To make isort skip an entire file simply add isort:skip_file to the module's doc string: \"\"\" my_module.py Best module ever isort:skip_file \"\"\" import b import a Adding an import to multiple files isort makes it easy to add an import statement across multiple files, while being assured it's correctly placed. From the command line: isort -a \"from __future__ import print_function\" *.py from within Kate: ctrl+] or: menu > Python > Add Import Removing an import from multiple files isort also makes it easy to remove an import from multiple files, without having to be concerned with how it was originally formatted. From the command line: isort -rm \"os.system\" *.py from within Kate: ctrl+shift+] or: menu > Python > Remove Import Using isort to verify code The --check-only option isort can also be used to used to verify that code is correctly formatted by running it with -c . Any files that contain incorrectly sorted and/or formatted imports will be outputted to stderr . isort **/*.py -c -v SUCCESS: /home/timothy/Projects/Open_Source/isort/isort_kate_plugin.py Everything Looks Good! ERROR: /home/timothy/Projects/Open_Source/isort/isort/isort.py Imports are incorrectly sorted. One great place this can be used is with a pre-commit git hook, such as this one by \\@acdha: https://gist.github.com/acdha/8717683 This can help to ensure a certain level of code quality throughout a project. Git hook isort provides a hook function that can be integrated into your Git pre-commit script to check Python code before committing. To cause the commit to fail if there are isort errors (strict mode), include the following in .git/hooks/pre-commit : #!/usr/bin/env python import sys from isort.hooks import git_hook sys . exit ( git_hook ( strict = True , modify = True )) If you just want to display warnings, but allow the commit to happen anyway, call git_hook without the strict parameter. If you want to display warnings, but not also fix the code, call git_hook without the modify parameter. Setuptools integration Upon installation, isort enables a setuptools command that checks Python files declared by your project. Running python setup.py isort on the command line will check the files listed in your py_modules and packages . If any warning is found, the command will exit with an error code: $ python setup.py isort Also, to allow users to be able to use the command without having to install isort themselves, add isort to the setup_requires of your setup() like so: setup ( name = \"project\" , packages = [ \"project\" ], setup_requires = [ \"isort\" ] ) Security contact information To report a security vulnerability, please use the Tidelift security contact . Tidelift will coordinate the fix and disclosure. Why isort? isort simply stands for import sort. It was originally called \"sortImports\" however I got tired of typing the extra characters and came to the realization camelCase is not pythonic. I wrote isort because in an organization I used to work in the manager came in one day and decided all code must have alphabetically sorted imports. The code base was huge - and he meant for us to do it by hand. However, being a programmer - I\\'m too lazy to spend 8 hours mindlessly performing a function, but not too lazy to spend 16 hours automating it. I was given permission to open source sortImports and here we are :) Get professionally supported isort with the Tidelift Subscription Professional support for isort is available as part of the Tidelift Subscription . Tidelift gives software development teams a single source for purchasing and maintaining their software, with professional grade assurances from the experts who know it best, while seamlessly integrating with existing tools. Thanks and I hope you find isort useful! ~Timothy Crosley","title":"Home"},{"location":"#installing-isort","text":"Installing isort is as simple as: pip install isort Install isort with requirements.txt support: pip install isort [ requirements ] Install isort with Pipfile support: pip install isort [ pipfile ] Install isort with both formats support: pip install isort [ requirements,pipfile ] Install isort with support for reading configuration from pyproject.toml : pip install isort [ pyproject ]","title":"Installing isort"},{"location":"#using-isort","text":"From the command line : isort mypythonfile.py mypythonfile2.py or recursively: isort which is equivalent to: isort **/*.py or to see the proposed changes without applying them: isort mypythonfile.py --diff Finally, to atomically run isort against a project, only applying changes if they don't introduce syntax errors do: isort --atomic . (Note: this is disabled by default as it keeps isort from being able to run against code written using a different version of Python) From within Python : import isort isort.file ( \"pythonfile.py\" ) or: import isort sorted_code = isort.code ( \"import b\\nimport a\\n\" )","title":"Using isort"},{"location":"#installing-isorts-for-your-preferred-text-editor","text":"Several plugins have been written that enable to use isort from within a variety of text-editors. You can find a full list of them on the isort wiki . Additionally, I will enthusiastically accept pull requests that include plugins for other text editors and add documentation for them as I am notified.","title":"Installing isort's for your preferred text editor"},{"location":"#how-does-isort-work","text":"isort parses specified files for global level import lines (imports outside of try / except blocks, functions, etc..) and puts them all at the top of the file grouped together by the type of import: Future Python Standard Library Third Party Current Python Project Explicitly Local (. before import, as in: from . import x ) Custom Separate Sections (Defined by forced_separate list in configuration file) Custom Sections (Defined by sections list in configuration file) Inside of each section the imports are sorted alphabetically. isort automatically removes duplicate python imports, and wraps long from imports to the specified line length (defaults to 79).","title":"How does isort work?"},{"location":"#when-will-isort-not-work","text":"If you ever have the situation where you need to have a try / except block in the middle of top-level imports or if your import order is directly linked to precedence. For example: a common practice in Django settings files is importing * from various settings files to form a new settings file. In this case if any of the imports change order you are changing the settings definition itself. However, you can configure isort to skip over just these files - or even to force certain imports to the top.","title":"When will isort not work?"},{"location":"#configuring-isort","text":"If you find the default isort settings do not work well for your project, isort provides several ways to adjust the behavior. To configure isort for a single user create a ~/.isort.cfg or $XDG_CONFIG_HOME/.isort.cfg file: [settings] line_length = 120 force_to_top = file1.py,file2.py skip = file3.py,file4.py known_future_library = future,pies known_standard_library = std,std2 known_third_party = randomthirdparty known_first_party = mylib1,mylib2 indent = ' ' multi_line_output = 3 length_sort = 1 forced_separate = django.contrib,django.utils default_section = FIRSTPARTY no_lines_before = LOCALFOLDER Additionally, you can specify project level configuration simply by placing a .isort.cfg file at the root of your project. isort will look up to 25 directories up, from the file it is ran against, to find a project specific configuration. Or, if you prefer, you can add an isort or tool:isort section to your project's setup.cfg or tox.ini file with any desired settings. You can also add your desired settings under a [tool.isort] section in your pyproject.toml file. For pyproject.toml support, use pip install isort[pyproject] . You can then override any of these settings by using command line arguments, or by passing in override values to any of the public Python API functions. Finally, as of version 3.0 isort supports editorconfig files using the standard syntax defined here: https://editorconfig.org/ Meaning you place any standard isort configuration parameters within a .editorconfig file under the *.py section and they will be honored. For a full list of isort settings and their meanings take a look at the isort wiki .","title":"Configuring isort"},{"location":"#multi-line-output-modes","text":"You will notice above the \\\"multi_line_output\\\" setting. This setting defines how from imports wrap when they extend past the line_length limit and has 6 possible settings: 0 - Grid from third_party import ( lib1 , lib2 , lib3 , lib4 , lib5 , ... ) 1 - Vertical from third_party import ( lib1 , lib2 , lib3 lib4 , lib5 , ... ) 2 - Hanging Indent from third_party import \\ lib1 , lib2 , lib3 , \\ lib4 , lib5 , lib6 3 - Vertical Hanging Indent from third_party import ( lib1 , lib2 , lib3 , lib4 , ) 4 - Hanging Grid from third_party import ( lib1 , lib2 , lib3 , lib4 , lib5 , ... ) 5 - Hanging Grid Grouped from third_party import ( lib1 , lib2 , lib3 , lib4 , lib5 , ... ) 6 - Hanging Grid Grouped, No Trailing Comma In Mode 5 isort leaves a single extra space to maintain consistency of output when a comma is added at the end. Mode 6 is the same - except that no extra space is maintained leading to the possibility of lines one character longer. You can enforce a trailing comma by using this in conjunction with -tc or include_trailing_comma: True . from third_party import ( lib1 , lib2 , lib3 , lib4 , lib5 ) 7 - NOQA from third_party import lib1 , lib2 , lib3 , ... # NOQA Alternatively, you can set force_single_line to True ( -sl on the command line) and every import will appear on its own line: from third_party import lib1 from third_party import lib2 from third_party import lib3 ... Note: to change the how constant indents appear - simply change the indent property with the following accepted formats: Number of spaces you would like. For example: 4 would cause standard 4 space indentation. Tab A verbatim string with quotes around it. For example: \" \" is equivalent to 4. For the import styles that use parentheses, you can control whether or not to include a trailing comma after the last import with the include_trailing_comma option (defaults to False ).","title":"Multi line output modes"},{"location":"#intelligently-balanced-multi-line-imports","text":"As of isort 3.1.0 support for balanced multi-line imports has been added. With this enabled isort will dynamically change the import length to the one that produces the most balanced grid, while staying below the maximum import length defined. Example: from __future__ import ( absolute_import , division , print_function , unicode_literals ) Will be produced instead of: from __future__ import ( absolute_import , division , print_function , unicode_literals ) To enable this set balanced_wrapping to True in your config or pass the -e option into the command line utility.","title":"Intelligently Balanced Multi-line Imports"},{"location":"#custom-sections-and-ordering","text":"You can change the section order with sections option from the default of: FUTURE,STDLIB,THIRDPARTY,FIRSTPARTY,LOCALFOLDER to your preference: sections = FUTURE,STDLIB,FIRSTPARTY,THIRDPARTY,LOCALFOLDER You also can define your own sections and their order. Example: known_django = django known_pandas = pandas,numpy sections = FUTURE,STDLIB,DJANGO,THIRDPARTY,PANDAS,FIRSTPARTY,LOCALFOLDER would create two new sections with the specified known modules. The no_lines_before option will prevent the listed sections from being split from the previous section by an empty line. Example: sections = FUTURE,STDLIB,THIRDPARTY,FIRSTPARTY,LOCALFOLDER no_lines_before = LOCALFOLDER would produce a section with both FIRSTPARTY and LOCALFOLDER modules combined.","title":"Custom Sections and Ordering"},{"location":"#auto-comment-import-sections","text":"Some projects prefer to have import sections uniquely titled to aid in identifying the sections quickly when visually scanning. isort can automate this as well. To do this simply set the import_heading_{section_name} setting for each section you wish to have auto commented - to the desired comment. For Example: import_heading_stdlib = Standard Library import_heading_firstparty = My Stuff Would lead to output looking like the following: # Standard Library import os import sys import django.settings # My Stuff import myproject.test","title":"Auto-comment import sections"},{"location":"#ordering-by-import-length","text":"isort also makes it easy to sort your imports by length, simply by setting the length_sort option to True . This will result in the following output style: from evn.util import ( Pool , Dict , Options , Constant , DecayDict , UnexpectedCodePath , ) It is also possible to opt-in to sorting imports by length for only specific sections by using length_sort_ followed by the section name as a configuration item, e.g.: length_sort_stdlib=1","title":"Ordering by import length"},{"location":"#skip-processing-of-imports-outside-of-configuration","text":"To make isort ignore a single import simply add a comment at the end of the import line containing the text isort:skip : import module # isort:skip or: from xyz import ( abc , # isort:skip yo , hey ) To make isort skip an entire file simply add isort:skip_file to the module's doc string: \"\"\" my_module.py Best module ever isort:skip_file \"\"\" import b import a","title":"Skip processing of imports (outside of configuration)"},{"location":"#adding-an-import-to-multiple-files","text":"isort makes it easy to add an import statement across multiple files, while being assured it's correctly placed. From the command line: isort -a \"from __future__ import print_function\" *.py from within Kate: ctrl+] or: menu > Python > Add Import","title":"Adding an import to multiple files"},{"location":"#removing-an-import-from-multiple-files","text":"isort also makes it easy to remove an import from multiple files, without having to be concerned with how it was originally formatted. From the command line: isort -rm \"os.system\" *.py from within Kate: ctrl+shift+] or: menu > Python > Remove Import","title":"Removing an import from multiple files"},{"location":"#using-isort-to-verify-code","text":"","title":"Using isort to verify code"},{"location":"#the-check-only-option","text":"isort can also be used to used to verify that code is correctly formatted by running it with -c . Any files that contain incorrectly sorted and/or formatted imports will be outputted to stderr . isort **/*.py -c -v SUCCESS: /home/timothy/Projects/Open_Source/isort/isort_kate_plugin.py Everything Looks Good! ERROR: /home/timothy/Projects/Open_Source/isort/isort/isort.py Imports are incorrectly sorted. One great place this can be used is with a pre-commit git hook, such as this one by \\@acdha: https://gist.github.com/acdha/8717683 This can help to ensure a certain level of code quality throughout a project.","title":"The --check-only option"},{"location":"#git-hook","text":"isort provides a hook function that can be integrated into your Git pre-commit script to check Python code before committing. To cause the commit to fail if there are isort errors (strict mode), include the following in .git/hooks/pre-commit : #!/usr/bin/env python import sys from isort.hooks import git_hook sys . exit ( git_hook ( strict = True , modify = True )) If you just want to display warnings, but allow the commit to happen anyway, call git_hook without the strict parameter. If you want to display warnings, but not also fix the code, call git_hook without the modify parameter.","title":"Git hook"},{"location":"#setuptools-integration","text":"Upon installation, isort enables a setuptools command that checks Python files declared by your project. Running python setup.py isort on the command line will check the files listed in your py_modules and packages . If any warning is found, the command will exit with an error code: $ python setup.py isort Also, to allow users to be able to use the command without having to install isort themselves, add isort to the setup_requires of your setup() like so: setup ( name = \"project\" , packages = [ \"project\" ], setup_requires = [ \"isort\" ] )","title":"Setuptools integration"},{"location":"#security-contact-information","text":"To report a security vulnerability, please use the Tidelift security contact . Tidelift will coordinate the fix and disclosure.","title":"Security contact information"},{"location":"#why-isort","text":"isort simply stands for import sort. It was originally called \"sortImports\" however I got tired of typing the extra characters and came to the realization camelCase is not pythonic. I wrote isort because in an organization I used to work in the manager came in one day and decided all code must have alphabetically sorted imports. The code base was huge - and he meant for us to do it by hand. However, being a programmer - I\\'m too lazy to spend 8 hours mindlessly performing a function, but not too lazy to spend 16 hours automating it. I was given permission to open source sortImports and here we are :) Get professionally supported isort with the Tidelift Subscription Professional support for isort is available as part of the Tidelift Subscription . Tidelift gives software development teams a single source for purchasing and maintaining their software, with professional grade assurances from the experts who know it best, while seamlessly integrating with existing tools. Thanks and I hope you find isort useful! ~Timothy Crosley","title":"Why isort?"},{"location":"CHANGELOG/","text":"Changelog NOTE: isort follows the semver versioning standard. 5.0.2 - July 4, 2020 Ensured black profile was complete, adding missing line_length definition. 5.0.1 - July 4, 2020 Fixed a runtime error in a vendored dependency (toml). 5.0.0 Penny - July 4, 2020 Breaking changes: isort now requires Python 3.6+ to run but continues to support formatting on ALL versions of python including Python 2 code. isort deprecates official support for Python 3.4, removing modules only in this release from known_standard_library: user Config files are no longer composed on-top of each-other. Instead the first config file found is used. Since there is no longer composition negative form settings (such as --dont-skip) are no longer required and have been removed. Two-letter shortened setting names (like ac for atomic ) now require two dashes to avoid ambiguity: --ac . For consistency with other tools -v now is shorthand for verbose and -V is shorthand for version. See Issue: #1067. length_sort_{section_name} config usage has been deprecated. Instead length_sort_sections list can be used to specify a list of sections that need to be length sorted. safety_excludes and unsafe have been deprecated Config now includes as default full set of safety directories defined by safety excludes. --recursive option has been removed. Directories passed in are now automatically sorted recursive. --apply option has been removed as it is the default behaviour. isort now does nothing, beyond giving instructions and exiting status code 0, when ran with no arguments. a new --interactive flag has been added to enable the old style behaviour. isort now works on contiguous sections of imports, instead of one whole file at a time. isort now formats all nested \"as\" imports in the \"from\" form. import x.y as a becomes from x import y as a . keep_direct_and_as_imports option now defaults to True . appdirs is no longer supported. Unless manually specified, config should be project config only. toml is now installed as a vendorized module, meaning pyproject.toml based config is always supported. Completely new Python API, old version is removed and no longer accessible. New module placement logic and module fully replaces old finders. Old approach is still available via --old-finders . Internal: isort now utilizes mypy and typing to filter out typing related issues before deployment. isort now utilizes black internally to ensure more consistent formatting. profile support for common project types (black, django, google, etc) Much much more. There is some difficulty in fully capturing the extent of changes in this release - just because of how all encompassing the release is. See: Github Issues for more. 4.3.21 - June 25, 2019 - hot fix release Fixed issue #957 - Long aliases and use_parentheses generates invalid syntax 4.3.20 - May 14, 2019 - hot fix release Fixed issue #948 - Pipe redirection broken on Python2.7 4.3.19 - May 12, 2019 - hot fix release Fixed issue #942 - correctly handle pyi (Python Template Files) to match black output 4.3.18 - May 1, 2019 - hot fix release Fixed an issue with parsing files that contain unicode characters in Python 2 Fixed issue #924 - Pulling in pip internals causes depreciation warning Fixed issue #938 - Providing a way to filter explicitly passed in files via configuration settings ( --filter-files ) Improved interoperability with toml configuration files 4.3.17 - April 7, 2019 - hot fix release Fixed issue #905 & #919: Import section headers behaving strangely 4.3.16 - March 23, 2019 - hot fix release Fixed issue #909 - skip and skip-glob are not enforced when using settings-path. Fixed issue #907 - appdirs optional requirement does not correctly specify version Fixed issue #902 - Too broad warning about missing toml package Fixed issue #778 - remove user from known standard library as it's no longer in any supported Python version. 4.3.15 - March 10, 2019 - hot fix release Fixed a regression with handling streaming input from pipes (Issue #895) Fixed handling of \\x0c whitespace character (Issue #811) Improved CLI documentation 4.3.14 - March 9, 2019 - hot fix release Fixed a regression with /directory/ .py style patterns 4.3.13 - March 8, 2019 - hot fix release Fixed the inability to accurately determine import section when a mix of conda and virtual environments are used. Fixed some output being printed even when --quiet mode is enabled. Fixed issue #890 interoperability with PyCharm by allowing case sensitive non type grouped sorting. Fixed issue #889 under some circumstances isort will incorrectly add a new line at the beginning of a file. Fixed issue #885 many files not being skipped according to set skip settings. Fixed issue #842 streaming encoding improvements. 4.3.12 - March 6, 2019 - hot fix release Fix error caused when virtual environment not detected 4.3.11 - March 6, 2019 - hot fix release Fixed issue #876: confused by symlinks pointing to virtualenv gives FIRSTPARTY not THIRDPARTY Fixed issue #873: current version skips every file on travis Additional caching to reduce performance regression introduced in 4.3.5 4.3.10 - March 2, 2019 - hot fix release Fixed Windows incompatibilities (Issue #835) Fixed relative import sorting bug (Issue #417) Fixed \"no_lines_before\" to also be respected from previous empty sections. Fixed slow-down introduced by finders mechanism by adding a LRU cache (issue #848) Fixed issue #842 default encoding not-set in Python2 Restored Windows automated testing Added Mac automated testing 4.3.9 - February 25, 2019 - hot fix release Fixed a bug that led to an incompatibility with black: #831 4.3.8 - February 25, 2019 - hot fix release Fixed a bug that led to the recursive option not always been available from the command line. 4.3.7 - February 25, 2019 - hot fix release Expands the finder failsafe to occur on the creation of the finder objects. 4.3.6 - February 24, 2019 - hot fix release Fixes a fatal error that occurs if a single finder throws an exception. Important as we add more finders that utilize third party libraries. 4.3.5 - February 24, 2019 - last Python 2.7 Maintenance Release This is the final Python 2.x release of isort, and includes the following major changes: Potentially Interface Breaking: - The -r option for removing imports has been renamed -rm to avoid accidental deletions and confusion with the -rc recursive option. - __init__.py has been removed from the default ignore list. The default ignore list is now empty - with all items needing to be explicitly ignored. - Isort will now by default ignore .tox / venv folders in an effort to be \"safe\". You can disable this behaviour by setting the \"--unsafe\" flag, this is separate from any skip or not skip rules you may have in place. - Isort now allows for files missing closing newlines in whitespace check - distutils support has been removed to simplify setup.py New: - Official Python 3.7 Compatibility. - Support for using requirements files to auto determine third-paty section if pipreqs & requirementslib are installed. - Added support for using pyproject.toml if toml is installed. - Added support for XDG_HOME if appdirs is installed. - An option has been added to enable ignoring trailing comments ('ignore_comments') defaulting to False. - Added support to enable line length sorting for only specific sections - Added a correctly_sorted property on the SortsImport to enable more intuitive programmatic checking. Fixes: - Improved black compatibility. - Isort will now detect files in the CWD as first-party. - Fixed several cases where '-ns' or 'not_skip' was being incorrectly ignored. - Fixed sorting of relative path imports ('.', '..', '...', etc). - Fixed bugs caused by a failure to maintain order when loading iterables from config files. - Correctly handle CPython compiled imports and others that need EXT_SUFFIX to correctly identify. - Fixed handling of Symbolic Links to follow them when walking the path. - Fixed handling of relative known_paths. - Fixed lack of access to all wrap modes from the CLI. - Fixed handling of FIFO files. - Fixed a bug that could result in multiple imports being inserted on the same line. 4.3.4 - February 12, 2018 - hotfix release Fixed issue #671: isort is corrupting CRLF files 4.3.3 - Feburary 5, 2018 - hotfix release Fixed issue #665: Tabs turned into single spaces 4.3.2 - Feburary 4, 2018 - hotfix release Fixed issue #651: Add imports option is broken Fixed issue #662: An error generated by rewriting .imports to . imoprts 4.3.1 - Feburary 2, 2018 - hotfix release Fixed setup.py errors Fixed issue #654: Trailing comma count error Fixed issue #650: Wrong error message displayed 4.3.0 - January 31, 2018 Fixed #557: force_alphabetical_sort and force_sort_within_sections can now be utilized together without extra new lines Fix case-sensitive path existence check in Mac OS X Added --no-lines-before for more granular control over section output Fixed #493: Unwanted conversion to Windows line endings Fixed #590: Import as mucks with alphabetical sorting Implemented --version-number to retrieve just the version number without the isort logo Breaking changes Python 2.7+ only (dropped 2.6) allowing various code simplifications and improvements. 4.2.15 - June 6, 2017 - hotfix release IMPORTANT NOTE: This will be the last release with Python 2.6 support, subsequent releases will be 2.7+ only - Fixed certain one line imports not being successfully wrapped 4.2.14 - June 5, 2017 - hotfix release Fixed #559 & #565: Added missing standard library imports 4.2.13 - June 2, 2017 - hotfix release Fixed #553: Check only and --diff now work together again 4.2.12 - June 1, 2017 - hotfix release Fixed wheel distribution bug 4.2.11 - June 1, 2017 - hotfix release Fixed #546: Can't select y/n/c after latest update Fixed #545: Incorrectly moves future imports above encoding comments 4.2.9 - June 1, 2017 - hotfix release Fixed #428: Check only modifies sorting Fixed #540: Not correctly identifying stdlib modules 4.2.8 - May 31, 2017 Added --virtual-env switch command line option Added --enforce-whitespace option to go along with --check-only for more exact checks (issue #423) Fixed imports with a tailing '\\' and no space in-between getting removed (issue #425) Fixed issue #299: long lines occasionally not wrapped Fixed issue #432: No longer add import inside class when class starts at top of file after encoding comment Fixed issue #440: Added missing --use-parentheses option to command line tool and documentation Fixed issue #496: import* imports now get successfully identified and reformatted instead of deleted Fixed issue #491: Non ending parentheses withing single line comments no longer cause formatting issues Fixed issue #471: Imports that wrap the maximum line length and contain comments on the last line are no longer rendered incorrectly Fixed issue #436: Force sort within section no longer rearranges comments Fixed issue #473: Force_to_top and force_sort_within_sections now work together Fixed issue #484 & #472: Consistent output with imports of same spelling but different case Fixed issue #433: No longer incorrectly add an extra new-line when comment between imports and function definition Fixed issue #419: Path specification for skipped paths is not Unix/Windows inter-operable. Breaking Changes: Fixed issue #511: All command line options with an underscore, have had the underscore replaced with a dash for consistency. This effects: multi-line, add-import, remove-import, force-adds, --force-single-line-imports, and length-sort. Replaced the --enforce-whitespace option with --ignore-whitespace to restore original behavior of strict whitespace by default 4.2.5 Fixed an issue that caused modules to inccorectly be matched as thirdparty when they simply had src in the leading path, even if they weren't withing $VIRTUALENV/src #414 4.2.4 Fixed an issue that caused module that contained functions before doc strings, to incorrectly place imports Fixed regression in how force_alphabetical_sort was being interpretted (issue #409) Fixed stray print statement printing skipped files (issue #411) Added option for forcing imports into a single bucket: no_sections Added option for new lines between import types (from, straight): lines_between_sections 4.2.3 Fixed a large number of priority bugs - bug fix only release 4.2.2 Give an error message when isort is unable to determine where to place a module Allow imports to be sorted by module, independent of import_type, when force_sort_within_sections option is set Fixed an issue that caused Python files with 2 top comments not to be sorted 4.2.1 Hot fix release to fix code error when skipping globs 4.2.0 Added option \"NOQA\" Do not wrap lines, but add a noqa statement at the end Added support for running isort recursively, simply with a standalone isort command Added support to run isort library as a module Added compatibility for Python 3.5 Fixed performance issue (#338) when running on project with lots of skipped directories Fixed issue #328: extra new can occasionally occur when using alphabetical-only sort Fixed custom sections parsing from config file (unicode string -> list) Updated pylama extension to the correct entry point Skip files even when file_contents is provided if they are explicitly in skip list Removed always showing isort banner, keeping it for when the version is requested, verbose is used, or show_logo setting is set. 4.1.2 Fixed issue #323: Accidental default configuration change introduced 4.1.1 Added support for partial file match skips (thanks to @Amwam) Added support for --quiet option to only show errors when running isort Fixed issue #316: isort added new lines incorrectly when a top-of line comment is present 4.1.0 Started keeping a log of all changes between releases Added the isort logo to the command line interface Added example usage gif to README Implemented issue #292: skip setting now supports glob patterns Implemented issue #271: Add option to sort imports purely alphabetically Implemented issue #301: Readme is now natively in RST format, making it easier for Python tooling to pick up Implemented pylama isort extension Fixed issue #260: # encoding lines at the top of the file are now correctly supported Fixed issue #284: Sticky comments above first import are now supported Fixed issue #310: Ensure comments don't get duplicated when reformatting imports Fixed issue #289: Sections order not being respected Fixed issue #296: Made it more clear how to set arguments more then once 4.0.0 Removed all external dependencies","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"NOTE: isort follows the semver versioning standard.","title":"Changelog"},{"location":"CHANGELOG/#502-july-4-2020","text":"Ensured black profile was complete, adding missing line_length definition.","title":"5.0.2 - July 4, 2020"},{"location":"CHANGELOG/#501-july-4-2020","text":"Fixed a runtime error in a vendored dependency (toml).","title":"5.0.1 - July 4, 2020"},{"location":"CHANGELOG/#500-penny-july-4-2020","text":"Breaking changes: isort now requires Python 3.6+ to run but continues to support formatting on ALL versions of python including Python 2 code. isort deprecates official support for Python 3.4, removing modules only in this release from known_standard_library: user Config files are no longer composed on-top of each-other. Instead the first config file found is used. Since there is no longer composition negative form settings (such as --dont-skip) are no longer required and have been removed. Two-letter shortened setting names (like ac for atomic ) now require two dashes to avoid ambiguity: --ac . For consistency with other tools -v now is shorthand for verbose and -V is shorthand for version. See Issue: #1067. length_sort_{section_name} config usage has been deprecated. Instead length_sort_sections list can be used to specify a list of sections that need to be length sorted. safety_excludes and unsafe have been deprecated Config now includes as default full set of safety directories defined by safety excludes. --recursive option has been removed. Directories passed in are now automatically sorted recursive. --apply option has been removed as it is the default behaviour. isort now does nothing, beyond giving instructions and exiting status code 0, when ran with no arguments. a new --interactive flag has been added to enable the old style behaviour. isort now works on contiguous sections of imports, instead of one whole file at a time. isort now formats all nested \"as\" imports in the \"from\" form. import x.y as a becomes from x import y as a . keep_direct_and_as_imports option now defaults to True . appdirs is no longer supported. Unless manually specified, config should be project config only. toml is now installed as a vendorized module, meaning pyproject.toml based config is always supported. Completely new Python API, old version is removed and no longer accessible. New module placement logic and module fully replaces old finders. Old approach is still available via --old-finders . Internal: isort now utilizes mypy and typing to filter out typing related issues before deployment. isort now utilizes black internally to ensure more consistent formatting. profile support for common project types (black, django, google, etc) Much much more. There is some difficulty in fully capturing the extent of changes in this release - just because of how all encompassing the release is. See: Github Issues for more.","title":"5.0.0 Penny - July 4, 2020"},{"location":"CHANGELOG/#4321-june-25-2019-hot-fix-release","text":"Fixed issue #957 - Long aliases and use_parentheses generates invalid syntax","title":"4.3.21 - June 25, 2019 - hot fix release"},{"location":"CHANGELOG/#4320-may-14-2019-hot-fix-release","text":"Fixed issue #948 - Pipe redirection broken on Python2.7","title":"4.3.20 - May 14, 2019 - hot fix release"},{"location":"CHANGELOG/#4319-may-12-2019-hot-fix-release","text":"Fixed issue #942 - correctly handle pyi (Python Template Files) to match black output","title":"4.3.19 - May 12, 2019 - hot fix release"},{"location":"CHANGELOG/#4318-may-1-2019-hot-fix-release","text":"Fixed an issue with parsing files that contain unicode characters in Python 2 Fixed issue #924 - Pulling in pip internals causes depreciation warning Fixed issue #938 - Providing a way to filter explicitly passed in files via configuration settings ( --filter-files ) Improved interoperability with toml configuration files","title":"4.3.18 - May 1, 2019 - hot fix release"},{"location":"CHANGELOG/#4317-april-7-2019-hot-fix-release","text":"Fixed issue #905 & #919: Import section headers behaving strangely","title":"4.3.17 - April 7, 2019 - hot fix release"},{"location":"CHANGELOG/#4316-march-23-2019-hot-fix-release","text":"Fixed issue #909 - skip and skip-glob are not enforced when using settings-path. Fixed issue #907 - appdirs optional requirement does not correctly specify version Fixed issue #902 - Too broad warning about missing toml package Fixed issue #778 - remove user from known standard library as it's no longer in any supported Python version.","title":"4.3.16 - March 23, 2019 - hot fix release"},{"location":"CHANGELOG/#4315-march-10-2019-hot-fix-release","text":"Fixed a regression with handling streaming input from pipes (Issue #895) Fixed handling of \\x0c whitespace character (Issue #811) Improved CLI documentation","title":"4.3.15 - March 10, 2019 - hot fix release"},{"location":"CHANGELOG/#4314-march-9-2019-hot-fix-release","text":"Fixed a regression with /directory/ .py style patterns","title":"4.3.14 - March 9, 2019 - hot fix release"},{"location":"CHANGELOG/#4313-march-8-2019-hot-fix-release","text":"Fixed the inability to accurately determine import section when a mix of conda and virtual environments are used. Fixed some output being printed even when --quiet mode is enabled. Fixed issue #890 interoperability with PyCharm by allowing case sensitive non type grouped sorting. Fixed issue #889 under some circumstances isort will incorrectly add a new line at the beginning of a file. Fixed issue #885 many files not being skipped according to set skip settings. Fixed issue #842 streaming encoding improvements.","title":"4.3.13 - March 8, 2019 - hot fix release"},{"location":"CHANGELOG/#4312-march-6-2019-hot-fix-release","text":"Fix error caused when virtual environment not detected","title":"4.3.12 - March 6, 2019 - hot fix release"},{"location":"CHANGELOG/#4311-march-6-2019-hot-fix-release","text":"Fixed issue #876: confused by symlinks pointing to virtualenv gives FIRSTPARTY not THIRDPARTY Fixed issue #873: current version skips every file on travis Additional caching to reduce performance regression introduced in 4.3.5","title":"4.3.11 - March 6, 2019 - hot fix release"},{"location":"CHANGELOG/#4310-march-2-2019-hot-fix-release","text":"Fixed Windows incompatibilities (Issue #835) Fixed relative import sorting bug (Issue #417) Fixed \"no_lines_before\" to also be respected from previous empty sections. Fixed slow-down introduced by finders mechanism by adding a LRU cache (issue #848) Fixed issue #842 default encoding not-set in Python2 Restored Windows automated testing Added Mac automated testing","title":"4.3.10 - March 2, 2019 - hot fix release"},{"location":"CHANGELOG/#439-february-25-2019-hot-fix-release","text":"Fixed a bug that led to an incompatibility with black: #831","title":"4.3.9 - February 25, 2019 - hot fix release"},{"location":"CHANGELOG/#438-february-25-2019-hot-fix-release","text":"Fixed a bug that led to the recursive option not always been available from the command line.","title":"4.3.8 - February 25, 2019 - hot fix release"},{"location":"CHANGELOG/#437-february-25-2019-hot-fix-release","text":"Expands the finder failsafe to occur on the creation of the finder objects.","title":"4.3.7 - February 25, 2019 - hot fix release"},{"location":"CHANGELOG/#436-february-24-2019-hot-fix-release","text":"Fixes a fatal error that occurs if a single finder throws an exception. Important as we add more finders that utilize third party libraries.","title":"4.3.6 - February 24, 2019 - hot fix release"},{"location":"CHANGELOG/#435-february-24-2019-last-python-27-maintenance-release","text":"This is the final Python 2.x release of isort, and includes the following major changes: Potentially Interface Breaking: - The -r option for removing imports has been renamed -rm to avoid accidental deletions and confusion with the -rc recursive option. - __init__.py has been removed from the default ignore list. The default ignore list is now empty - with all items needing to be explicitly ignored. - Isort will now by default ignore .tox / venv folders in an effort to be \"safe\". You can disable this behaviour by setting the \"--unsafe\" flag, this is separate from any skip or not skip rules you may have in place. - Isort now allows for files missing closing newlines in whitespace check - distutils support has been removed to simplify setup.py New: - Official Python 3.7 Compatibility. - Support for using requirements files to auto determine third-paty section if pipreqs & requirementslib are installed. - Added support for using pyproject.toml if toml is installed. - Added support for XDG_HOME if appdirs is installed. - An option has been added to enable ignoring trailing comments ('ignore_comments') defaulting to False. - Added support to enable line length sorting for only specific sections - Added a correctly_sorted property on the SortsImport to enable more intuitive programmatic checking. Fixes: - Improved black compatibility. - Isort will now detect files in the CWD as first-party. - Fixed several cases where '-ns' or 'not_skip' was being incorrectly ignored. - Fixed sorting of relative path imports ('.', '..', '...', etc). - Fixed bugs caused by a failure to maintain order when loading iterables from config files. - Correctly handle CPython compiled imports and others that need EXT_SUFFIX to correctly identify. - Fixed handling of Symbolic Links to follow them when walking the path. - Fixed handling of relative known_paths. - Fixed lack of access to all wrap modes from the CLI. - Fixed handling of FIFO files. - Fixed a bug that could result in multiple imports being inserted on the same line.","title":"4.3.5 - February 24, 2019 - last Python 2.7 Maintenance Release"},{"location":"CHANGELOG/#434-february-12-2018-hotfix-release","text":"Fixed issue #671: isort is corrupting CRLF files","title":"4.3.4 - February 12, 2018 - hotfix release"},{"location":"CHANGELOG/#433-feburary-5-2018-hotfix-release","text":"Fixed issue #665: Tabs turned into single spaces","title":"4.3.3 - Feburary 5, 2018 - hotfix release"},{"location":"CHANGELOG/#432-feburary-4-2018-hotfix-release","text":"Fixed issue #651: Add imports option is broken Fixed issue #662: An error generated by rewriting .imports to . imoprts","title":"4.3.2 - Feburary 4, 2018 - hotfix release"},{"location":"CHANGELOG/#431-feburary-2-2018-hotfix-release","text":"Fixed setup.py errors Fixed issue #654: Trailing comma count error Fixed issue #650: Wrong error message displayed","title":"4.3.1 - Feburary 2, 2018 - hotfix release"},{"location":"CHANGELOG/#430-january-31-2018","text":"Fixed #557: force_alphabetical_sort and force_sort_within_sections can now be utilized together without extra new lines Fix case-sensitive path existence check in Mac OS X Added --no-lines-before for more granular control over section output Fixed #493: Unwanted conversion to Windows line endings Fixed #590: Import as mucks with alphabetical sorting Implemented --version-number to retrieve just the version number without the isort logo Breaking changes Python 2.7+ only (dropped 2.6) allowing various code simplifications and improvements.","title":"4.3.0 - January 31, 2018"},{"location":"CHANGELOG/#4215-june-6-2017-hotfix-release","text":"IMPORTANT NOTE: This will be the last release with Python 2.6 support, subsequent releases will be 2.7+ only - Fixed certain one line imports not being successfully wrapped","title":"4.2.15 - June 6, 2017 - hotfix release"},{"location":"CHANGELOG/#4214-june-5-2017-hotfix-release","text":"Fixed #559 & #565: Added missing standard library imports","title":"4.2.14 - June 5, 2017 - hotfix release"},{"location":"CHANGELOG/#4213-june-2-2017-hotfix-release","text":"Fixed #553: Check only and --diff now work together again","title":"4.2.13 - June 2, 2017 - hotfix release"},{"location":"CHANGELOG/#4212-june-1-2017-hotfix-release","text":"Fixed wheel distribution bug","title":"4.2.12 - June 1, 2017 - hotfix release"},{"location":"CHANGELOG/#4211-june-1-2017-hotfix-release","text":"Fixed #546: Can't select y/n/c after latest update Fixed #545: Incorrectly moves future imports above encoding comments","title":"4.2.11 - June 1, 2017 - hotfix release"},{"location":"CHANGELOG/#429-june-1-2017-hotfix-release","text":"Fixed #428: Check only modifies sorting Fixed #540: Not correctly identifying stdlib modules","title":"4.2.9 - June 1, 2017 - hotfix release"},{"location":"CHANGELOG/#428-may-31-2017","text":"Added --virtual-env switch command line option Added --enforce-whitespace option to go along with --check-only for more exact checks (issue #423) Fixed imports with a tailing '\\' and no space in-between getting removed (issue #425) Fixed issue #299: long lines occasionally not wrapped Fixed issue #432: No longer add import inside class when class starts at top of file after encoding comment Fixed issue #440: Added missing --use-parentheses option to command line tool and documentation Fixed issue #496: import* imports now get successfully identified and reformatted instead of deleted Fixed issue #491: Non ending parentheses withing single line comments no longer cause formatting issues Fixed issue #471: Imports that wrap the maximum line length and contain comments on the last line are no longer rendered incorrectly Fixed issue #436: Force sort within section no longer rearranges comments Fixed issue #473: Force_to_top and force_sort_within_sections now work together Fixed issue #484 & #472: Consistent output with imports of same spelling but different case Fixed issue #433: No longer incorrectly add an extra new-line when comment between imports and function definition Fixed issue #419: Path specification for skipped paths is not Unix/Windows inter-operable. Breaking Changes: Fixed issue #511: All command line options with an underscore, have had the underscore replaced with a dash for consistency. This effects: multi-line, add-import, remove-import, force-adds, --force-single-line-imports, and length-sort. Replaced the --enforce-whitespace option with --ignore-whitespace to restore original behavior of strict whitespace by default","title":"4.2.8 - May 31, 2017"},{"location":"CHANGELOG/#425","text":"Fixed an issue that caused modules to inccorectly be matched as thirdparty when they simply had src in the leading path, even if they weren't withing $VIRTUALENV/src #414","title":"4.2.5"},{"location":"CHANGELOG/#424","text":"Fixed an issue that caused module that contained functions before doc strings, to incorrectly place imports Fixed regression in how force_alphabetical_sort was being interpretted (issue #409) Fixed stray print statement printing skipped files (issue #411) Added option for forcing imports into a single bucket: no_sections Added option for new lines between import types (from, straight): lines_between_sections","title":"4.2.4"},{"location":"CHANGELOG/#423","text":"Fixed a large number of priority bugs - bug fix only release","title":"4.2.3"},{"location":"CHANGELOG/#422","text":"Give an error message when isort is unable to determine where to place a module Allow imports to be sorted by module, independent of import_type, when force_sort_within_sections option is set Fixed an issue that caused Python files with 2 top comments not to be sorted","title":"4.2.2"},{"location":"CHANGELOG/#421","text":"Hot fix release to fix code error when skipping globs","title":"4.2.1"},{"location":"CHANGELOG/#420","text":"Added option \"NOQA\" Do not wrap lines, but add a noqa statement at the end Added support for running isort recursively, simply with a standalone isort command Added support to run isort library as a module Added compatibility for Python 3.5 Fixed performance issue (#338) when running on project with lots of skipped directories Fixed issue #328: extra new can occasionally occur when using alphabetical-only sort Fixed custom sections parsing from config file (unicode string -> list) Updated pylama extension to the correct entry point Skip files even when file_contents is provided if they are explicitly in skip list Removed always showing isort banner, keeping it for when the version is requested, verbose is used, or show_logo setting is set.","title":"4.2.0"},{"location":"CHANGELOG/#412","text":"Fixed issue #323: Accidental default configuration change introduced","title":"4.1.2"},{"location":"CHANGELOG/#411","text":"Added support for partial file match skips (thanks to @Amwam) Added support for --quiet option to only show errors when running isort Fixed issue #316: isort added new lines incorrectly when a top-of line comment is present","title":"4.1.1"},{"location":"CHANGELOG/#410","text":"Started keeping a log of all changes between releases Added the isort logo to the command line interface Added example usage gif to README Implemented issue #292: skip setting now supports glob patterns Implemented issue #271: Add option to sort imports purely alphabetically Implemented issue #301: Readme is now natively in RST format, making it easier for Python tooling to pick up Implemented pylama isort extension Fixed issue #260: # encoding lines at the top of the file are now correctly supported Fixed issue #284: Sticky comments above first import are now supported Fixed issue #310: Ensure comments don't get duplicated when reformatting imports Fixed issue #289: Sections order not being respected Fixed issue #296: Made it more clear how to set arguments more then once","title":"4.1.0"},{"location":"CHANGELOG/#400","text":"Removed all external dependencies","title":"4.0.0"},{"location":"docs/configuration/action_comments/","text":"Action Comments The most basic way to configure the flow of isort within a single file is action comments. These comments are picked up and interpreted by the isort parser during parsing. isort: skip-file Tells isort to skip the entire file. Example: # !/bin/python3 # isort: skip-file import os import sys ... Warning This should be placed as high in the file as reasonably possible. Since isort uses a streaming architecture, it may have already completed some work before it reaches the comment. Usually, this is okay - but can be confusing if --diff or any interactive options are used from the command line. isort: skip If placed on the same line as (or within the continuation of a) an import statement, isort will not sort this import. Example: import b import a # isort: skip <- this will now stay below b Note It is recommended to where possible use # isort: off and # isort: on instead as the behaviour is more explicit and predictable. isort: off Turns isort parsing off. Every line after an # isort: off statement will be passed along unchanged until an # isort: on comment or the end of the file. Example: import e import f # isort: off import b import a isort: on Turns isort parsing back on. This only makes sense if an # isort: off comment exists higher in the file! This allows you to have blocks of unsorted imports, around otherwise sorted ones. Example: import e import f # isort: off import b import a # isort: on import c import d isort: split Tells isort the current sort section is finished, and all future imports belong to a new sort grouping. Example: import e import f # isort: split import a import b import c import d Tip isort split is exactly the same as placing an # isort: on immediately below an # isort: off","title":"Action Comments"},{"location":"docs/configuration/action_comments/#action-comments","text":"The most basic way to configure the flow of isort within a single file is action comments. These comments are picked up and interpreted by the isort parser during parsing.","title":"Action Comments"},{"location":"docs/configuration/action_comments/#isort-skip-file","text":"Tells isort to skip the entire file. Example: # !/bin/python3 # isort: skip-file import os import sys ... Warning This should be placed as high in the file as reasonably possible. Since isort uses a streaming architecture, it may have already completed some work before it reaches the comment. Usually, this is okay - but can be confusing if --diff or any interactive options are used from the command line.","title":"isort: skip-file"},{"location":"docs/configuration/action_comments/#isort-skip","text":"If placed on the same line as (or within the continuation of a) an import statement, isort will not sort this import. Example: import b import a # isort: skip <- this will now stay below b Note It is recommended to where possible use # isort: off and # isort: on instead as the behaviour is more explicit and predictable.","title":"isort: skip"},{"location":"docs/configuration/action_comments/#isort-off","text":"Turns isort parsing off. Every line after an # isort: off statement will be passed along unchanged until an # isort: on comment or the end of the file. Example: import e import f # isort: off import b import a","title":"isort: off"},{"location":"docs/configuration/action_comments/#isort-on","text":"Turns isort parsing back on. This only makes sense if an # isort: off comment exists higher in the file! This allows you to have blocks of unsorted imports, around otherwise sorted ones. Example: import e import f # isort: off import b import a # isort: on import c import d","title":"isort: on"},{"location":"docs/configuration/action_comments/#isort-split","text":"Tells isort the current sort section is finished, and all future imports belong to a new sort grouping. Example: import e import f # isort: split import a import b import c import d Tip isort split is exactly the same as placing an # isort: on immediately below an # isort: off","title":"isort: split"},{"location":"docs/configuration/config_files/","text":"Supported Config Files isort supports a variety of standard config formats, to allow customizations to easily be integrated into any project. When applying configurations, isort looks for the closest supported config file, in the order files are listed below. You can manually specify the settings file or path by setting --settings-path from the commandline, otherwise isort will traverse up to 25 parent directories until it finds a suitable config file. As soon as it finds a file, it stops looking. isort never merges config files together due to the confusion it can cause. Tip You can always introspect the configuration settings isort determined, and find out which config file it picked up, by running isort . --show-config .isort.cfg [preferred format] The first place isort will look for settings is in dedicated .isort.cfg files. The advantage of using this kind of config file, is that it is explicitly for isort and follows a well understood format. The downside, is that it means one more config file in your project when you may already have several polluting your file hierarchy. An example a config from the isort project itself: [settings] profile = hug src_paths = isort,test pyproject.toml [preferred format] The second place isort will look, and an equally excellent choice to place your configuration, is within a pyproject.toml file. The advantage of using this config file, is that it is quickly becoming a standard place to configure all Python tools. This means other developers will know to look here and you will keep your projects root nice and tidy. The only disadvantage is that other tools you use might not yet support this format, negating the cleanliness. [tool.isort] profile = \"hug\" src_paths = [\"isort\", \"test\"] setup.cfg setup.cfg can be thought of as the precursor to pyproject.toml . While isort and newer tools are increasingly moving to pyproject.toml, if you rely on many tools that use this standard it can be a natural fit to put your isort config there as well. [isort] profile = hug src_paths = isort,test tox.ini tox is a tool commonly used in the Python community to specify multiple testing environments. Because isort verification is commonly ran as a testing step, some prefer to place the isort config inside of the tox.ini file. [isort] .editorconfig Finally, isort will look for a .editorconfig configuration with settings for Python source files. EditorConfig is a project to enable specifying a configuration for text editing behaviour once, allowing multiple command line tools and text editors to pick it up. Since isort cares about a lot of the same settings as a text-editor (like line-length) it makes sense for it to look within these files as well. root = true [ * . py ] profile = hug indent_style = space indent_size = 4 skip = build ,. tox , venv src_paths = isort , test","title":"Config Files"},{"location":"docs/configuration/config_files/#supported-config-files","text":"isort supports a variety of standard config formats, to allow customizations to easily be integrated into any project. When applying configurations, isort looks for the closest supported config file, in the order files are listed below. You can manually specify the settings file or path by setting --settings-path from the commandline, otherwise isort will traverse up to 25 parent directories until it finds a suitable config file. As soon as it finds a file, it stops looking. isort never merges config files together due to the confusion it can cause. Tip You can always introspect the configuration settings isort determined, and find out which config file it picked up, by running isort . --show-config","title":"Supported Config Files"},{"location":"docs/configuration/config_files/#isortcfg-preferred-format","text":"The first place isort will look for settings is in dedicated .isort.cfg files. The advantage of using this kind of config file, is that it is explicitly for isort and follows a well understood format. The downside, is that it means one more config file in your project when you may already have several polluting your file hierarchy. An example a config from the isort project itself: [settings] profile = hug src_paths = isort,test","title":".isort.cfg [preferred format]"},{"location":"docs/configuration/config_files/#pyprojecttoml-preferred-format","text":"The second place isort will look, and an equally excellent choice to place your configuration, is within a pyproject.toml file. The advantage of using this config file, is that it is quickly becoming a standard place to configure all Python tools. This means other developers will know to look here and you will keep your projects root nice and tidy. The only disadvantage is that other tools you use might not yet support this format, negating the cleanliness. [tool.isort] profile = \"hug\" src_paths = [\"isort\", \"test\"]","title":"pyproject.toml [preferred format]"},{"location":"docs/configuration/config_files/#setupcfg","text":"setup.cfg can be thought of as the precursor to pyproject.toml . While isort and newer tools are increasingly moving to pyproject.toml, if you rely on many tools that use this standard it can be a natural fit to put your isort config there as well. [isort] profile = hug src_paths = isort,test","title":"setup.cfg"},{"location":"docs/configuration/config_files/#toxini","text":"tox is a tool commonly used in the Python community to specify multiple testing environments. Because isort verification is commonly ran as a testing step, some prefer to place the isort config inside of the tox.ini file. [isort]","title":"tox.ini"},{"location":"docs/configuration/config_files/#editorconfig","text":"Finally, isort will look for a .editorconfig configuration with settings for Python source files. EditorConfig is a project to enable specifying a configuration for text editing behaviour once, allowing multiple command line tools and text editors to pick it up. Since isort cares about a lot of the same settings as a text-editor (like line-length) it makes sense for it to look within these files as well. root = true [ * . py ] profile = hug indent_style = space indent_size = 4 skip = build ,. tox , venv src_paths = isort , test","title":".editorconfig"},{"location":"docs/configuration/options/","text":"Configuration options for isort As a code formatter isort has opinions. However, it also allows you to have your own. If your opinions disagree with those of isort, isort will disagree but commit to your way of formatting. To enable this, isort exposes a plethora of options to specify how you want your imports sorted, organized, and formatted. Too busy to build your perfect isort configuration? For curated common configurations, see isort's built-in profiles . Python Version Tells isort to set the known standard library based on the the specified Python version. Default is to assume any Python 3 version could be the target, and use a union off all stdlib modules across versions. If auto is specified, the version of the interpreter used to run isort (currently: 38) will be used. Type: String Default: py3 Python & Config File Name: py_version CLI Flags: --py --python-version Force To Top Force specific imports to the top of their appropriate section. Type: Frozenset Default: frozenset() Python & Config File Name: force_to_top CLI Flags: -t --top Skip Files that sort imports should skip over. If you want to skip multiple files you should specify twice: --skip file1 --skip file2. Type: Frozenset Default: frozenset({'node_modules', '.hg', '_build', 'dist', 'build', '.eggs', '.tox', '.nox', 'buck-out', '.mypy_cache', '.pants.d', '.venv', 'venv', '.git'}) Python & Config File Name: skip CLI Flags: -s --skip Skip Glob Files that sort imports should skip over. Type: Frozenset Default: frozenset() Python & Config File Name: skip_glob CLI Flags: --sg --skip-glob Line Length The max length of an import line (used for wrapping long imports). Type: Int Default: 79 Python & Config File Name: line_length CLI Flags: -l -w --line-length --line-width Wrap Length Specifies how long lines that are wrapped should be, if not set line_length is used. NOTE: wrap_length must be LOWER than or equal to line_length. Type: Int Default: 0 Python & Config File Name: wrap_length CLI Flags: --wl --wrap-length Line Ending Forces line endings to the specified value. If not set, values will be guessed per-file. Type: String Default: `` Python & Config File Name: line_ending CLI Flags: --le --line-ending Sections No Description Type: Tuple Default: ('FUTURE', 'STDLIB', 'THIRDPARTY', 'FIRSTPARTY', 'LOCALFOLDER') Python & Config File Name: sections CLI Flags: Not Supported No Sections Put all imports into the same section bucket Type: Bool Default: False Python & Config File Name: no_sections CLI Flags: --ds --no-sections Known Future Library Force isort to recognize a module as part of the future compatibility libraries. Type: Frozenset Default: frozenset({'__future__'}) Python & Config File Name: known_future_library CLI Flags: -f --future Known Third Party Force isort to recognize a module as being part of a third party library. Type: Frozenset Default: frozenset({'google.appengine.api'}) Python & Config File Name: known_third_party CLI Flags: -o --thirdparty Known First Party Force isort to recognize a module as being part of the current python project. Type: Frozenset Default: frozenset() Python & Config File Name: known_first_party CLI Flags: -p --project Known Standard Library Force isort to recognize a module as part of Python's standard library. Type: Frozenset Default: frozenset({'distutils', 'webbrowser', 'codeop', 'binhex', 'tempfile', 'platform', 'struct', 'base64', 'calendar', 'ast', 'abc', 'pwd', 'spwd', 'plistlib', 'numbers', 'secrets', 'signal', 'grp', 'unittest', 'statistics', 'typing', 'imaplib', 'multiprocessing', 'uuid', 'wsgiref', 'email', 'tokenize', 'getpass', 'asynchat', 'imp', 'mmap', 'sys', 'colorsys', 'cmath', 'tabnanny', 'rlcompleter', 'json', 'sqlite3', 'pprint', 'copyreg', 'zipapp', 'contextvars', 'tarfile', 'telnetlib', 'fileinput', 'modulefinder', 'curses', 'syslog', 'imghdr', 'copy', 'msvcrt', 'cgi', 'weakref', 'datetime', 'dataclasses', 'optparse', 'locale', 'ossaudiodev', '_thread', 'fcntl', 'sched', 'zipfile', 'subprocess', 'formatter', 'operator', 'xml', 'faulthandler', 'dummy_threading', 'shlex', 'argparse', 'trace', 'ntpath', 'unicodedata', 'uu', 'symbol', 'atexit', 'ipaddress', 'runpy', 'binascii', 'doctest', 'termios', 'lzma', 'pdb', 'shutil', 'readline', 'zlib', 're', 'zipimport', 'audioop', 'quopri', 'sndhdr', 'venv', 'msilib', 'array', 'symtable', 'encodings', 'timeit', 'nis', 'http', 'fnmatch', 'codecs', 'stat', 'csv', 'site', 'mimetypes', 'inspect', 'poplib', 'getopt', 'pipes', 'select', 'configparser', 'dbm', 'time', 'html', 'os', 'logging', 'types', 'chunk', 'winreg', 'nntplib', 'compileall', 'pydoc', 'bisect', 'warnings', 'py_compile', 'random', 'importlib', 'cProfile', 'tty', 'linecache', 'shelve', 'parser', 'gc', 'mailbox', 'reprlib', 'token', 'turtledemo', 'pty', 'contextlib', 'hmac', 'socket', 'asyncore', 'keyword', 'pkgutil', 'aifc', 'bdb', 'queue', 'xdrlib', 'ctypes', 'dis', 'ftplib', 'gzip', 'smtplib', 'code', 'pickle', 'socketserver', 'fpectl', 'resource', 'sunau', 'io', 'bz2', 'decimal', 'traceback', 'hashlib', 'smtpd', 'itertools', 'concurrent', 'textwrap', 'pstats', 'tracemalloc', 'sysconfig', 'errno', 'mailcap', 'pickletools', 'test', 'pathlib', 'functools', 'tkinter', 'xmlrpc', 'ensurepip', 'string', 'enum', '_dummy_thread', 'profile', 'glob', 'math', 'posixpath', 'builtins', 'fractions', 'crypt', 'urllib', 'gettext', 'ssl', 'sre_constants', 'collections', 'asyncio', 'netrc', 'filecmp', 'turtle', 'stringprep', 'selectors', 'heapq', 'macpath', 'winsound', 'marshal', 'posix', 'pyclbr', 'cgitb', 'difflib', 'threading', 'wave', 'cmd', 'lib2to3'}) Python & Config File Name: known_standard_library CLI Flags: -b --builtin Extra Standard Library Extra modules to be included in the list of ones in Python's standard library. Type: Frozenset Default: frozenset() Python & Config File Name: extra_standard_library CLI Flags: --extra-builtin Known Other No Description Type: Dict Default: {} Python & Config File Name: known_other CLI Flags: Not Supported Multi Line Output Multi line output (0-grid, 1-vertical, 2-hanging, 3-vert-hanging, 4-vert-grid, 5-vert-grid-grouped, 6-vert-grid-grouped-no-comma). Type: Wrapmodes Default: WrapModes.GRID Python & Config File Name: multi_line_output CLI Flags: -m --multi-line Forced Separate No Description Type: Tuple Default: () Python & Config File Name: forced_separate CLI Flags: Not Supported Indent String to place for indents defaults to \" \" (4 spaces). Type: String Default: Python & Config File Name: indent CLI Flags: -i --indent Comment Prefix No Description Type: String Default: # Python & Config File Name: comment_prefix CLI Flags: Not Supported Length Sort Sort imports by their string length. Type: Bool Default: False Python & Config File Name: length_sort CLI Flags: --ls --length-sort Length Sort Sections No Description Type: Frozenset Default: frozenset() Python & Config File Name: length_sort_sections CLI Flags: Not Supported Add Imports Adds the specified import line to all files, automatically determining correct placement. Type: Frozenset Default: frozenset() Python & Config File Name: add_imports CLI Flags: -a --add-import Remove Imports Removes the specified import from all files. Type: Frozenset Default: frozenset() Python & Config File Name: remove_imports CLI Flags: --rm --remove-import Reverse Relative Reverse order of relative imports. Type: Bool Default: False Python & Config File Name: reverse_relative CLI Flags: --rr --reverse-relative Force Single Line Forces all from imports to appear on their own line Type: Bool Default: False Python & Config File Name: force_single_line CLI Flags: --sl --force-single-line-imports Single Line Exclusions One or more modules to exclude from the single line rule. Type: Tuple Default: () Python & Config File Name: single_line_exclusions CLI Flags: --nsl --single-line-exclusions Default Section Sets the default section for imports (by default FIRSTPARTY) options: ('FUTURE', 'STDLIB', 'THIRDPARTY', 'FIRSTPARTY', 'LOCALFOLDER') Type: String Default: THIRDPARTY Python & Config File Name: default_section CLI Flags: --sd --section-default Import Headings No Description Type: Dict Default: {} Python & Config File Name: import_headings CLI Flags: Not Supported Balanced Wrapping Balances wrapping to produce the most consistent line length possible Type: Bool Default: False Python & Config File Name: balanced_wrapping CLI Flags: -e --balanced Use Parentheses Use parenthesis for line continuation on length limit instead of slashes. Type: Bool Default: False Python & Config File Name: use_parentheses CLI Flags: --up --use-parentheses Order By Type Order imports by type in addition to alphabetically Type: Bool Default: True Python & Config File Name: order_by_type CLI Flags: --ot --order-by-type Atomic Ensures the output doesn't save if the resulting file contains syntax errors. Type: Bool Default: False Python & Config File Name: atomic CLI Flags: --ac --atomic Lines After Imports No Description Type: Int Default: -1 Python & Config File Name: lines_after_imports CLI Flags: --lai --lines-after-imports Lines Between Sections No Description Type: Int Default: 1 Python & Config File Name: lines_between_sections CLI Flags: Not Supported Lines Between Types No Description Type: Int Default: 0 Python & Config File Name: lines_between_types CLI Flags: --lbt --lines-between-types Combine As Imports Combines as imports on the same line. Type: Bool Default: False Python & Config File Name: combine_as_imports CLI Flags: --ca --combine-as Combine Star Ensures that if a star import is present, nothing else is imported from that namespace. Type: Bool Default: False Python & Config File Name: combine_star CLI Flags: --cs --combine-star Keep Direct And As Imports Turns off default behavior that removes direct imports when as imports exist. Type: Bool Default: True Python & Config File Name: keep_direct_and_as_imports CLI Flags: -k --keep-direct-and-as Include Trailing Comma Includes a trailing comma on multi line imports that include parentheses. Type: Bool Default: False Python & Config File Name: include_trailing_comma CLI Flags: --tc --trailing-comma From First Switches the typical ordering preference, showing from imports first then straight ones. Type: Bool Default: False Python & Config File Name: from_first CLI Flags: --ff --from-first Verbose Shows verbose output, such as when files are skipped or when a check is successful. Type: Bool Default: False Python & Config File Name: verbose CLI Flags: -v --verbose Quiet Shows extra quiet output, only errors are outputted. Type: Bool Default: False Python & Config File Name: quiet CLI Flags: -q --quiet Force Adds Forces import adds even if the original file is empty. Type: Bool Default: False Python & Config File Name: force_adds CLI Flags: --af --force-adds Force Alphabetical Sort Within Sections No Description Type: Bool Default: False Python & Config File Name: force_alphabetical_sort_within_sections CLI Flags: Not Supported Force Alphabetical Sort Force all imports to be sorted alphabetically within a section Type: Bool Default: False Python & Config File Name: force_alphabetical_sort CLI Flags: --fass --force-alphabetical-sort-within-sections Force Grid Wrap Force number of from imports (defaults to 2) to be grid wrapped regardless of line length Type: Int Default: 0 Python & Config File Name: force_grid_wrap CLI Flags: --fgw --force-grid-wrap Force Sort Within Sections Force imports to be sorted by module, independent of import_type Type: Bool Default: False Python & Config File Name: force_sort_within_sections CLI Flags: --fss --force-sort-within-sections Lexicographical No Description Type: Bool Default: False Python & Config File Name: lexicographical CLI Flags: Not Supported Ignore Whitespace Tells isort to ignore whitespace differences when --check-only is being used. Type: Bool Default: False Python & Config File Name: ignore_whitespace CLI Flags: --ws --ignore-whitespace No Lines Before Sections which should not be split with previous by empty lines Type: Frozenset Default: frozenset() Python & Config File Name: no_lines_before CLI Flags: --nlb --no-lines-before No Inline Sort Leaves from imports with multiple imports 'as-is' (e.g. from foo import a, c ,b ). Type: Bool Default: False Python & Config File Name: no_inline_sort CLI Flags: --nis --no-inline-sort Ignore Comments No Description Type: Bool Default: False Python & Config File Name: ignore_comments CLI Flags: Not Supported Case Sensitive Tells isort to include casing when sorting module names Type: Bool Default: False Python & Config File Name: case_sensitive CLI Flags: --case-sensitive Sources No Description Type: Tuple Default: () Python & Config File Name: sources CLI Flags: Not Supported Virtual Env Virtual environment to use for determining whether a package is third-party Type: String Default: `` Python & Config File Name: virtual_env CLI Flags: --virtual-env Conda Env Conda environment to use for determining whether a package is third-party Type: String Default: `` Python & Config File Name: conda_env CLI Flags: --conda-env Ensure Newline Before Comments Inserts a blank line before a comment following an import. Type: Bool Default: False Python & Config File Name: ensure_newline_before_comments CLI Flags: -n --ensure-newline-before-comments Directory No Description Type: String Default: `` Python & Config File Name: directory CLI Flags: Not Supported Profile Base profile type to use for configuration. Type: String Default: `` Python & Config File Name: profile CLI Flags: --profile Src Paths Add an explicitly defined source path (modules within src paths have their imports automatically catorgorized as first_party). Type: Frozenset Default: frozenset() Python & Config File Name: src_paths CLI Flags: --src --src-path Old Finders Use the old deprecated finder logic that relies on environment introspection magic. Type: Bool Default: False Python & Config File Name: old_finders CLI Flags: --old-finders --magic-placement Check Checks the file for unsorted / unformatted imports and prints them to the command line without modifying the file. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: -c --check-only --check Write To Stdout Force resulting output to stdout, instead of in-place. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: -d --stdout Show Diff Prints a diff of all the changes isort would make to a file, instead of changing it in place Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --df --diff Jobs Number of files to process in parallel. Type: Int Default: None Python & Config File Name: Not Supported CLI Flags: -j --jobs Dont Order By Type Don't order imports by type in addition to alphabetically Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --dt --dont-order-by-type Settings Path Explicitly set the settings path or file instead of auto determining based on file location. Type: String Default: None Python & Config File Name: Not Supported CLI Flags: --sp --settings-path --settings-file --settings Show Version Displays the currently installed version of isort. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: -V --version Version Number Returns just the current version number without the logo Type: String Default: ==SUPPRESS== Python & Config File Name: Not Supported CLI Flags: --vn --version-number Filter Files Tells isort to filter files even when they are explicitly passed in as part of the command Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --filter-files Files One or more Python source files that need their imports sorted. Type: String Default: None Python & Config File Name: Not Supported CLI Flags: Ask To Apply Tells isort to apply changes interactively. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --interactive Show Config See isort's determined config, as well as sources of config options. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --show-config","title":"Options"},{"location":"docs/configuration/options/#configuration-options-for-isort","text":"As a code formatter isort has opinions. However, it also allows you to have your own. If your opinions disagree with those of isort, isort will disagree but commit to your way of formatting. To enable this, isort exposes a plethora of options to specify how you want your imports sorted, organized, and formatted. Too busy to build your perfect isort configuration? For curated common configurations, see isort's built-in profiles .","title":"Configuration options for isort"},{"location":"docs/configuration/options/#python-version","text":"Tells isort to set the known standard library based on the the specified Python version. Default is to assume any Python 3 version could be the target, and use a union off all stdlib modules across versions. If auto is specified, the version of the interpreter used to run isort (currently: 38) will be used. Type: String Default: py3 Python & Config File Name: py_version CLI Flags: --py --python-version","title":"Python Version"},{"location":"docs/configuration/options/#force-to-top","text":"Force specific imports to the top of their appropriate section. Type: Frozenset Default: frozenset() Python & Config File Name: force_to_top CLI Flags: -t --top","title":"Force To Top"},{"location":"docs/configuration/options/#skip","text":"Files that sort imports should skip over. If you want to skip multiple files you should specify twice: --skip file1 --skip file2. Type: Frozenset Default: frozenset({'node_modules', '.hg', '_build', 'dist', 'build', '.eggs', '.tox', '.nox', 'buck-out', '.mypy_cache', '.pants.d', '.venv', 'venv', '.git'}) Python & Config File Name: skip CLI Flags: -s --skip","title":"Skip"},{"location":"docs/configuration/options/#skip-glob","text":"Files that sort imports should skip over. Type: Frozenset Default: frozenset() Python & Config File Name: skip_glob CLI Flags: --sg --skip-glob","title":"Skip Glob"},{"location":"docs/configuration/options/#line-length","text":"The max length of an import line (used for wrapping long imports). Type: Int Default: 79 Python & Config File Name: line_length CLI Flags: -l -w --line-length --line-width","title":"Line Length"},{"location":"docs/configuration/options/#wrap-length","text":"Specifies how long lines that are wrapped should be, if not set line_length is used. NOTE: wrap_length must be LOWER than or equal to line_length. Type: Int Default: 0 Python & Config File Name: wrap_length CLI Flags: --wl --wrap-length","title":"Wrap Length"},{"location":"docs/configuration/options/#line-ending","text":"Forces line endings to the specified value. If not set, values will be guessed per-file. Type: String Default: `` Python & Config File Name: line_ending CLI Flags: --le --line-ending","title":"Line Ending"},{"location":"docs/configuration/options/#sections","text":"No Description Type: Tuple Default: ('FUTURE', 'STDLIB', 'THIRDPARTY', 'FIRSTPARTY', 'LOCALFOLDER') Python & Config File Name: sections CLI Flags: Not Supported","title":"Sections"},{"location":"docs/configuration/options/#no-sections","text":"Put all imports into the same section bucket Type: Bool Default: False Python & Config File Name: no_sections CLI Flags: --ds --no-sections","title":"No Sections"},{"location":"docs/configuration/options/#known-future-library","text":"Force isort to recognize a module as part of the future compatibility libraries. Type: Frozenset Default: frozenset({'__future__'}) Python & Config File Name: known_future_library CLI Flags: -f --future","title":"Known Future Library"},{"location":"docs/configuration/options/#known-third-party","text":"Force isort to recognize a module as being part of a third party library. Type: Frozenset Default: frozenset({'google.appengine.api'}) Python & Config File Name: known_third_party CLI Flags: -o --thirdparty","title":"Known Third Party"},{"location":"docs/configuration/options/#known-first-party","text":"Force isort to recognize a module as being part of the current python project. Type: Frozenset Default: frozenset() Python & Config File Name: known_first_party CLI Flags: -p --project","title":"Known First Party"},{"location":"docs/configuration/options/#known-standard-library","text":"Force isort to recognize a module as part of Python's standard library. Type: Frozenset Default: frozenset({'distutils', 'webbrowser', 'codeop', 'binhex', 'tempfile', 'platform', 'struct', 'base64', 'calendar', 'ast', 'abc', 'pwd', 'spwd', 'plistlib', 'numbers', 'secrets', 'signal', 'grp', 'unittest', 'statistics', 'typing', 'imaplib', 'multiprocessing', 'uuid', 'wsgiref', 'email', 'tokenize', 'getpass', 'asynchat', 'imp', 'mmap', 'sys', 'colorsys', 'cmath', 'tabnanny', 'rlcompleter', 'json', 'sqlite3', 'pprint', 'copyreg', 'zipapp', 'contextvars', 'tarfile', 'telnetlib', 'fileinput', 'modulefinder', 'curses', 'syslog', 'imghdr', 'copy', 'msvcrt', 'cgi', 'weakref', 'datetime', 'dataclasses', 'optparse', 'locale', 'ossaudiodev', '_thread', 'fcntl', 'sched', 'zipfile', 'subprocess', 'formatter', 'operator', 'xml', 'faulthandler', 'dummy_threading', 'shlex', 'argparse', 'trace', 'ntpath', 'unicodedata', 'uu', 'symbol', 'atexit', 'ipaddress', 'runpy', 'binascii', 'doctest', 'termios', 'lzma', 'pdb', 'shutil', 'readline', 'zlib', 're', 'zipimport', 'audioop', 'quopri', 'sndhdr', 'venv', 'msilib', 'array', 'symtable', 'encodings', 'timeit', 'nis', 'http', 'fnmatch', 'codecs', 'stat', 'csv', 'site', 'mimetypes', 'inspect', 'poplib', 'getopt', 'pipes', 'select', 'configparser', 'dbm', 'time', 'html', 'os', 'logging', 'types', 'chunk', 'winreg', 'nntplib', 'compileall', 'pydoc', 'bisect', 'warnings', 'py_compile', 'random', 'importlib', 'cProfile', 'tty', 'linecache', 'shelve', 'parser', 'gc', 'mailbox', 'reprlib', 'token', 'turtledemo', 'pty', 'contextlib', 'hmac', 'socket', 'asyncore', 'keyword', 'pkgutil', 'aifc', 'bdb', 'queue', 'xdrlib', 'ctypes', 'dis', 'ftplib', 'gzip', 'smtplib', 'code', 'pickle', 'socketserver', 'fpectl', 'resource', 'sunau', 'io', 'bz2', 'decimal', 'traceback', 'hashlib', 'smtpd', 'itertools', 'concurrent', 'textwrap', 'pstats', 'tracemalloc', 'sysconfig', 'errno', 'mailcap', 'pickletools', 'test', 'pathlib', 'functools', 'tkinter', 'xmlrpc', 'ensurepip', 'string', 'enum', '_dummy_thread', 'profile', 'glob', 'math', 'posixpath', 'builtins', 'fractions', 'crypt', 'urllib', 'gettext', 'ssl', 'sre_constants', 'collections', 'asyncio', 'netrc', 'filecmp', 'turtle', 'stringprep', 'selectors', 'heapq', 'macpath', 'winsound', 'marshal', 'posix', 'pyclbr', 'cgitb', 'difflib', 'threading', 'wave', 'cmd', 'lib2to3'}) Python & Config File Name: known_standard_library CLI Flags: -b --builtin","title":"Known Standard Library"},{"location":"docs/configuration/options/#extra-standard-library","text":"Extra modules to be included in the list of ones in Python's standard library. Type: Frozenset Default: frozenset() Python & Config File Name: extra_standard_library CLI Flags: --extra-builtin","title":"Extra Standard Library"},{"location":"docs/configuration/options/#known-other","text":"No Description Type: Dict Default: {} Python & Config File Name: known_other CLI Flags: Not Supported","title":"Known Other"},{"location":"docs/configuration/options/#multi-line-output","text":"Multi line output (0-grid, 1-vertical, 2-hanging, 3-vert-hanging, 4-vert-grid, 5-vert-grid-grouped, 6-vert-grid-grouped-no-comma). Type: Wrapmodes Default: WrapModes.GRID Python & Config File Name: multi_line_output CLI Flags: -m --multi-line","title":"Multi Line Output"},{"location":"docs/configuration/options/#forced-separate","text":"No Description Type: Tuple Default: () Python & Config File Name: forced_separate CLI Flags: Not Supported","title":"Forced Separate"},{"location":"docs/configuration/options/#indent","text":"String to place for indents defaults to \" \" (4 spaces). Type: String Default: Python & Config File Name: indent CLI Flags: -i --indent","title":"Indent"},{"location":"docs/configuration/options/#comment-prefix","text":"No Description Type: String Default: # Python & Config File Name: comment_prefix CLI Flags: Not Supported","title":"Comment Prefix"},{"location":"docs/configuration/options/#length-sort","text":"Sort imports by their string length. Type: Bool Default: False Python & Config File Name: length_sort CLI Flags: --ls --length-sort","title":"Length Sort"},{"location":"docs/configuration/options/#length-sort-sections","text":"No Description Type: Frozenset Default: frozenset() Python & Config File Name: length_sort_sections CLI Flags: Not Supported","title":"Length Sort Sections"},{"location":"docs/configuration/options/#add-imports","text":"Adds the specified import line to all files, automatically determining correct placement. Type: Frozenset Default: frozenset() Python & Config File Name: add_imports CLI Flags: -a --add-import","title":"Add Imports"},{"location":"docs/configuration/options/#remove-imports","text":"Removes the specified import from all files. Type: Frozenset Default: frozenset() Python & Config File Name: remove_imports CLI Flags: --rm --remove-import","title":"Remove Imports"},{"location":"docs/configuration/options/#reverse-relative","text":"Reverse order of relative imports. Type: Bool Default: False Python & Config File Name: reverse_relative CLI Flags: --rr --reverse-relative","title":"Reverse Relative"},{"location":"docs/configuration/options/#force-single-line","text":"Forces all from imports to appear on their own line Type: Bool Default: False Python & Config File Name: force_single_line CLI Flags: --sl --force-single-line-imports","title":"Force Single Line"},{"location":"docs/configuration/options/#single-line-exclusions","text":"One or more modules to exclude from the single line rule. Type: Tuple Default: () Python & Config File Name: single_line_exclusions CLI Flags: --nsl --single-line-exclusions","title":"Single Line Exclusions"},{"location":"docs/configuration/options/#default-section","text":"Sets the default section for imports (by default FIRSTPARTY) options: ('FUTURE', 'STDLIB', 'THIRDPARTY', 'FIRSTPARTY', 'LOCALFOLDER') Type: String Default: THIRDPARTY Python & Config File Name: default_section CLI Flags: --sd --section-default","title":"Default Section"},{"location":"docs/configuration/options/#import-headings","text":"No Description Type: Dict Default: {} Python & Config File Name: import_headings CLI Flags: Not Supported","title":"Import Headings"},{"location":"docs/configuration/options/#balanced-wrapping","text":"Balances wrapping to produce the most consistent line length possible Type: Bool Default: False Python & Config File Name: balanced_wrapping CLI Flags: -e --balanced","title":"Balanced Wrapping"},{"location":"docs/configuration/options/#use-parentheses","text":"Use parenthesis for line continuation on length limit instead of slashes. Type: Bool Default: False Python & Config File Name: use_parentheses CLI Flags: --up --use-parentheses","title":"Use Parentheses"},{"location":"docs/configuration/options/#order-by-type","text":"Order imports by type in addition to alphabetically Type: Bool Default: True Python & Config File Name: order_by_type CLI Flags: --ot --order-by-type","title":"Order By Type"},{"location":"docs/configuration/options/#atomic","text":"Ensures the output doesn't save if the resulting file contains syntax errors. Type: Bool Default: False Python & Config File Name: atomic CLI Flags: --ac --atomic","title":"Atomic"},{"location":"docs/configuration/options/#lines-after-imports","text":"No Description Type: Int Default: -1 Python & Config File Name: lines_after_imports CLI Flags: --lai --lines-after-imports","title":"Lines After Imports"},{"location":"docs/configuration/options/#lines-between-sections","text":"No Description Type: Int Default: 1 Python & Config File Name: lines_between_sections CLI Flags: Not Supported","title":"Lines Between Sections"},{"location":"docs/configuration/options/#lines-between-types","text":"No Description Type: Int Default: 0 Python & Config File Name: lines_between_types CLI Flags: --lbt --lines-between-types","title":"Lines Between Types"},{"location":"docs/configuration/options/#combine-as-imports","text":"Combines as imports on the same line. Type: Bool Default: False Python & Config File Name: combine_as_imports CLI Flags: --ca --combine-as","title":"Combine As Imports"},{"location":"docs/configuration/options/#combine-star","text":"Ensures that if a star import is present, nothing else is imported from that namespace. Type: Bool Default: False Python & Config File Name: combine_star CLI Flags: --cs --combine-star","title":"Combine Star"},{"location":"docs/configuration/options/#keep-direct-and-as-imports","text":"Turns off default behavior that removes direct imports when as imports exist. Type: Bool Default: True Python & Config File Name: keep_direct_and_as_imports CLI Flags: -k --keep-direct-and-as","title":"Keep Direct And As Imports"},{"location":"docs/configuration/options/#include-trailing-comma","text":"Includes a trailing comma on multi line imports that include parentheses. Type: Bool Default: False Python & Config File Name: include_trailing_comma CLI Flags: --tc --trailing-comma","title":"Include Trailing Comma"},{"location":"docs/configuration/options/#from-first","text":"Switches the typical ordering preference, showing from imports first then straight ones. Type: Bool Default: False Python & Config File Name: from_first CLI Flags: --ff --from-first","title":"From First"},{"location":"docs/configuration/options/#verbose","text":"Shows verbose output, such as when files are skipped or when a check is successful. Type: Bool Default: False Python & Config File Name: verbose CLI Flags: -v --verbose","title":"Verbose"},{"location":"docs/configuration/options/#quiet","text":"Shows extra quiet output, only errors are outputted. Type: Bool Default: False Python & Config File Name: quiet CLI Flags: -q --quiet","title":"Quiet"},{"location":"docs/configuration/options/#force-adds","text":"Forces import adds even if the original file is empty. Type: Bool Default: False Python & Config File Name: force_adds CLI Flags: --af --force-adds","title":"Force Adds"},{"location":"docs/configuration/options/#force-alphabetical-sort-within-sections","text":"No Description Type: Bool Default: False Python & Config File Name: force_alphabetical_sort_within_sections CLI Flags: Not Supported","title":"Force Alphabetical Sort Within Sections"},{"location":"docs/configuration/options/#force-alphabetical-sort","text":"Force all imports to be sorted alphabetically within a section Type: Bool Default: False Python & Config File Name: force_alphabetical_sort CLI Flags: --fass --force-alphabetical-sort-within-sections","title":"Force Alphabetical Sort"},{"location":"docs/configuration/options/#force-grid-wrap","text":"Force number of from imports (defaults to 2) to be grid wrapped regardless of line length Type: Int Default: 0 Python & Config File Name: force_grid_wrap CLI Flags: --fgw --force-grid-wrap","title":"Force Grid Wrap"},{"location":"docs/configuration/options/#force-sort-within-sections","text":"Force imports to be sorted by module, independent of import_type Type: Bool Default: False Python & Config File Name: force_sort_within_sections CLI Flags: --fss --force-sort-within-sections","title":"Force Sort Within Sections"},{"location":"docs/configuration/options/#lexicographical","text":"No Description Type: Bool Default: False Python & Config File Name: lexicographical CLI Flags: Not Supported","title":"Lexicographical"},{"location":"docs/configuration/options/#ignore-whitespace","text":"Tells isort to ignore whitespace differences when --check-only is being used. Type: Bool Default: False Python & Config File Name: ignore_whitespace CLI Flags: --ws --ignore-whitespace","title":"Ignore Whitespace"},{"location":"docs/configuration/options/#no-lines-before","text":"Sections which should not be split with previous by empty lines Type: Frozenset Default: frozenset() Python & Config File Name: no_lines_before CLI Flags: --nlb --no-lines-before","title":"No Lines Before"},{"location":"docs/configuration/options/#no-inline-sort","text":"Leaves from imports with multiple imports 'as-is' (e.g. from foo import a, c ,b ). Type: Bool Default: False Python & Config File Name: no_inline_sort CLI Flags: --nis --no-inline-sort","title":"No Inline Sort"},{"location":"docs/configuration/options/#ignore-comments","text":"No Description Type: Bool Default: False Python & Config File Name: ignore_comments CLI Flags: Not Supported","title":"Ignore Comments"},{"location":"docs/configuration/options/#case-sensitive","text":"Tells isort to include casing when sorting module names Type: Bool Default: False Python & Config File Name: case_sensitive CLI Flags: --case-sensitive","title":"Case Sensitive"},{"location":"docs/configuration/options/#sources","text":"No Description Type: Tuple Default: () Python & Config File Name: sources CLI Flags: Not Supported","title":"Sources"},{"location":"docs/configuration/options/#virtual-env","text":"Virtual environment to use for determining whether a package is third-party Type: String Default: `` Python & Config File Name: virtual_env CLI Flags: --virtual-env","title":"Virtual Env"},{"location":"docs/configuration/options/#conda-env","text":"Conda environment to use for determining whether a package is third-party Type: String Default: `` Python & Config File Name: conda_env CLI Flags: --conda-env","title":"Conda Env"},{"location":"docs/configuration/options/#ensure-newline-before-comments","text":"Inserts a blank line before a comment following an import. Type: Bool Default: False Python & Config File Name: ensure_newline_before_comments CLI Flags: -n --ensure-newline-before-comments","title":"Ensure Newline Before Comments"},{"location":"docs/configuration/options/#directory","text":"No Description Type: String Default: `` Python & Config File Name: directory CLI Flags: Not Supported","title":"Directory"},{"location":"docs/configuration/options/#profile","text":"Base profile type to use for configuration. Type: String Default: `` Python & Config File Name: profile CLI Flags: --profile","title":"Profile"},{"location":"docs/configuration/options/#src-paths","text":"Add an explicitly defined source path (modules within src paths have their imports automatically catorgorized as first_party). Type: Frozenset Default: frozenset() Python & Config File Name: src_paths CLI Flags: --src --src-path","title":"Src Paths"},{"location":"docs/configuration/options/#old-finders","text":"Use the old deprecated finder logic that relies on environment introspection magic. Type: Bool Default: False Python & Config File Name: old_finders CLI Flags: --old-finders --magic-placement","title":"Old Finders"},{"location":"docs/configuration/options/#check","text":"Checks the file for unsorted / unformatted imports and prints them to the command line without modifying the file. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: -c --check-only --check","title":"Check"},{"location":"docs/configuration/options/#write-to-stdout","text":"Force resulting output to stdout, instead of in-place. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: -d --stdout","title":"Write To Stdout"},{"location":"docs/configuration/options/#show-diff","text":"Prints a diff of all the changes isort would make to a file, instead of changing it in place Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --df --diff","title":"Show Diff"},{"location":"docs/configuration/options/#jobs","text":"Number of files to process in parallel. Type: Int Default: None Python & Config File Name: Not Supported CLI Flags: -j --jobs","title":"Jobs"},{"location":"docs/configuration/options/#dont-order-by-type","text":"Don't order imports by type in addition to alphabetically Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --dt --dont-order-by-type","title":"Dont Order By Type"},{"location":"docs/configuration/options/#settings-path","text":"Explicitly set the settings path or file instead of auto determining based on file location. Type: String Default: None Python & Config File Name: Not Supported CLI Flags: --sp --settings-path --settings-file --settings","title":"Settings Path"},{"location":"docs/configuration/options/#show-version","text":"Displays the currently installed version of isort. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: -V --version","title":"Show Version"},{"location":"docs/configuration/options/#version-number","text":"Returns just the current version number without the logo Type: String Default: ==SUPPRESS== Python & Config File Name: Not Supported CLI Flags: --vn --version-number","title":"Version Number"},{"location":"docs/configuration/options/#filter-files","text":"Tells isort to filter files even when they are explicitly passed in as part of the command Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --filter-files","title":"Filter Files"},{"location":"docs/configuration/options/#files","text":"One or more Python source files that need their imports sorted. Type: String Default: None Python & Config File Name: Not Supported CLI Flags:","title":"Files"},{"location":"docs/configuration/options/#ask-to-apply","text":"Tells isort to apply changes interactively. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --interactive","title":"Ask To Apply"},{"location":"docs/configuration/options/#show-config","text":"See isort's determined config, as well as sources of config options. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --show-config","title":"Show Config"},{"location":"docs/configuration/profiles/","text":"Built-in Profile for isort The following profiles are built into isort to allow easy interoperability with common projects and code styles. To use any of the listed profiles, use isort --profile PROFILE_NAME from the command line, or profile=PROFILE_NAME in your configuration file. black multi_line_output : 3 include_trailing_comma : True force_grid_wrap : 0 use_parentheses : True ensure_newline_before_comments : True line_length : 88 django combine_as_imports : True include_trailing_comma : True multi_line_output : 5 line_length : 79 pycharm multi_line_output : 3 force_grid_wrap : 2 google force_single_line : True force_sort_within_sections : True lexicographical : True single_line_exclusions : ('typing',) open_stack force_single_line : True force_sort_within_sections : True lexicographical : True plone force_alphabetical_sort : True force_single_line : True ines_after_imports : 2 line_length : 200 attrs atomic : True force_grid_wrap : 0 include_trailing_comma : True lines_after_imports : 2 lines_between_types : 1 multi_line_output : 3 not_skip : '__init__.py' use_parentheses : True hug multi_line_output : 3 include_trailing_comma : True force_grid_wrap : 0 use_parentheses : True line_length : 100","title":"Profiles"},{"location":"docs/configuration/profiles/#built-in-profile-for-isort","text":"The following profiles are built into isort to allow easy interoperability with common projects and code styles. To use any of the listed profiles, use isort --profile PROFILE_NAME from the command line, or profile=PROFILE_NAME in your configuration file.","title":"Built-in Profile for isort"},{"location":"docs/configuration/profiles/#black","text":"multi_line_output : 3 include_trailing_comma : True force_grid_wrap : 0 use_parentheses : True ensure_newline_before_comments : True line_length : 88","title":"black"},{"location":"docs/configuration/profiles/#django","text":"combine_as_imports : True include_trailing_comma : True multi_line_output : 5 line_length : 79","title":"django"},{"location":"docs/configuration/profiles/#pycharm","text":"multi_line_output : 3 force_grid_wrap : 2","title":"pycharm"},{"location":"docs/configuration/profiles/#google","text":"force_single_line : True force_sort_within_sections : True lexicographical : True single_line_exclusions : ('typing',)","title":"google"},{"location":"docs/configuration/profiles/#open_stack","text":"force_single_line : True force_sort_within_sections : True lexicographical : True","title":"open_stack"},{"location":"docs/configuration/profiles/#plone","text":"force_alphabetical_sort : True force_single_line : True ines_after_imports : 2 line_length : 200","title":"plone"},{"location":"docs/configuration/profiles/#attrs","text":"atomic : True force_grid_wrap : 0 include_trailing_comma : True lines_after_imports : 2 lines_between_types : 1 multi_line_output : 3 not_skip : '__init__.py' use_parentheses : True","title":"attrs"},{"location":"docs/configuration/profiles/#hug","text":"multi_line_output : 3 include_trailing_comma : True force_grid_wrap : 0 use_parentheses : True line_length : 100","title":"hug"},{"location":"docs/contributing/1.-contributing-guide/","text":"Contributing to isort Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place. Getting isort set up for local development The first step when contributing to any project is getting it set up on your local machine. isort aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) WSL users running Ubuntu may need to install Python's venv module even after installing Python. Once you have verified that your system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/isort.git cd isort poetry install Optionally, isolate poetry's installation from the rest of your system using the instructions on the poetry site here: https://python-poetry.org/docs/#installation ./scripts/test.sh should yield Success: no issues found ./scripts/clean.sh should yield a Safety report checking packages TIP : ./scripts/done.sh will run both clean and test in one step. Docker development If you would instead like to develop using Docker, the only local requirement is docker. See the docker docs if you have not used docker before. Once you have the docker daemon running and have cloned the repository, you can get started by following these steps: cd isort ./scripts/docker.sh A local test cycle might look like the following: docker build ./ -t isort:latest docker run isort if #2 fails, debug, save, and goto #1 docker run -it isort bash will get you into the failed environment docker run -v $(git rev-parse --show-toplevel):/isort will make changes made in the docker environment persist on your local checkout. TIP : combine both to get an interacive docker shell that loads changes made locally, even after build, to quickly rerun that pesky failing test ./scripts/docker.sh if #4 fails, debug, save and goto #1; you may need to specify a different --build-arg VERSION=$VER congrats! you are probably ready to push a contribution Making a contribution Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main isort project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the HOPE-8 Coding Standard used by the project. Run tests locally to make sure everything is still working ./scripts/done.sh Or if you are using Docker docker run isort:latest Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :). Thank you! I can not tell you how thankful I am for the hard work done by isort contributors like you . Thank you! ~Timothy Crosley","title":"1. Contributing Guide"},{"location":"docs/contributing/1.-contributing-guide/#contributing-to-isort","text":"Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place.","title":"Contributing to isort"},{"location":"docs/contributing/1.-contributing-guide/#getting-isort-set-up-for-local-development","text":"The first step when contributing to any project is getting it set up on your local machine. isort aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) WSL users running Ubuntu may need to install Python's venv module even after installing Python. Once you have verified that your system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/isort.git cd isort poetry install Optionally, isolate poetry's installation from the rest of your system using the instructions on the poetry site here: https://python-poetry.org/docs/#installation ./scripts/test.sh should yield Success: no issues found ./scripts/clean.sh should yield a Safety report checking packages TIP : ./scripts/done.sh will run both clean and test in one step.","title":"Getting isort set up for local development"},{"location":"docs/contributing/1.-contributing-guide/#docker-development","text":"If you would instead like to develop using Docker, the only local requirement is docker. See the docker docs if you have not used docker before. Once you have the docker daemon running and have cloned the repository, you can get started by following these steps: cd isort ./scripts/docker.sh A local test cycle might look like the following: docker build ./ -t isort:latest docker run isort if #2 fails, debug, save, and goto #1 docker run -it isort bash will get you into the failed environment docker run -v $(git rev-parse --show-toplevel):/isort will make changes made in the docker environment persist on your local checkout. TIP : combine both to get an interacive docker shell that loads changes made locally, even after build, to quickly rerun that pesky failing test ./scripts/docker.sh if #4 fails, debug, save and goto #1; you may need to specify a different --build-arg VERSION=$VER congrats! you are probably ready to push a contribution","title":"Docker development"},{"location":"docs/contributing/1.-contributing-guide/#making-a-contribution","text":"Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main isort project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the HOPE-8 Coding Standard used by the project. Run tests locally to make sure everything is still working ./scripts/done.sh Or if you are using Docker docker run isort:latest Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :).","title":"Making a contribution"},{"location":"docs/contributing/1.-contributing-guide/#thank-you","text":"I can not tell you how thankful I am for the hard work done by isort contributors like you . Thank you! ~Timothy Crosley","title":"Thank you!"},{"location":"docs/contributing/2.-coding-standard/","text":"HOPE 8 -- Style Guide for Hug Code HOPE: 8 Title: Style Guide for Hug Code Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 19-May-2019 Updated: 17-August-2019 Introduction This document gives coding conventions for the Hug code comprising the Hug core as well as all official interfaces, extensions, and plugins for the framework. Optionally, projects that use Hug are encouraged to follow this HOPE and link to it as a reference. PEP 8 Foundation All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines. Line Length Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side. There is no perfect number: but for Hug, we've decided to cap the lines at 100 characters. Descriptive Variable names Naming things is hard. Hug has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand. Adding new modules New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible. Automated Code Cleaners All code submitted to Hug should be formatted using Black and isort. Black should be run with the line length set to 100, and isort with Black compatible settings in place. Automated Code Linting All code submitted to hug should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"2. Coding Standard"},{"location":"docs/contributing/2.-coding-standard/#hope-8-style-guide-for-hug-code","text":"HOPE: 8 Title: Style Guide for Hug Code Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 19-May-2019 Updated: 17-August-2019","title":"HOPE 8 -- Style Guide for Hug Code"},{"location":"docs/contributing/2.-coding-standard/#introduction","text":"This document gives coding conventions for the Hug code comprising the Hug core as well as all official interfaces, extensions, and plugins for the framework. Optionally, projects that use Hug are encouraged to follow this HOPE and link to it as a reference.","title":"Introduction"},{"location":"docs/contributing/2.-coding-standard/#pep-8-foundation","text":"All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines.","title":"PEP 8 Foundation"},{"location":"docs/contributing/2.-coding-standard/#line-length","text":"Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side. There is no perfect number: but for Hug, we've decided to cap the lines at 100 characters.","title":"Line Length"},{"location":"docs/contributing/2.-coding-standard/#descriptive-variable-names","text":"Naming things is hard. Hug has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand.","title":"Descriptive Variable names"},{"location":"docs/contributing/2.-coding-standard/#adding-new-modules","text":"New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible.","title":"Adding new modules"},{"location":"docs/contributing/2.-coding-standard/#automated-code-cleaners","text":"All code submitted to Hug should be formatted using Black and isort. Black should be run with the line length set to 100, and isort with Black compatible settings in place.","title":"Automated Code Cleaners"},{"location":"docs/contributing/2.-coding-standard/#automated-code-linting","text":"All code submitted to hug should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"Automated Code Linting"},{"location":"docs/contributing/3.-code-of-conduct/","text":"HOPE 11 -- Code of Conduct HOPE: 11 Title: Code of Conduct Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 17-August-2019 Updated: 17-August-2019 Abstract Defines the Code of Conduct for Hug and all related projects. Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting timothy.crosley@gmail.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Confidentiality will be maintained with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the [Contributor Covenant][https://www.contributor-covenant.org], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"3. Code Of Conduct"},{"location":"docs/contributing/3.-code-of-conduct/#hope-11-code-of-conduct","text":"HOPE: 11 Title: Code of Conduct Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 17-August-2019 Updated: 17-August-2019","title":"HOPE 11 -- Code of Conduct"},{"location":"docs/contributing/3.-code-of-conduct/#abstract","text":"Defines the Code of Conduct for Hug and all related projects.","title":"Abstract"},{"location":"docs/contributing/3.-code-of-conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"docs/contributing/3.-code-of-conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"docs/contributing/3.-code-of-conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"docs/contributing/3.-code-of-conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"docs/contributing/3.-code-of-conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting timothy.crosley@gmail.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Confidentiality will be maintained with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"docs/contributing/3.-code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the [Contributor Covenant][https://www.contributor-covenant.org], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"docs/contributing/4.-acknowledgements/","text":"Original Creator & Maintainer Timothy Edmund Crosley (@timothycrosley) Plugin Writers VIM - Juan Pedro Fisanotti (@fisadev) Emacs - Friedrich Paetzke (@paetzke) Sublime - Thijs de Zoute (@thijsdezoete) Notable Bug Reporters Bengt L\u00fcers (@Bengt) Chris Adams (@acdha) @OddBloke Martin Geisler (@mgeisler) Tim Heap (@timheap) Code Contributors Aaron Gallagher (@habnabit) Thomas Grainger (@graingert) Thijs de Zoute (@thijsdezoete) Marc Abramowitz (@msabramo) Daniel Cowgill (@dcowgill) Francois Lebel (@flebel) Antoni Segura Puimedon (@celebdor) Pablo (@oubiga) Oskar Hahn (@ostcar) Wim Glenn (@wimglenn) Matt Caldwell (@mattcaldwell) Dwayne Bailey (@dwaynebailey) Ionel Cristian M\u0103rie\u0219 (@ionelmc) Chris Adams (@acdha) GuoJing (@GuoJing) George Hickman (@ghickman) Dan Davison (@dandavison) Maciej Wolff (@maciejwo) Elliott Sales de Andrade (@qulogic) Kasper Jacobsen (@dinoshauer) Sebastian Pipping (@hartwork) Helen Sherwood-Taylor (@helenst) Mocker (@Zuckonit) Tim Graham (@timgraham) Adam (@NorthIsUp) Norman J\u00e4ckel (@normanjaeckel) Derrick Petzold (@dpetzold) Michael van Tellingen (@mvantellingen) Patrick Yevsukov (@patrickyevsukov) Christer van der Meeren (@cmeeren) Timon Wong/NHNCN (@timonwong) Jeremy Dunck (@jdunck) Benjamin ABEL (@benjaminabel) Dan Baragan (@danbaragan) Rob Cowie (@robcowie) Amit Shah (@Amwam) Patrick Gerken (@do3cc) @dein0s David Stensland (@terite) Ankur Dedania (@AbsoluteMSTR) Lee Packham (@leepa) Jesse Mullan (@jmullan) Kwok-kuen Cheung (@cheungpat) Johan Bloemberg (@aequitas) Dan Watson (@dcwatson) \u00c9ric Araujo (@merwok) Dan Palmer (@danpalmer) Andy Boot (@bootandy) @m7v8 John Vandenberg (@jayvdb) Adam Chainz (@adamchainz) @Brightcells Jonas Trappenberg (@teeberg) Andrew Konstantaras (@akonsta) Jason Brackman (@jasonbrackman) Kathryn Lingel (@katlings) Andrew Gaul (@gaul) John Chadwick (@jchv) Jon Dufresne (@jdufresne) Brian F. Baron (@briabar) Madison Caldwell (@madirey) Matt Yule-Bennett (@mattbennett) Jaswanth Kumar (@jaswanth098) Dario Navin (@Zarathustra2) Danny Weinberg (@FuegoFro) Gram (@orsinium) Hugo van Kemenade (@hugovk) G\u00e9ry Ogam (@maggyero) Cody Scott (@Siecje) Pedro Algarvio (@s0undt3ch) Chris St. Pierre (@stpierre) Sebastian Rittau (@srittau) Jo\u00e3o M.C. Teixeira (@joaomcteixeira) Honnix (@honnix) Anders Kaseorg (@andersk) Documenters Reinout van Rees (@reinout) Helen Sherwood-Taylor (@helenst) Elliott Sales de Andrade (@QuLogic) Brian Peiris (@brianpeiris) Tim Graham (@timgraham) Josh Soref (@jsoref) Teg Khanna (@tegkhanna) Sarah Beth Tracy (@sbtries) Aaron Brown (@aaronvbrown) Harutaka Kawamura (@harupy) Brad Solomon (@bsolomon1124) Martynas Mickevi\u010dius (@2m) A sincere thanks to everyone who has helped isort be the great utility it is today! It would not be one-hundredth as useful and consistent as it is now without the help of your bug reports, commits, and suggestions. You guys rock! ~Timothy Crosley","title":"4. Acknowledgements"},{"location":"docs/contributing/4.-acknowledgements/#original-creator-maintainer","text":"Timothy Edmund Crosley (@timothycrosley)","title":"Original Creator &amp; Maintainer"},{"location":"docs/contributing/4.-acknowledgements/#plugin-writers","text":"VIM - Juan Pedro Fisanotti (@fisadev) Emacs - Friedrich Paetzke (@paetzke) Sublime - Thijs de Zoute (@thijsdezoete)","title":"Plugin Writers"},{"location":"docs/contributing/4.-acknowledgements/#notable-bug-reporters","text":"Bengt L\u00fcers (@Bengt) Chris Adams (@acdha) @OddBloke Martin Geisler (@mgeisler) Tim Heap (@timheap)","title":"Notable Bug Reporters"},{"location":"docs/contributing/4.-acknowledgements/#code-contributors","text":"Aaron Gallagher (@habnabit) Thomas Grainger (@graingert) Thijs de Zoute (@thijsdezoete) Marc Abramowitz (@msabramo) Daniel Cowgill (@dcowgill) Francois Lebel (@flebel) Antoni Segura Puimedon (@celebdor) Pablo (@oubiga) Oskar Hahn (@ostcar) Wim Glenn (@wimglenn) Matt Caldwell (@mattcaldwell) Dwayne Bailey (@dwaynebailey) Ionel Cristian M\u0103rie\u0219 (@ionelmc) Chris Adams (@acdha) GuoJing (@GuoJing) George Hickman (@ghickman) Dan Davison (@dandavison) Maciej Wolff (@maciejwo) Elliott Sales de Andrade (@qulogic) Kasper Jacobsen (@dinoshauer) Sebastian Pipping (@hartwork) Helen Sherwood-Taylor (@helenst) Mocker (@Zuckonit) Tim Graham (@timgraham) Adam (@NorthIsUp) Norman J\u00e4ckel (@normanjaeckel) Derrick Petzold (@dpetzold) Michael van Tellingen (@mvantellingen) Patrick Yevsukov (@patrickyevsukov) Christer van der Meeren (@cmeeren) Timon Wong/NHNCN (@timonwong) Jeremy Dunck (@jdunck) Benjamin ABEL (@benjaminabel) Dan Baragan (@danbaragan) Rob Cowie (@robcowie) Amit Shah (@Amwam) Patrick Gerken (@do3cc) @dein0s David Stensland (@terite) Ankur Dedania (@AbsoluteMSTR) Lee Packham (@leepa) Jesse Mullan (@jmullan) Kwok-kuen Cheung (@cheungpat) Johan Bloemberg (@aequitas) Dan Watson (@dcwatson) \u00c9ric Araujo (@merwok) Dan Palmer (@danpalmer) Andy Boot (@bootandy) @m7v8 John Vandenberg (@jayvdb) Adam Chainz (@adamchainz) @Brightcells Jonas Trappenberg (@teeberg) Andrew Konstantaras (@akonsta) Jason Brackman (@jasonbrackman) Kathryn Lingel (@katlings) Andrew Gaul (@gaul) John Chadwick (@jchv) Jon Dufresne (@jdufresne) Brian F. Baron (@briabar) Madison Caldwell (@madirey) Matt Yule-Bennett (@mattbennett) Jaswanth Kumar (@jaswanth098) Dario Navin (@Zarathustra2) Danny Weinberg (@FuegoFro) Gram (@orsinium) Hugo van Kemenade (@hugovk) G\u00e9ry Ogam (@maggyero) Cody Scott (@Siecje) Pedro Algarvio (@s0undt3ch) Chris St. Pierre (@stpierre) Sebastian Rittau (@srittau) Jo\u00e3o M.C. Teixeira (@joaomcteixeira) Honnix (@honnix) Anders Kaseorg (@andersk)","title":"Code Contributors"},{"location":"docs/contributing/4.-acknowledgements/#documenters","text":"Reinout van Rees (@reinout) Helen Sherwood-Taylor (@helenst) Elliott Sales de Andrade (@QuLogic) Brian Peiris (@brianpeiris) Tim Graham (@timgraham) Josh Soref (@jsoref) Teg Khanna (@tegkhanna) Sarah Beth Tracy (@sbtries) Aaron Brown (@aaronvbrown) Harutaka Kawamura (@harupy) Brad Solomon (@bsolomon1124) Martynas Mickevi\u010dius (@2m) A sincere thanks to everyone who has helped isort be the great utility it is today! It would not be one-hundredth as useful and consistent as it is now without the help of your bug reports, commits, and suggestions. You guys rock! ~Timothy Crosley","title":"Documenters"},{"location":"docs/major_releases/introducing_isort_5/","text":"Introducing isort 5 isort 5.0.0 is the first major release of isort in over five years and the first significant refactoring of isort since it was conceived more than ten years ago. It's also the first version to require Python 3 (Python 3.6+ at that!) to run - though it can still be run on source files from any version of Python. This does mean that there may be some pain with the upgrade process, but we believe the improvements will be well worth it. Click here for an attempt at full changelog with a list of breaking changes. Try isort 5 right now from your browser! So why the massive change? Profile support isort --profile black . isort --profile django . isort --profile pycharm . isort --profile google . isort --profile open_stack . isort --profile plone . isort --profile attrs . isort --profile hug . isort is very configurable. That's great, but it can be overwhelming, both for users and for the isort project. isort now comes with profiles for the most common isort configurations, so you likely will not need to configure anything at all. This also means that as a project, isort can run extensive tests against these specific profiles to ensure nothing breaks over time. Sort imports anywhere import a # <- These are sorted import b b . install ( a ) import os # <- And these are sorted import sys def my_function (): import x # <- Even these are sorted! import z isort 5 will find and sort contiguous section of imports no matter where they are. It also allows you to place code in-between imports without any hacks required. Streaming architecture import a import b ... \u221e isort has been refactored to use a streaming architecture. This means it can sort files of any size (even larger than the Python interpreter supports!) without breaking a sweat. It also means that even when sorting imports in smaller files, it is faster and more resource-efficient. Consistent behavior across all environments Sorting the same file with the same configuration should give you the same output no matter what computer or OS you are running. Extensive effort has been placed around refactoring how modules are placed and how configuration files are loaded to ensure this is the case. Cython support cimport ctime from cpython cimport PyLong_FromVoidPtr from cpython cimport bool as py_bool from cython.operator cimport dereference as deref from cython.operator cimport preincrement as preinc from libc.stdint cimport uint64_t , uintptr_t from libc.stdlib cimport atoi , calloc , free , malloc from libc.string cimport memcpy , strlen from libcpp cimport bool as cpp_bool from libcpp.map cimport map as cpp_map from libcpp.pair cimport pair as cpp_pair from libcpp.string cimport string as cpp_string from libcpp.vector cimport vector as cpp_vector from multimap cimport multimap as cpp_multimap from wstring cimport wstring as cpp_wstring isort 5 adds seamless support for Cython ( .pyx ) files. Action Comments import e import f # isort: off <- Turns isort parsing off import b import a # isort: on <- Turns isort parsing back on import c import d isort 5 adds support for Action Comments which provide a quick and convient way to control the flow of parsing within single source files. First class Python API import isort isort . code ( \"\"\" import b import a \"\"\" ) == \"\"\" import a import b \"\"\" isort now exposes its programmatic API as a first-class citizen. This API makes it easy to extend or use isort in your own Python project. You can see the full documentation for this new API here . Solid base for the future A major focus for the release was to give isort a solid foundation for the next 5-10 years of the project's life. isort has been refactored into functional components that are easily testable. The project now has 100% code coverage. It utilizes tools like Hypothesis to reduce the number of unexpected errors. It went from fully dynamic to fully static typing using mypy. Finally, it utilizes the latest linters both on (like DeepSource ) and offline (like Flake8 ) to help ensure a higher bar for all code contributions into the future. Give 5.0.0 a try! Try isort 5 right now from your browser! OR Install isort locally using pip3 install isort . Click here for full installation instructions.","title":"Introducing Isort 5"},{"location":"docs/major_releases/introducing_isort_5/#introducing-isort-5","text":"isort 5.0.0 is the first major release of isort in over five years and the first significant refactoring of isort since it was conceived more than ten years ago. It's also the first version to require Python 3 (Python 3.6+ at that!) to run - though it can still be run on source files from any version of Python. This does mean that there may be some pain with the upgrade process, but we believe the improvements will be well worth it. Click here for an attempt at full changelog with a list of breaking changes. Try isort 5 right now from your browser! So why the massive change?","title":"Introducing isort 5"},{"location":"docs/major_releases/introducing_isort_5/#profile-support","text":"isort --profile black . isort --profile django . isort --profile pycharm . isort --profile google . isort --profile open_stack . isort --profile plone . isort --profile attrs . isort --profile hug . isort is very configurable. That's great, but it can be overwhelming, both for users and for the isort project. isort now comes with profiles for the most common isort configurations, so you likely will not need to configure anything at all. This also means that as a project, isort can run extensive tests against these specific profiles to ensure nothing breaks over time.","title":"Profile support"},{"location":"docs/major_releases/introducing_isort_5/#sort-imports-anywhere","text":"import a # <- These are sorted import b b . install ( a ) import os # <- And these are sorted import sys def my_function (): import x # <- Even these are sorted! import z isort 5 will find and sort contiguous section of imports no matter where they are. It also allows you to place code in-between imports without any hacks required.","title":"Sort imports anywhere"},{"location":"docs/major_releases/introducing_isort_5/#streaming-architecture","text":"import a import b ... \u221e isort has been refactored to use a streaming architecture. This means it can sort files of any size (even larger than the Python interpreter supports!) without breaking a sweat. It also means that even when sorting imports in smaller files, it is faster and more resource-efficient.","title":"Streaming architecture"},{"location":"docs/major_releases/introducing_isort_5/#consistent-behavior-across-all-environments","text":"Sorting the same file with the same configuration should give you the same output no matter what computer or OS you are running. Extensive effort has been placed around refactoring how modules are placed and how configuration files are loaded to ensure this is the case.","title":"Consistent behavior across all environments"},{"location":"docs/major_releases/introducing_isort_5/#cython-support","text":"cimport ctime from cpython cimport PyLong_FromVoidPtr from cpython cimport bool as py_bool from cython.operator cimport dereference as deref from cython.operator cimport preincrement as preinc from libc.stdint cimport uint64_t , uintptr_t from libc.stdlib cimport atoi , calloc , free , malloc from libc.string cimport memcpy , strlen from libcpp cimport bool as cpp_bool from libcpp.map cimport map as cpp_map from libcpp.pair cimport pair as cpp_pair from libcpp.string cimport string as cpp_string from libcpp.vector cimport vector as cpp_vector from multimap cimport multimap as cpp_multimap from wstring cimport wstring as cpp_wstring isort 5 adds seamless support for Cython ( .pyx ) files.","title":"Cython support"},{"location":"docs/major_releases/introducing_isort_5/#action-comments","text":"import e import f # isort: off <- Turns isort parsing off import b import a # isort: on <- Turns isort parsing back on import c import d isort 5 adds support for Action Comments which provide a quick and convient way to control the flow of parsing within single source files.","title":"Action Comments"},{"location":"docs/major_releases/introducing_isort_5/#first-class-python-api","text":"import isort isort . code ( \"\"\" import b import a \"\"\" ) == \"\"\" import a import b \"\"\" isort now exposes its programmatic API as a first-class citizen. This API makes it easy to extend or use isort in your own Python project. You can see the full documentation for this new API here .","title":"First class Python API"},{"location":"docs/major_releases/introducing_isort_5/#solid-base-for-the-future","text":"A major focus for the release was to give isort a solid foundation for the next 5-10 years of the project's life. isort has been refactored into functional components that are easily testable. The project now has 100% code coverage. It utilizes tools like Hypothesis to reduce the number of unexpected errors. It went from fully dynamic to fully static typing using mypy. Finally, it utilizes the latest linters both on (like DeepSource ) and offline (like Flake8 ) to help ensure a higher bar for all code contributions into the future.","title":"Solid base for the future"},{"location":"docs/major_releases/introducing_isort_5/#give-500-a-try","text":"Try isort 5 right now from your browser! OR Install isort locally using pip3 install isort . Click here for full installation instructions.","title":"Give 5.0.0 a try!"},{"location":"docs/quick_start/0.-try/","text":"Try isort from your browser! Use our live isort editor to see how isort can help improve the formatting of your Python imports. Safe to use. No code is transmitted. The below live isort tester doesn't transmit any of the code you paste to our server or anyone else's. Instead, this page runs a complete Python3 installation with isort installed entirely within your browser. To accomplish this, it utilizes the pyodide project. // set the pyodide files URL (packages.json, pyodide.asm.data etc) window.languagePluginUrl = 'https://pyodide-cdn2.iodide.io/v0.15.0/full/'; from future import braces import b import b import os import a from future import braces import b import a import b, a Loading... Configuration (Note: the below must follow JSON format). Full configuration guide is here : {\"line_length\": 80, \"multi_line_output\": 2, \"atomic\": true } Like what you saw? Installing isort to use locally is as simple as pip3 install isort . Click here for full installation instructions.","title":"0. Try"},{"location":"docs/quick_start/0.-try/#try-isort-from-your-browser","text":"Use our live isort editor to see how isort can help improve the formatting of your Python imports. Safe to use. No code is transmitted. The below live isort tester doesn't transmit any of the code you paste to our server or anyone else's. Instead, this page runs a complete Python3 installation with isort installed entirely within your browser. To accomplish this, it utilizes the pyodide project. // set the pyodide files URL (packages.json, pyodide.asm.data etc) window.languagePluginUrl = 'https://pyodide-cdn2.iodide.io/v0.15.0/full/'; from future import braces import b import b import os import a from future import braces import b import a import b, a Loading... Configuration (Note: the below must follow JSON format). Full configuration guide is here : {\"line_length\": 80, \"multi_line_output\": 2, \"atomic\": true } Like what you saw? Installing isort to use locally is as simple as pip3 install isort . Click here for full installation instructions.","title":"Try isort from your browser!"},{"location":"docs/quick_start/1.-install/","text":"Install isort using your preferred Python package manager: pip3 install isort OR poetry add isort OR pipenv install isort OR For a fully isolated user installation you can use pipx pipx install isort Tip If you want isort to act as a linter for projects, it probably makes since to add isort as an explicit development dependency for each project that uses it. If, on the other hand, you are an individual developer simply using isort as a personal tool to clean up your own commits, a global or user level installation makes sense. Both are seamlessly supported on a single machine.","title":"1. Install"},{"location":"docs/quick_start/2.-cli/","text":"Command Line Usage Once installed, isort exposes a command line utility for sorting, organizing, and formatting imports within Python and Cython source files. To verify the tool is installed correctly, run isort --version from the command line and you should be given the available commands and the version of isort installed. For a list of all CLI options type isort --help or view the online configuration reference .: Formatting a Project In general, isort is most commonly utilized across an entire projects source at once. The simplest way to do this is isort . or if using a src directory isort src . isort will automatically find all Python source files recursively and pick-up a configuration file placed at the root of your project if present. This can be combined with any command line configuration customizations such as specifying a profile to use ( isort . --profile black ). Verifying a Project The second most common usage of isort is verifying that imports within a project are formatted correctly (often within the context of a CI/CD system). The simplest way to accomplish this is using the check command line option: isort --check . . To improve the usefulness of errors when they do occur, this can be combined with the diff option: isort --check --diff . . Single Source Files Finally, isort can just as easily be ran against individual source files. Simply pass in a single or multiple source files to sort or validate (Example: isort setup.py ). Multiple Projects Running a single isort command across multiple projects, or source files spanning multiple projects, is highly discouraged. Instead it is recommended that an isort process (or command) is ran for each project independently. This is because isort creates an immutable config for each CLI instance. # YES isort project1 isort project2 # Also YES isort project1 / src project1 / test isort project2 / src project2 / test # NO isort project1 project2","title":"2. Cli"},{"location":"docs/quick_start/2.-cli/#command-line-usage","text":"Once installed, isort exposes a command line utility for sorting, organizing, and formatting imports within Python and Cython source files. To verify the tool is installed correctly, run isort --version from the command line and you should be given the available commands and the version of isort installed. For a list of all CLI options type isort --help or view the online configuration reference .:","title":"Command Line Usage"},{"location":"docs/quick_start/2.-cli/#formatting-a-project","text":"In general, isort is most commonly utilized across an entire projects source at once. The simplest way to do this is isort . or if using a src directory isort src . isort will automatically find all Python source files recursively and pick-up a configuration file placed at the root of your project if present. This can be combined with any command line configuration customizations such as specifying a profile to use ( isort . --profile black ).","title":"Formatting a Project"},{"location":"docs/quick_start/2.-cli/#verifying-a-project","text":"The second most common usage of isort is verifying that imports within a project are formatted correctly (often within the context of a CI/CD system). The simplest way to accomplish this is using the check command line option: isort --check . . To improve the usefulness of errors when they do occur, this can be combined with the diff option: isort --check --diff . .","title":"Verifying a Project"},{"location":"docs/quick_start/2.-cli/#single-source-files","text":"Finally, isort can just as easily be ran against individual source files. Simply pass in a single or multiple source files to sort or validate (Example: isort setup.py ).","title":"Single Source Files"},{"location":"docs/quick_start/2.-cli/#multiple-projects","text":"Running a single isort command across multiple projects, or source files spanning multiple projects, is highly discouraged. Instead it is recommended that an isort process (or command) is ran for each project independently. This is because isort creates an immutable config for each CLI instance. # YES isort project1 isort project2 # Also YES isort project1 / src project1 / test isort project2 / src project2 / test # NO isort project1 project2","title":"Multiple Projects"},{"location":"docs/quick_start/3.-api/","text":"Programmatic Python API Usage In addition to the powerful command line interface, isort exposes a complete Python API. To use the Python API, import isort and then call the desired function call: Every function is fully type hinted and requires and returns only builtin Python objects. Highlights include: isort.code - Takes a string containing code, and returns it with imports sorted. isort.check_code - Takes a string containing code, and returns True if all imports are sorted correctly, otherwise, False . isort.stream - Takes an input stream containing Python code and an output stream. Outputs code to output stream with all imports sorted. isort.stream - Takes an input stream containing Python code and returns True if all imports in the stream are sorted correctly, otherwise, False . isort.file - Takes the path of a Python source file and sorts the imports in-place. isort.check_file - Takes the path of a Python source file and returns True if all imports contained within are sorted correctly, otherwise, False . isort.place_module - Takes the name of a module as a string and returns the categorization determined for it. isort.place_module_with_reason - Takes the name of a module as a string and returns the categorization determined for it and why that categorization was given. For a full definition of the API see the API reference documentation or try help(isort) from an interactive interpreter.","title":"3. Api"},{"location":"docs/quick_start/3.-api/#programmatic-python-api-usage","text":"In addition to the powerful command line interface, isort exposes a complete Python API. To use the Python API, import isort and then call the desired function call: Every function is fully type hinted and requires and returns only builtin Python objects. Highlights include: isort.code - Takes a string containing code, and returns it with imports sorted. isort.check_code - Takes a string containing code, and returns True if all imports are sorted correctly, otherwise, False . isort.stream - Takes an input stream containing Python code and an output stream. Outputs code to output stream with all imports sorted. isort.stream - Takes an input stream containing Python code and returns True if all imports in the stream are sorted correctly, otherwise, False . isort.file - Takes the path of a Python source file and sorts the imports in-place. isort.check_file - Takes the path of a Python source file and returns True if all imports contained within are sorted correctly, otherwise, False . isort.place_module - Takes the name of a module as a string and returns the categorization determined for it. isort.place_module_with_reason - Takes the name of a module as a string and returns the categorization determined for it and why that categorization was given. For a full definition of the API see the API reference documentation or try help(isort) from an interactive interpreter.","title":"Programmatic Python API Usage"},{"location":"reference/isort/","text":"Module isort Defines the public isort interface View Source \"\"\"Defines the public isort interface\"\"\" from . import settings # noqa: F401 from ._version import __version__ from .api import check_code_string as check_code from .api import check_file , check_stream , place_module , place_module_with_reason from .api import sort_code_string as code from .api import sort_file as file from .api import sort_stream as stream Sub-modules isort.api isort.comments isort.deprecated isort.exceptions isort.format isort.hooks isort.io isort.logo isort.main isort.output isort.parse isort.place isort.profiles isort.pylama_isort isort.sections isort.settings isort.setuptools_commands isort.sorting isort.stdlibs isort.utils isort.wrap isort.wrap_modes","title":"Index"},{"location":"reference/isort/#module-isort","text":"Defines the public isort interface View Source \"\"\"Defines the public isort interface\"\"\" from . import settings # noqa: F401 from ._version import __version__ from .api import check_code_string as check_code from .api import check_file , check_stream , place_module , place_module_with_reason from .api import sort_code_string as code from .api import sort_file as file from .api import sort_stream as stream","title":"Module isort"},{"location":"reference/isort/#sub-modules","text":"isort.api isort.comments isort.deprecated isort.exceptions isort.format isort.hooks isort.io isort.logo isort.main isort.output isort.parse isort.place isort.profiles isort.pylama_isort isort.sections isort.settings isort.setuptools_commands isort.sorting isort.stdlibs isort.utils isort.wrap isort.wrap_modes","title":"Sub-modules"},{"location":"reference/isort/api/","text":"Module isort.api View Source import shutil import sys import textwrap from io import StringIO from itertools import chain from pathlib import Path from typing import List , Optional , TextIO , Union from warnings import warn from . import io , output , parse from .exceptions import ( ExistingSyntaxErrors , FileSkipComment , FileSkipSetting , IntroducedSyntaxErrors , ) from .format import ( ask_whether_to_apply_changes_to_file , format_natural , remove_whitespace , show_unified_diff , ) from .io import Empty from .place import module as place_module # skipcq: PYL-W0611 (intended export of public API) from .place import module_with_reason as place_module_with_reason # skipcq: PYL-W0611 (^) from .settings import DEFAULT_CONFIG , FILE_SKIP_COMMENTS , Config CIMPORT_IDENTIFIERS = ( \"cimport \" , \"cimport*\" , \"from.cimport\" ) IMPORT_START_IDENTIFIERS = ( \"from \" , \"from.import\" , \"import \" , \"import*\" ) + CIMPORT_IDENTIFIERS COMMENT_INDICATORS = ( '\"\"\"' , \"'''\" , \"'\" , '\"' , \"#\" ) def sort_code_string ( code : str , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ): \"\"\"Sorts any imports within the provided code string, returning a new string with them sorted. - **code**: The string of code with imports that need to be sorted. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" input_stream = StringIO ( code ) output_stream = StringIO () config = _config ( path = file_path , config = config , ** config_kwargs ) sort_stream ( input_stream , output_stream , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) output_stream . seek ( 0 ) return output_stream . read () def check_code_string ( code : str , show_diff : bool = False , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ) -> bool : \"\"\"Checks the order, format, and categorization of imports within the provided code string. Returns `True` if everything is correct, otherwise `False`. - **code**: The string of code with imports that need to be sorted. - **show_diff**: If `True` the changes that need to be done will be printed to stdout. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( path = file_path , config = config , ** config_kwargs ) return check_stream ( StringIO ( code ), show_diff = show_diff , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) def sort_stream ( input_stream : TextIO , output_stream : TextIO , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ): \"\"\"Sorts any imports within the provided code stream, outputs to the provided output stream. Directly returns nothing. - **input_stream**: The stream of code with imports that need to be sorted. - **output_stream**: The stream where sorted imports should be written to. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( path = file_path , config = config , ** config_kwargs ) content_source = str ( file_path or \"Passed in content\" ) if not disregard_skip : if file_path and config . is_skipped ( file_path ): raise FileSkipSetting ( content_source ) if config . atomic : try : file_content = input_stream . read () compile ( file_content , content_source , \"exec\" , 0 , 1 ) input_stream = StringIO ( file_content ) except SyntaxError : raise ExistingSyntaxErrors ( content_source ) try : changed = _sort_imports ( input_stream , output_stream , extension = extension , config = config ) except FileSkipComment : raise FileSkipComment ( content_source ) if config . atomic : output_stream . seek ( 0 ) try : compile ( output_stream . read (), content_source , \"exec\" , 0 , 1 ) output_stream . seek ( 0 ) except SyntaxError : # pragma: no cover raise IntroducedSyntaxErrors ( content_source ) return changed def check_stream ( input_stream : TextIO , show_diff : bool = False , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ) -> bool : \"\"\"Checks any imports within the provided code stream, returning `False` if any unsorted or incorrectly imports are found or `True` if no problems are identified. - **input_stream**: The stream of code with imports that need to be sorted. - **show_diff**: If `True` the changes that need to be done will be printed to stdout. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( path = file_path , config = config , ** config_kwargs ) changed : bool = sort_stream ( input_stream = input_stream , output_stream = Empty , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) if not changed : if config . verbose : print ( f \"SUCCESS: {file_path or ''} Everything Looks Good!\" ) return True else : print ( f \"ERROR: {file_path or ''} Imports are incorrectly sorted and/or formatted.\" ) if show_diff : output_stream = StringIO () input_stream . seek ( 0 ) file_contents = input_stream . read () sort_stream ( input_stream = StringIO ( file_contents ), output_stream = output_stream , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) output_stream . seek ( 0 ) show_unified_diff ( file_input = file_contents , file_output = output_stream . read (), file_path = file_path ) return False def check_file ( filename : Union [ str , Path ], show_diff : bool = False , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = True , ** config_kwargs , ) -> bool : \"\"\"Checks any imports within the provided file, returning `False` if any unsorted or incorrectly imports are found or `True` if no problems are identified. - **filename**: The name or Path of the file to check. - **show_diff**: If `True` the changes that need to be done will be printed to stdout. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" with io . File . read ( filename ) as source_file : return check_stream ( source_file . stream , show_diff = show_diff , extension = source_file . extension or \"py\" , config = config , file_path = file_path or source_file . path , disregard_skip = disregard_skip , ** config_kwargs , ) def sort_file ( filename : Union [ str , Path ], extension : str = \"py\" , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = True , ask_to_apply : bool = False , show_diff : bool = False , write_to_stdout : bool = False , ** config_kwargs , ): \"\"\"Sorts and formats any groups of imports imports within the provided file or Path. - **filename**: The name or Path of the file to format. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - **ask_to_apply**: If `True`, prompt before applying any changes. - **show_diff**: If `True` the changes that need to be done will be printed to stdout. - **write_to_stdout**: If `True`, write to stdout instead of the input file. - ****config_kwargs**: Any config modifications. \"\"\" with io . File . read ( filename ) as source_file : changed : bool = False try : if write_to_stdout : changed = sort_stream ( input_stream = source_file . stream , output_stream = sys . stdout , config = config , file_path = file_path or source_file . path , disregard_skip = disregard_skip , ** config_kwargs , ) else : tmp_file = source_file . path . with_suffix ( source_file . path . suffix + \".isorted\" ) try : with tmp_file . open ( \"w\" , encoding = source_file . encoding , newline = \"\" ) as output_stream : shutil . copymode ( filename , tmp_file ) changed = sort_stream ( input_stream = source_file . stream , output_stream = output_stream , config = config , file_path = file_path or source_file . path , disregard_skip = disregard_skip , ** config_kwargs , ) if changed : if show_diff or ask_to_apply : source_file . stream . seek ( 0 ) show_unified_diff ( file_input = source_file . stream . read (), file_output = tmp_file . read_text ( encoding = source_file . encoding ), file_path = file_path or source_file . path , ) if ask_to_apply and not ask_whether_to_apply_changes_to_file ( str ( source_file . path ) ): return source_file . stream . close () tmp_file . replace ( source_file . path ) if not config . quiet : print ( f \"Fixing {source_file.path}\" ) finally : try : # Python 3.8+: use `missing_ok=True` instead of try except. tmp_file . unlink () except FileNotFoundError : pass except ExistingSyntaxErrors : warn ( \"{file_path} unable to sort due to existing syntax errors\" ) except IntroducedSyntaxErrors : # pragma: no cover warn ( \"{file_path} unable to sort as isort introduces new syntax errors\" ) def _config ( path : Optional [ Path ] = None , config : Config = DEFAULT_CONFIG , ** config_kwargs ) -> Config : if path : if ( config is DEFAULT_CONFIG and \"settings_path\" not in config_kwargs and \"settings_file\" not in config_kwargs ): config_kwargs [ \"settings_path\" ] = path if config_kwargs : if config is not DEFAULT_CONFIG : raise ValueError ( \"You can either specify custom configuration options using kwargs or \" \"passing in a Config object. Not Both!\" ) config = Config ( ** config_kwargs ) return config def _sort_imports ( input_stream : TextIO , output_stream : TextIO , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , ) -> bool : \"\"\"Parses stream identifying sections of contiguous imports and sorting them Code with unsorted imports is read from the provided `input_stream`, sorted and then outputted to the specified `output_stream`. - `input_stream`: Text stream with unsorted import sections. - `output_stream`: Text stream to output sorted inputs into. - `config`: Config settings to use when sorting imports. Defaults settings. - *Default*: `isort.settings.DEFAULT_CONFIG`. - `extension`: The file extension or file extension rules that should be used. - *Default*: `\"py\"`. - *Choices*: `[\"py\", \"pyi\", \"pyx\"]`. Returns `True` if there were changes that needed to be made (errors present) from what was provided in the input_stream, otherwise `False`. \"\"\" line_separator : str = config . line_ending add_imports : List [ str ] = [ format_natural ( addition ) for addition in config . add_imports ] import_section : str = \"\" next_import_section : str = \"\" next_cimports : bool = False in_quote : str = \"\" first_comment_index_start : int = - 1 first_comment_index_end : int = - 1 contains_imports : bool = False in_top_comment : bool = False first_import_section : bool = True section_comments = [ f \"# {heading}\" for heading in config . import_headings . values ()] indent : str = \"\" isort_off : bool = False cimports : bool = False made_changes : bool = False for index , line in enumerate ( chain ( input_stream , ( None ,))): if line is None : if index == 0 and not config . force_adds : return False not_imports = True line = \"\" if not line_separator : line_separator = \" \\n \" else : if not line_separator : line_separator = line [ - 1 ] for file_skip_comment in FILE_SKIP_COMMENTS : if file_skip_comment in line : raise FileSkipComment ( \"Passed in content\" ) stripped_line = line . strip () if ( ( index == 0 or ( index in ( 1 , 2 ) and not contains_imports )) and stripped_line . startswith ( \"#\" ) and stripped_line not in section_comments ): in_top_comment = True elif in_top_comment : if not line . startswith ( \"#\" ) or stripped_line in section_comments : in_top_comment = False first_comment_index_end = index - 1 if ( not stripped_line . startswith ( \"#\" ) or in_quote ) and '\"' in line or \"'\" in line : char_index = 0 if first_comment_index_start == - 1 and ( line . startswith ( '\"' ) or line . startswith ( \"'\" ) ): first_comment_index_start = index while char_index < len ( line ): if line [ char_index ] == \" \\\\ \" : char_index += 1 elif in_quote : if line [ char_index : char_index + len ( in_quote )] == in_quote : in_quote = \"\" if first_comment_index_end < first_comment_index_start : first_comment_index_end = index elif line [ char_index ] in ( \"'\" , '\"' ): long_quote = line [ char_index : char_index + 3 ] if long_quote in ( '\"\"\"' , \"'''\" ): in_quote = long_quote char_index += 2 else : in_quote = line [ char_index ] elif line [ char_index ] == \"#\" : break char_index += 1 not_imports = bool ( in_quote ) or in_top_comment or isort_off if not ( in_quote or in_top_comment ): stripped_line = line . strip () if isort_off : if stripped_line == \"# isort: on\" : isort_off = False elif stripped_line == \"# isort: off\" : not_imports = True isort_off = True elif stripped_line == \"# isort: split\" : not_imports = True elif ( not stripped_line or stripped_line . startswith ( \"#\" ) and ( not indent or indent + line . lstrip () == line ) ): import_section += line elif stripped_line . startswith ( IMPORT_START_IDENTIFIERS ): contains_imports = True new_indent = line [: - len ( line . lstrip ())] import_statement = line stripped_line = line . strip () . split ( \"#\" )[ 0 ] while stripped_line . endswith ( \" \\\\ \" ) or ( \"(\" in stripped_line and \")\" not in stripped_line ): if stripped_line . endswith ( \" \\\\ \" ): while stripped_line and stripped_line . endswith ( \" \\\\ \" ): line = input_stream . readline () stripped_line = line . strip () . split ( \"#\" )[ 0 ] import_statement += line else : while \")\" not in stripped_line : line = input_stream . readline () stripped_line = line . strip () . split ( \"#\" )[ 0 ] import_statement += line cimport_statement : bool = False if ( import_statement . lstrip () . startswith ( CIMPORT_IDENTIFIERS ) or \" cimport \" in import_statement or \" cimport*\" in import_statement or \" cimport(\" in import_statement or \".cimport\" in import_statement ): cimport_statement = True if cimport_statement != cimports or ( new_indent != indent and import_section ): if import_section : next_cimports = cimport_statement next_import_section = import_statement import_statement = \"\" not_imports = True line = \"\" else : cimports = cimport_statement indent = new_indent import_section += import_statement else : not_imports = True if not_imports : if ( add_imports and not in_top_comment and not in_quote and not import_section and not line . lstrip () . startswith ( COMMENT_INDICATORS ) ): import_section = line_separator . join ( add_imports ) + line_separator contains_imports = True add_imports = [] if next_import_section and not import_section : # pragma: no cover import_section = next_import_section next_import_section = \"\" if import_section : if add_imports and not indent : import_section += line_separator . join ( add_imports ) + line_separator contains_imports = True add_imports = [] if not indent : import_section += line if not contains_imports : output_stream . write ( import_section ) else : leading_whitespace = import_section [: - len ( import_section . lstrip ())] trailing_whitespace = import_section [ len ( import_section . rstrip ()) :] if first_import_section and not import_section . lstrip ( line_separator ) . startswith ( COMMENT_INDICATORS ): import_section = import_section . lstrip ( line_separator ) first_import_section = False raw_import_section : str = import_section if indent : import_section = line_separator . join ( line . lstrip () for line in import_section . split ( line_separator ) ) out_config = Config ( config = config , line_length = max ( config . line_length - len ( indent ), 0 ) ) else : out_config = config sorted_import_section = output . sorted_imports ( parse . file_contents ( import_section , config = config ), out_config , extension , import_type = \"cimport\" if cimports else \"import\" , ) if indent : sorted_import_section = ( leading_whitespace + textwrap . indent ( sorted_import_section , indent ) . strip () + trailing_whitespace ) if not made_changes : if config . ignore_whitespace : compare_in = remove_whitespace ( raw_import_section , line_separator = line_separator ) . strip () compare_out = remove_whitespace ( sorted_import_section , line_separator = line_separator ) . strip () else : compare_in = raw_import_section . strip () compare_out = sorted_import_section . strip () if compare_out != compare_in : made_changes = True output_stream . write ( sorted_import_section ) if not line and not indent and next_import_section : output_stream . write ( line_separator ) if indent : output_stream . write ( line ) if not next_import_section : indent = \"\" if next_import_section : cimports = next_cimports contains_imports = True else : contains_imports = False import_section = next_import_section next_import_section = \"\" else : output_stream . write ( line ) not_imports = False return made_changes Variables CIMPORT_IDENTIFIERS COMMENT_INDICATORS FILE_SKIP_COMMENTS IMPORT_START_IDENTIFIERS Functions check_code_string def check_code_string ( code : str , show_diff : bool = False , extension : str = 'py' , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = False , ** config_kwargs ) -> bool Checks the order, format, and categorization of imports within the provided code string. Returns True if everything is correct, otherwise False . code : The string of code with imports that need to be sorted. show_diff : If True the changes that need to be done will be printed to stdout. extension : The file extension that contains the code. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. **config_kwargs : Any config modifications. View Source def check_code_string ( code : str , show_diff : bool = False , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ) -> bool : \"\"\"Checks the order, format, and categorization of imports within the provided code string. Returns `True` if everything is correct, otherwise `False`. - **code**: The string of code with imports that need to be sorted. - **show_diff**: If `True` the changes that need to be done will be printed to stdout. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( path = file_path , config = config , ** config_kwargs ) return check_stream ( StringIO ( code ), show_diff = show_diff , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) check_file def check_file ( filename : Union [ str , pathlib . Path ], show_diff : bool = False , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = True , ** config_kwargs ) -> bool Checks any imports within the provided file, returning False if any unsorted or incorrectly imports are found or True if no problems are identified. filename : The name or Path of the file to check. show_diff : If True the changes that need to be done will be printed to stdout. extension : The file extension that contains the code. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. **config_kwargs : Any config modifications. View Source def check_file ( filename : Union [ str , Path ], show_diff : bool = False , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = True , ** config_kwargs , ) -> bool : \"\"\"Checks any imports within the provided file, returning `False` if any unsorted or incorrectly imports are found or `True` if no problems are identified. - **filename**: The name or Path of the file to check. - **show_diff**: If `True` the changes that need to be done will be printed to stdout. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" with io . File . read ( filename ) as source_file : return check_stream ( source_file . stream , show_diff = show_diff , extension = source_file . extension or \"py\" , config = config , file_path = file_path or source_file . path , disregard_skip = disregard_skip , ** config_kwargs , ) check_stream def check_stream ( input_stream : < class ' TextIO '>, show_diff : bool = False , extension : str = 'py' , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = False , ** config_kwargs ) -> bool Checks any imports within the provided code stream, returning False if any unsorted or incorrectly imports are found or True if no problems are identified. input_stream : The stream of code with imports that need to be sorted. show_diff : If True the changes that need to be done will be printed to stdout. extension : The file extension that contains the code. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. **config_kwargs : Any config modifications. View Source def check_stream ( input_stream : TextIO , show_diff : bool = False , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ) -> bool : \"\"\"Checks any imports within the provided code stream, returning `False` if any unsorted or incorrectly imports are found or `True` if no problems are identified. - **input_stream**: The stream of code with imports that need to be sorted. - **show_diff**: If `True` the changes that need to be done will be printed to stdout. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( path = file_path , config = config , ** config_kwargs ) changed : bool = sort_stream ( input_stream = input_stream , output_stream = Empty , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) if not changed : if config . verbose : print ( f \"SUCCESS: {file_path or ''} Everything Looks Good!\" ) return True else : print ( f \"ERROR: {file_path or ''} Imports are incorrectly sorted and/or formatted.\" ) if show_diff : output_stream = StringIO () input_stream . seek ( 0 ) file_contents = input_stream . read () sort_stream ( input_stream = StringIO ( file_contents ), output_stream = output_stream , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) output_stream . seek ( 0 ) show_unified_diff ( file_input = file_contents , file_output = output_stream . read (), file_path = file_path ) return False sort_code_string def sort_code_string ( code : str , extension : str = 'py' , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = False , ** config_kwargs ) Sorts any imports within the provided code string, returning a new string with them sorted. code : The string of code with imports that need to be sorted. extension : The file extension that contains the code. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. **config_kwargs : Any config modifications. View Source def sort_code_string ( code : str , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ): \"\"\"Sorts any imports within the provided code string, returning a new string with them sorted. - **code**: The string of code with imports that need to be sorted. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" input_stream = StringIO ( code ) output_stream = StringIO () config = _config ( path = file_path , config = config , ** config_kwargs ) sort_stream ( input_stream , output_stream , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) output_stream . seek ( 0 ) return output_stream . read () sort_file def sort_file ( filename : Union [ str , pathlib . Path ], extension : str = 'py' , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = True , ask_to_apply : bool = False , show_diff : bool = False , write_to_stdout : bool = False , ** config_kwargs ) Sorts and formats any groups of imports imports within the provided file or Path. filename : The name or Path of the file to format. extension : The file extension that contains the code. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. ask_to_apply : If True , prompt before applying any changes. show_diff : If True the changes that need to be done will be printed to stdout. write_to_stdout : If True , write to stdout instead of the input file. **config_kwargs : Any config modifications. View Source def sort_file ( filename : Union [ str , Path ], extension : str = \"py\" , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = True , ask_to_apply : bool = False , show_diff : bool = False , write_to_stdout : bool = False , ** config_kwargs , ): \"\"\"Sorts and formats any groups of imports imports within the provided file or Path. - **filename**: The name or Path of the file to format. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - **ask_to_apply**: If `True`, prompt before applying any changes. - **show_diff**: If `True` the changes that need to be done will be printed to stdout. - **write_to_stdout**: If `True`, write to stdout instead of the input file. - ****config_kwargs**: Any config modifications. \"\"\" with io . File . read ( filename ) as source_file : changed : bool = False try : if write_to_stdout : changed = sort_stream ( input_stream = source_file . stream , output_stream = sys . stdout , config = config , file_path = file_path or source_file . path , disregard_skip = disregard_skip , ** config_kwargs , ) else : tmp_file = source_file . path . with_suffix ( source_file . path . suffix + \".isorted\" ) try : with tmp_file . open ( \"w\" , encoding = source_file . encoding , newline = \"\" ) as output_stream : shutil . copymode ( filename , tmp_file ) changed = sort_stream ( input_stream = source_file . stream , output_stream = output_stream , config = config , file_path = file_path or source_file . path , disregard_skip = disregard_skip , ** config_kwargs , ) if changed : if show_diff or ask_to_apply : source_file . stream . seek ( 0 ) show_unified_diff ( file_input = source_file . stream . read (), file_output = tmp_file . read_text ( encoding = source_file . encoding ), file_path = file_path or source_file . path , ) if ask_to_apply and not ask_whether_to_apply_changes_to_file ( str ( source_file . path ) ): return source_file . stream . close () tmp_file . replace ( source_file . path ) if not config . quiet : print ( f \"Fixing {source_file.path}\" ) finally : try : # Python 3.8+: use `missing_ok=True` instead of try except. tmp_file . unlink () except FileNotFoundError : pass except ExistingSyntaxErrors : warn ( \"{file_path} unable to sort due to existing syntax errors\" ) except IntroducedSyntaxErrors : # pragma: no cover warn ( \"{file_path} unable to sort as isort introduces new syntax errors\" ) sort_stream def sort_stream ( input_stream : < class ' TextIO '>, output_stream : < class ' TextIO '>, extension : str = 'py' , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = False , ** config_kwargs ) Sorts any imports within the provided code stream, outputs to the provided output stream. Directly returns nothing. input_stream : The stream of code with imports that need to be sorted. output_stream : The stream where sorted imports should be written to. extension : The file extension that contains the code. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. **config_kwargs : Any config modifications. View Source def sort_stream ( input_stream : TextIO , output_stream : TextIO , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ): \"\"\"Sorts any imports within the provided code stream, outputs to the provided output stream. Directly returns nothing. - **input_stream**: The stream of code with imports that need to be sorted. - **output_stream**: The stream where sorted imports should be written to. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( path = file_path , config = config , ** config_kwargs ) content_source = str ( file_path or \"Passed in content\" ) if not disregard_skip : if file_path and config . is_skipped ( file_path ): raise FileSkipSetting ( content_source ) if config . atomic : try : file_content = input_stream . read () compile ( file_content , content_source , \"exec\" , 0 , 1 ) input_stream = StringIO ( file_content ) except SyntaxError : raise ExistingSyntaxErrors ( content_source ) try : changed = _sort_imports ( input_stream , output_stream , extension = extension , config = config ) except FileSkipComment : raise FileSkipComment ( content_source ) if config . atomic : output_stream . seek ( 0 ) try : compile ( output_stream . read (), content_source , \"exec\" , 0 , 1 ) output_stream . seek ( 0 ) except SyntaxError : # pragma: no cover raise IntroducedSyntaxErrors ( content_source ) return changed","title":"API"},{"location":"reference/isort/api/#module-isortapi","text":"View Source import shutil import sys import textwrap from io import StringIO from itertools import chain from pathlib import Path from typing import List , Optional , TextIO , Union from warnings import warn from . import io , output , parse from .exceptions import ( ExistingSyntaxErrors , FileSkipComment , FileSkipSetting , IntroducedSyntaxErrors , ) from .format import ( ask_whether_to_apply_changes_to_file , format_natural , remove_whitespace , show_unified_diff , ) from .io import Empty from .place import module as place_module # skipcq: PYL-W0611 (intended export of public API) from .place import module_with_reason as place_module_with_reason # skipcq: PYL-W0611 (^) from .settings import DEFAULT_CONFIG , FILE_SKIP_COMMENTS , Config CIMPORT_IDENTIFIERS = ( \"cimport \" , \"cimport*\" , \"from.cimport\" ) IMPORT_START_IDENTIFIERS = ( \"from \" , \"from.import\" , \"import \" , \"import*\" ) + CIMPORT_IDENTIFIERS COMMENT_INDICATORS = ( '\"\"\"' , \"'''\" , \"'\" , '\"' , \"#\" ) def sort_code_string ( code : str , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ): \"\"\"Sorts any imports within the provided code string, returning a new string with them sorted. - **code**: The string of code with imports that need to be sorted. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" input_stream = StringIO ( code ) output_stream = StringIO () config = _config ( path = file_path , config = config , ** config_kwargs ) sort_stream ( input_stream , output_stream , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) output_stream . seek ( 0 ) return output_stream . read () def check_code_string ( code : str , show_diff : bool = False , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ) -> bool : \"\"\"Checks the order, format, and categorization of imports within the provided code string. Returns `True` if everything is correct, otherwise `False`. - **code**: The string of code with imports that need to be sorted. - **show_diff**: If `True` the changes that need to be done will be printed to stdout. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( path = file_path , config = config , ** config_kwargs ) return check_stream ( StringIO ( code ), show_diff = show_diff , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) def sort_stream ( input_stream : TextIO , output_stream : TextIO , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ): \"\"\"Sorts any imports within the provided code stream, outputs to the provided output stream. Directly returns nothing. - **input_stream**: The stream of code with imports that need to be sorted. - **output_stream**: The stream where sorted imports should be written to. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( path = file_path , config = config , ** config_kwargs ) content_source = str ( file_path or \"Passed in content\" ) if not disregard_skip : if file_path and config . is_skipped ( file_path ): raise FileSkipSetting ( content_source ) if config . atomic : try : file_content = input_stream . read () compile ( file_content , content_source , \"exec\" , 0 , 1 ) input_stream = StringIO ( file_content ) except SyntaxError : raise ExistingSyntaxErrors ( content_source ) try : changed = _sort_imports ( input_stream , output_stream , extension = extension , config = config ) except FileSkipComment : raise FileSkipComment ( content_source ) if config . atomic : output_stream . seek ( 0 ) try : compile ( output_stream . read (), content_source , \"exec\" , 0 , 1 ) output_stream . seek ( 0 ) except SyntaxError : # pragma: no cover raise IntroducedSyntaxErrors ( content_source ) return changed def check_stream ( input_stream : TextIO , show_diff : bool = False , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ) -> bool : \"\"\"Checks any imports within the provided code stream, returning `False` if any unsorted or incorrectly imports are found or `True` if no problems are identified. - **input_stream**: The stream of code with imports that need to be sorted. - **show_diff**: If `True` the changes that need to be done will be printed to stdout. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( path = file_path , config = config , ** config_kwargs ) changed : bool = sort_stream ( input_stream = input_stream , output_stream = Empty , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) if not changed : if config . verbose : print ( f \"SUCCESS: {file_path or ''} Everything Looks Good!\" ) return True else : print ( f \"ERROR: {file_path or ''} Imports are incorrectly sorted and/or formatted.\" ) if show_diff : output_stream = StringIO () input_stream . seek ( 0 ) file_contents = input_stream . read () sort_stream ( input_stream = StringIO ( file_contents ), output_stream = output_stream , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) output_stream . seek ( 0 ) show_unified_diff ( file_input = file_contents , file_output = output_stream . read (), file_path = file_path ) return False def check_file ( filename : Union [ str , Path ], show_diff : bool = False , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = True , ** config_kwargs , ) -> bool : \"\"\"Checks any imports within the provided file, returning `False` if any unsorted or incorrectly imports are found or `True` if no problems are identified. - **filename**: The name or Path of the file to check. - **show_diff**: If `True` the changes that need to be done will be printed to stdout. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" with io . File . read ( filename ) as source_file : return check_stream ( source_file . stream , show_diff = show_diff , extension = source_file . extension or \"py\" , config = config , file_path = file_path or source_file . path , disregard_skip = disregard_skip , ** config_kwargs , ) def sort_file ( filename : Union [ str , Path ], extension : str = \"py\" , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = True , ask_to_apply : bool = False , show_diff : bool = False , write_to_stdout : bool = False , ** config_kwargs , ): \"\"\"Sorts and formats any groups of imports imports within the provided file or Path. - **filename**: The name or Path of the file to format. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - **ask_to_apply**: If `True`, prompt before applying any changes. - **show_diff**: If `True` the changes that need to be done will be printed to stdout. - **write_to_stdout**: If `True`, write to stdout instead of the input file. - ****config_kwargs**: Any config modifications. \"\"\" with io . File . read ( filename ) as source_file : changed : bool = False try : if write_to_stdout : changed = sort_stream ( input_stream = source_file . stream , output_stream = sys . stdout , config = config , file_path = file_path or source_file . path , disregard_skip = disregard_skip , ** config_kwargs , ) else : tmp_file = source_file . path . with_suffix ( source_file . path . suffix + \".isorted\" ) try : with tmp_file . open ( \"w\" , encoding = source_file . encoding , newline = \"\" ) as output_stream : shutil . copymode ( filename , tmp_file ) changed = sort_stream ( input_stream = source_file . stream , output_stream = output_stream , config = config , file_path = file_path or source_file . path , disregard_skip = disregard_skip , ** config_kwargs , ) if changed : if show_diff or ask_to_apply : source_file . stream . seek ( 0 ) show_unified_diff ( file_input = source_file . stream . read (), file_output = tmp_file . read_text ( encoding = source_file . encoding ), file_path = file_path or source_file . path , ) if ask_to_apply and not ask_whether_to_apply_changes_to_file ( str ( source_file . path ) ): return source_file . stream . close () tmp_file . replace ( source_file . path ) if not config . quiet : print ( f \"Fixing {source_file.path}\" ) finally : try : # Python 3.8+: use `missing_ok=True` instead of try except. tmp_file . unlink () except FileNotFoundError : pass except ExistingSyntaxErrors : warn ( \"{file_path} unable to sort due to existing syntax errors\" ) except IntroducedSyntaxErrors : # pragma: no cover warn ( \"{file_path} unable to sort as isort introduces new syntax errors\" ) def _config ( path : Optional [ Path ] = None , config : Config = DEFAULT_CONFIG , ** config_kwargs ) -> Config : if path : if ( config is DEFAULT_CONFIG and \"settings_path\" not in config_kwargs and \"settings_file\" not in config_kwargs ): config_kwargs [ \"settings_path\" ] = path if config_kwargs : if config is not DEFAULT_CONFIG : raise ValueError ( \"You can either specify custom configuration options using kwargs or \" \"passing in a Config object. Not Both!\" ) config = Config ( ** config_kwargs ) return config def _sort_imports ( input_stream : TextIO , output_stream : TextIO , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , ) -> bool : \"\"\"Parses stream identifying sections of contiguous imports and sorting them Code with unsorted imports is read from the provided `input_stream`, sorted and then outputted to the specified `output_stream`. - `input_stream`: Text stream with unsorted import sections. - `output_stream`: Text stream to output sorted inputs into. - `config`: Config settings to use when sorting imports. Defaults settings. - *Default*: `isort.settings.DEFAULT_CONFIG`. - `extension`: The file extension or file extension rules that should be used. - *Default*: `\"py\"`. - *Choices*: `[\"py\", \"pyi\", \"pyx\"]`. Returns `True` if there were changes that needed to be made (errors present) from what was provided in the input_stream, otherwise `False`. \"\"\" line_separator : str = config . line_ending add_imports : List [ str ] = [ format_natural ( addition ) for addition in config . add_imports ] import_section : str = \"\" next_import_section : str = \"\" next_cimports : bool = False in_quote : str = \"\" first_comment_index_start : int = - 1 first_comment_index_end : int = - 1 contains_imports : bool = False in_top_comment : bool = False first_import_section : bool = True section_comments = [ f \"# {heading}\" for heading in config . import_headings . values ()] indent : str = \"\" isort_off : bool = False cimports : bool = False made_changes : bool = False for index , line in enumerate ( chain ( input_stream , ( None ,))): if line is None : if index == 0 and not config . force_adds : return False not_imports = True line = \"\" if not line_separator : line_separator = \" \\n \" else : if not line_separator : line_separator = line [ - 1 ] for file_skip_comment in FILE_SKIP_COMMENTS : if file_skip_comment in line : raise FileSkipComment ( \"Passed in content\" ) stripped_line = line . strip () if ( ( index == 0 or ( index in ( 1 , 2 ) and not contains_imports )) and stripped_line . startswith ( \"#\" ) and stripped_line not in section_comments ): in_top_comment = True elif in_top_comment : if not line . startswith ( \"#\" ) or stripped_line in section_comments : in_top_comment = False first_comment_index_end = index - 1 if ( not stripped_line . startswith ( \"#\" ) or in_quote ) and '\"' in line or \"'\" in line : char_index = 0 if first_comment_index_start == - 1 and ( line . startswith ( '\"' ) or line . startswith ( \"'\" ) ): first_comment_index_start = index while char_index < len ( line ): if line [ char_index ] == \" \\\\ \" : char_index += 1 elif in_quote : if line [ char_index : char_index + len ( in_quote )] == in_quote : in_quote = \"\" if first_comment_index_end < first_comment_index_start : first_comment_index_end = index elif line [ char_index ] in ( \"'\" , '\"' ): long_quote = line [ char_index : char_index + 3 ] if long_quote in ( '\"\"\"' , \"'''\" ): in_quote = long_quote char_index += 2 else : in_quote = line [ char_index ] elif line [ char_index ] == \"#\" : break char_index += 1 not_imports = bool ( in_quote ) or in_top_comment or isort_off if not ( in_quote or in_top_comment ): stripped_line = line . strip () if isort_off : if stripped_line == \"# isort: on\" : isort_off = False elif stripped_line == \"# isort: off\" : not_imports = True isort_off = True elif stripped_line == \"# isort: split\" : not_imports = True elif ( not stripped_line or stripped_line . startswith ( \"#\" ) and ( not indent or indent + line . lstrip () == line ) ): import_section += line elif stripped_line . startswith ( IMPORT_START_IDENTIFIERS ): contains_imports = True new_indent = line [: - len ( line . lstrip ())] import_statement = line stripped_line = line . strip () . split ( \"#\" )[ 0 ] while stripped_line . endswith ( \" \\\\ \" ) or ( \"(\" in stripped_line and \")\" not in stripped_line ): if stripped_line . endswith ( \" \\\\ \" ): while stripped_line and stripped_line . endswith ( \" \\\\ \" ): line = input_stream . readline () stripped_line = line . strip () . split ( \"#\" )[ 0 ] import_statement += line else : while \")\" not in stripped_line : line = input_stream . readline () stripped_line = line . strip () . split ( \"#\" )[ 0 ] import_statement += line cimport_statement : bool = False if ( import_statement . lstrip () . startswith ( CIMPORT_IDENTIFIERS ) or \" cimport \" in import_statement or \" cimport*\" in import_statement or \" cimport(\" in import_statement or \".cimport\" in import_statement ): cimport_statement = True if cimport_statement != cimports or ( new_indent != indent and import_section ): if import_section : next_cimports = cimport_statement next_import_section = import_statement import_statement = \"\" not_imports = True line = \"\" else : cimports = cimport_statement indent = new_indent import_section += import_statement else : not_imports = True if not_imports : if ( add_imports and not in_top_comment and not in_quote and not import_section and not line . lstrip () . startswith ( COMMENT_INDICATORS ) ): import_section = line_separator . join ( add_imports ) + line_separator contains_imports = True add_imports = [] if next_import_section and not import_section : # pragma: no cover import_section = next_import_section next_import_section = \"\" if import_section : if add_imports and not indent : import_section += line_separator . join ( add_imports ) + line_separator contains_imports = True add_imports = [] if not indent : import_section += line if not contains_imports : output_stream . write ( import_section ) else : leading_whitespace = import_section [: - len ( import_section . lstrip ())] trailing_whitespace = import_section [ len ( import_section . rstrip ()) :] if first_import_section and not import_section . lstrip ( line_separator ) . startswith ( COMMENT_INDICATORS ): import_section = import_section . lstrip ( line_separator ) first_import_section = False raw_import_section : str = import_section if indent : import_section = line_separator . join ( line . lstrip () for line in import_section . split ( line_separator ) ) out_config = Config ( config = config , line_length = max ( config . line_length - len ( indent ), 0 ) ) else : out_config = config sorted_import_section = output . sorted_imports ( parse . file_contents ( import_section , config = config ), out_config , extension , import_type = \"cimport\" if cimports else \"import\" , ) if indent : sorted_import_section = ( leading_whitespace + textwrap . indent ( sorted_import_section , indent ) . strip () + trailing_whitespace ) if not made_changes : if config . ignore_whitespace : compare_in = remove_whitespace ( raw_import_section , line_separator = line_separator ) . strip () compare_out = remove_whitespace ( sorted_import_section , line_separator = line_separator ) . strip () else : compare_in = raw_import_section . strip () compare_out = sorted_import_section . strip () if compare_out != compare_in : made_changes = True output_stream . write ( sorted_import_section ) if not line and not indent and next_import_section : output_stream . write ( line_separator ) if indent : output_stream . write ( line ) if not next_import_section : indent = \"\" if next_import_section : cimports = next_cimports contains_imports = True else : contains_imports = False import_section = next_import_section next_import_section = \"\" else : output_stream . write ( line ) not_imports = False return made_changes","title":"Module isort.api"},{"location":"reference/isort/api/#variables","text":"CIMPORT_IDENTIFIERS COMMENT_INDICATORS FILE_SKIP_COMMENTS IMPORT_START_IDENTIFIERS","title":"Variables"},{"location":"reference/isort/api/#functions","text":"","title":"Functions"},{"location":"reference/isort/api/#check_code_string","text":"def check_code_string ( code : str , show_diff : bool = False , extension : str = 'py' , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = False , ** config_kwargs ) -> bool Checks the order, format, and categorization of imports within the provided code string. Returns True if everything is correct, otherwise False . code : The string of code with imports that need to be sorted. show_diff : If True the changes that need to be done will be printed to stdout. extension : The file extension that contains the code. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. **config_kwargs : Any config modifications. View Source def check_code_string ( code : str , show_diff : bool = False , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ) -> bool : \"\"\"Checks the order, format, and categorization of imports within the provided code string. Returns `True` if everything is correct, otherwise `False`. - **code**: The string of code with imports that need to be sorted. - **show_diff**: If `True` the changes that need to be done will be printed to stdout. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( path = file_path , config = config , ** config_kwargs ) return check_stream ( StringIO ( code ), show_diff = show_diff , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , )","title":"check_code_string"},{"location":"reference/isort/api/#check_file","text":"def check_file ( filename : Union [ str , pathlib . Path ], show_diff : bool = False , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = True , ** config_kwargs ) -> bool Checks any imports within the provided file, returning False if any unsorted or incorrectly imports are found or True if no problems are identified. filename : The name or Path of the file to check. show_diff : If True the changes that need to be done will be printed to stdout. extension : The file extension that contains the code. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. **config_kwargs : Any config modifications. View Source def check_file ( filename : Union [ str , Path ], show_diff : bool = False , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = True , ** config_kwargs , ) -> bool : \"\"\"Checks any imports within the provided file, returning `False` if any unsorted or incorrectly imports are found or `True` if no problems are identified. - **filename**: The name or Path of the file to check. - **show_diff**: If `True` the changes that need to be done will be printed to stdout. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" with io . File . read ( filename ) as source_file : return check_stream ( source_file . stream , show_diff = show_diff , extension = source_file . extension or \"py\" , config = config , file_path = file_path or source_file . path , disregard_skip = disregard_skip , ** config_kwargs , )","title":"check_file"},{"location":"reference/isort/api/#check_stream","text":"def check_stream ( input_stream : < class ' TextIO '>, show_diff : bool = False , extension : str = 'py' , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = False , ** config_kwargs ) -> bool Checks any imports within the provided code stream, returning False if any unsorted or incorrectly imports are found or True if no problems are identified. input_stream : The stream of code with imports that need to be sorted. show_diff : If True the changes that need to be done will be printed to stdout. extension : The file extension that contains the code. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. **config_kwargs : Any config modifications. View Source def check_stream ( input_stream : TextIO , show_diff : bool = False , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ) -> bool : \"\"\"Checks any imports within the provided code stream, returning `False` if any unsorted or incorrectly imports are found or `True` if no problems are identified. - **input_stream**: The stream of code with imports that need to be sorted. - **show_diff**: If `True` the changes that need to be done will be printed to stdout. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( path = file_path , config = config , ** config_kwargs ) changed : bool = sort_stream ( input_stream = input_stream , output_stream = Empty , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) if not changed : if config . verbose : print ( f \"SUCCESS: {file_path or ''} Everything Looks Good!\" ) return True else : print ( f \"ERROR: {file_path or ''} Imports are incorrectly sorted and/or formatted.\" ) if show_diff : output_stream = StringIO () input_stream . seek ( 0 ) file_contents = input_stream . read () sort_stream ( input_stream = StringIO ( file_contents ), output_stream = output_stream , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) output_stream . seek ( 0 ) show_unified_diff ( file_input = file_contents , file_output = output_stream . read (), file_path = file_path ) return False","title":"check_stream"},{"location":"reference/isort/api/#sort_code_string","text":"def sort_code_string ( code : str , extension : str = 'py' , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = False , ** config_kwargs ) Sorts any imports within the provided code string, returning a new string with them sorted. code : The string of code with imports that need to be sorted. extension : The file extension that contains the code. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. **config_kwargs : Any config modifications. View Source def sort_code_string ( code : str , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ): \"\"\"Sorts any imports within the provided code string, returning a new string with them sorted. - **code**: The string of code with imports that need to be sorted. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" input_stream = StringIO ( code ) output_stream = StringIO () config = _config ( path = file_path , config = config , ** config_kwargs ) sort_stream ( input_stream , output_stream , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) output_stream . seek ( 0 ) return output_stream . read ()","title":"sort_code_string"},{"location":"reference/isort/api/#sort_file","text":"def sort_file ( filename : Union [ str , pathlib . Path ], extension : str = 'py' , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = True , ask_to_apply : bool = False , show_diff : bool = False , write_to_stdout : bool = False , ** config_kwargs ) Sorts and formats any groups of imports imports within the provided file or Path. filename : The name or Path of the file to format. extension : The file extension that contains the code. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. ask_to_apply : If True , prompt before applying any changes. show_diff : If True the changes that need to be done will be printed to stdout. write_to_stdout : If True , write to stdout instead of the input file. **config_kwargs : Any config modifications. View Source def sort_file ( filename : Union [ str , Path ], extension : str = \"py\" , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = True , ask_to_apply : bool = False , show_diff : bool = False , write_to_stdout : bool = False , ** config_kwargs , ): \"\"\"Sorts and formats any groups of imports imports within the provided file or Path. - **filename**: The name or Path of the file to format. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - **ask_to_apply**: If `True`, prompt before applying any changes. - **show_diff**: If `True` the changes that need to be done will be printed to stdout. - **write_to_stdout**: If `True`, write to stdout instead of the input file. - ****config_kwargs**: Any config modifications. \"\"\" with io . File . read ( filename ) as source_file : changed : bool = False try : if write_to_stdout : changed = sort_stream ( input_stream = source_file . stream , output_stream = sys . stdout , config = config , file_path = file_path or source_file . path , disregard_skip = disregard_skip , ** config_kwargs , ) else : tmp_file = source_file . path . with_suffix ( source_file . path . suffix + \".isorted\" ) try : with tmp_file . open ( \"w\" , encoding = source_file . encoding , newline = \"\" ) as output_stream : shutil . copymode ( filename , tmp_file ) changed = sort_stream ( input_stream = source_file . stream , output_stream = output_stream , config = config , file_path = file_path or source_file . path , disregard_skip = disregard_skip , ** config_kwargs , ) if changed : if show_diff or ask_to_apply : source_file . stream . seek ( 0 ) show_unified_diff ( file_input = source_file . stream . read (), file_output = tmp_file . read_text ( encoding = source_file . encoding ), file_path = file_path or source_file . path , ) if ask_to_apply and not ask_whether_to_apply_changes_to_file ( str ( source_file . path ) ): return source_file . stream . close () tmp_file . replace ( source_file . path ) if not config . quiet : print ( f \"Fixing {source_file.path}\" ) finally : try : # Python 3.8+: use `missing_ok=True` instead of try except. tmp_file . unlink () except FileNotFoundError : pass except ExistingSyntaxErrors : warn ( \"{file_path} unable to sort due to existing syntax errors\" ) except IntroducedSyntaxErrors : # pragma: no cover warn ( \"{file_path} unable to sort as isort introduces new syntax errors\" )","title":"sort_file"},{"location":"reference/isort/api/#sort_stream","text":"def sort_stream ( input_stream : < class ' TextIO '>, output_stream : < class ' TextIO '>, extension : str = 'py' , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = False , ** config_kwargs ) Sorts any imports within the provided code stream, outputs to the provided output stream. Directly returns nothing. input_stream : The stream of code with imports that need to be sorted. output_stream : The stream where sorted imports should be written to. extension : The file extension that contains the code. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. **config_kwargs : Any config modifications. View Source def sort_stream ( input_stream : TextIO , output_stream : TextIO , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ): \"\"\"Sorts any imports within the provided code stream, outputs to the provided output stream. Directly returns nothing. - **input_stream**: The stream of code with imports that need to be sorted. - **output_stream**: The stream where sorted imports should be written to. - **extension**: The file extension that contains the code. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( path = file_path , config = config , ** config_kwargs ) content_source = str ( file_path or \"Passed in content\" ) if not disregard_skip : if file_path and config . is_skipped ( file_path ): raise FileSkipSetting ( content_source ) if config . atomic : try : file_content = input_stream . read () compile ( file_content , content_source , \"exec\" , 0 , 1 ) input_stream = StringIO ( file_content ) except SyntaxError : raise ExistingSyntaxErrors ( content_source ) try : changed = _sort_imports ( input_stream , output_stream , extension = extension , config = config ) except FileSkipComment : raise FileSkipComment ( content_source ) if config . atomic : output_stream . seek ( 0 ) try : compile ( output_stream . read (), content_source , \"exec\" , 0 , 1 ) output_stream . seek ( 0 ) except SyntaxError : # pragma: no cover raise IntroducedSyntaxErrors ( content_source ) return changed","title":"sort_stream"},{"location":"reference/isort/comments/","text":"Module isort.comments View Source from typing import List , Optional , Tuple def parse ( line : str ) -> Tuple [ str , str ]: \"\"\"Parses import lines for comments and returns back the import statement and the associated comment. \"\"\" comment_start = line . find ( \"#\" ) if comment_start != - 1 : return ( line [: comment_start ], line [ comment_start + 1 :] . strip ()) return ( line , \"\" ) def add_to_line ( comments : Optional [ List [ str ]], original_string : str = \"\" , removed : bool = False , comment_prefix : str = \"\" , ) -> str : \"\"\"Returns a string with comments added if removed is not set.\"\"\" if removed : return parse ( original_string )[ 0 ] if not comments : return original_string else : unique_comments : List [ str ] = [] for comment in comments : if comment not in unique_comments : unique_comments . append ( comment ) return f \"{parse(original_string)[0]}{comment_prefix} {'; '.join(unique_comments)}\" Functions add_to_line def add_to_line ( comments : Union [ List [ str ], NoneType ], original_string : str = '' , removed : bool = False , comment_prefix : str = '' ) -> str Returns a string with comments added if removed is not set. View Source def add_to_line ( comments : Optional [ List[str ] ] , original_string : str = \"\" , removed : bool = False , comment_prefix : str = \"\" , ) -> str : \"\"\"Returns a string with comments added if removed is not set.\"\"\" if removed : return parse ( original_string ) [ 0 ] if not comments : return original_string else : unique_comments : List [ str ] = [] for comment in comments : if comment not in unique_comments : unique_comments . append ( comment ) return f \"{parse(original_string)[0]}{comment_prefix} {'; '.join(unique_comments)}\" parse def parse ( line : str ) -> Tuple [ str , str ] Parses import lines for comments and returns back the import statement and the associated comment. View Source def parse ( line : str ) -> Tuple [ str , str ]: \"\"\"Parses import lines for comments and returns back the import statement and the associated comment. \"\"\" comment_start = line . find ( \"#\" ) if comment_start != - 1 : return ( line [: comment_start ], line [ comment_start + 1 :] . strip ()) return ( line , \"\" )","title":"Comments"},{"location":"reference/isort/comments/#module-isortcomments","text":"View Source from typing import List , Optional , Tuple def parse ( line : str ) -> Tuple [ str , str ]: \"\"\"Parses import lines for comments and returns back the import statement and the associated comment. \"\"\" comment_start = line . find ( \"#\" ) if comment_start != - 1 : return ( line [: comment_start ], line [ comment_start + 1 :] . strip ()) return ( line , \"\" ) def add_to_line ( comments : Optional [ List [ str ]], original_string : str = \"\" , removed : bool = False , comment_prefix : str = \"\" , ) -> str : \"\"\"Returns a string with comments added if removed is not set.\"\"\" if removed : return parse ( original_string )[ 0 ] if not comments : return original_string else : unique_comments : List [ str ] = [] for comment in comments : if comment not in unique_comments : unique_comments . append ( comment ) return f \"{parse(original_string)[0]}{comment_prefix} {'; '.join(unique_comments)}\"","title":"Module isort.comments"},{"location":"reference/isort/comments/#functions","text":"","title":"Functions"},{"location":"reference/isort/comments/#add_to_line","text":"def add_to_line ( comments : Union [ List [ str ], NoneType ], original_string : str = '' , removed : bool = False , comment_prefix : str = '' ) -> str Returns a string with comments added if removed is not set. View Source def add_to_line ( comments : Optional [ List[str ] ] , original_string : str = \"\" , removed : bool = False , comment_prefix : str = \"\" , ) -> str : \"\"\"Returns a string with comments added if removed is not set.\"\"\" if removed : return parse ( original_string ) [ 0 ] if not comments : return original_string else : unique_comments : List [ str ] = [] for comment in comments : if comment not in unique_comments : unique_comments . append ( comment ) return f \"{parse(original_string)[0]}{comment_prefix} {'; '.join(unique_comments)}\"","title":"add_to_line"},{"location":"reference/isort/comments/#parse","text":"def parse ( line : str ) -> Tuple [ str , str ] Parses import lines for comments and returns back the import statement and the associated comment. View Source def parse ( line : str ) -> Tuple [ str , str ]: \"\"\"Parses import lines for comments and returns back the import statement and the associated comment. \"\"\" comment_start = line . find ( \"#\" ) if comment_start != - 1 : return ( line [: comment_start ], line [ comment_start + 1 :] . strip ()) return ( line , \"\" )","title":"parse"},{"location":"reference/isort/exceptions/","text":"Module isort.exceptions All isort specific exception classes should be defined here View Source \"\"\"All isort specific exception classes should be defined here\"\"\" from .profiles import profiles class ISortError ( Exception ): \"\"\"Base isort exception object from which all isort sourced exceptions should inherit\"\"\" class ExistingSyntaxErrors ( ISortError ): \"\"\"Raised when isort is told to sort imports within code that has existing syntax errors\"\"\" def __init__ ( self , file_path : str ): super () . __init__ ( f \"isort was told to sort imports within code that contains syntax errors: \" f \"{file_path}.\" ) self . file_path = file_path class IntroducedSyntaxErrors ( ISortError ): \"\"\"Raised when isort has introduced a syntax error in the process of sorting imports\"\"\" def __init__ ( self , file_path : str ): super () . __init__ ( f \"isort introduced syntax errors when attempting to sort the imports contained within \" f \"{file_path}.\" ) self . file_path = file_path class FileSkipped ( ISortError ): \"\"\"Should be raised when a file is skipped for any reason\"\"\" def __init__ ( self , message : str , file_path : str ): super () . __init__ ( message ) self . file_path = file_path class FileSkipComment ( FileSkipped ): \"\"\"Raised when an entire file is skipped due to a isort skip file comment\"\"\" def __init__ ( self , file_path : str ): super () . __init__ ( f \"{file_path} contains an file skip comment and was skipped.\" , file_path = file_path ) class FileSkipSetting ( FileSkipped ): \"\"\"Raised when an entire file is skipped due to provided isort settings\"\"\" def __init__ ( self , file_path : str ): super () . __init__ ( f \"{file_path} was skipped as it's listed in 'skip' setting\" \" or matches a glob in 'skip_glob' setting\" , file_path = file_path , ) class ProfileDoesNotExist ( ISortError ): \"\"\"Raised when a profile is set by the user that doesn't exist\"\"\" def __init__ ( self , profile : str ): super () . __init__ ( f \"Specified profile of {profile} does not exist. \" f \"Available profiles: {','.join(profiles)}.\" ) self . profile = profile Variables profiles Classes ExistingSyntaxErrors class ExistingSyntaxErrors ( file_path : str ) Raised when isort is told to sort imports within code that has existing syntax errors View Source class ExistingSyntaxErrors ( ISortError ): \"\"\"Raised when isort is told to sort imports within code that has existing syntax errors\"\"\" def __init__ ( self , file_path: str ): super (). __init__ ( f \"isort was told to sort imports within code that contains syntax errors: \" f \"{file_path}.\" ) self . file_path = file_path Ancestors (in MRO) isort.exceptions.ISortError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. FileSkipComment class FileSkipComment ( file_path : str ) Raised when an entire file is skipped due to a isort skip file comment View Source class FileSkipComment ( FileSkipped ): \"\"\"Raised when an entire file is skipped due to a isort skip file comment\"\"\" def __init__ ( self , file_path: str ): super (). __init__ ( f \"{file_path} contains an file skip comment and was skipped.\" , file_path = file_path ) Ancestors (in MRO) isort.exceptions.FileSkipped isort.exceptions.ISortError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. FileSkipSetting class FileSkipSetting ( file_path : str ) Raised when an entire file is skipped due to provided isort settings View Source class FileSkipSetting ( FileSkipped ): \"\"\"Raised when an entire file is skipped due to provided isort settings\"\"\" def __init__ ( self , file_path: str ): super (). __init__ ( f \"{file_path} was skipped as it's listed in 'skip' setting\" \" or matches a glob in 'skip_glob' setting\" , file_path = file_path , ) Ancestors (in MRO) isort.exceptions.FileSkipped isort.exceptions.ISortError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. FileSkipped class FileSkipped ( message : str , file_path : str ) Should be raised when a file is skipped for any reason View Source class FileSkipped ( ISortError ): \"\"\"Should be raised when a file is skipped for any reason\"\"\" def __init__ ( self , message: str , file_path: str ): super (). __init__ ( message ) self . file_path = file_path Ancestors (in MRO) isort.exceptions.ISortError builtins.Exception builtins.BaseException Descendants isort.exceptions.FileSkipComment isort.exceptions.FileSkipSetting Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. ISortError class ISortError ( / , * args , ** kwargs ) Base isort exception object from which all isort sourced exceptions should inherit View Source class ISortError ( Exception ): \"\"\"Base isort exception object from which all isort sourced exceptions should inherit\"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Descendants isort.exceptions.ExistingSyntaxErrors isort.exceptions.IntroducedSyntaxErrors isort.exceptions.FileSkipped isort.exceptions.ProfileDoesNotExist Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. IntroducedSyntaxErrors class IntroducedSyntaxErrors ( file_path : str ) Raised when isort has introduced a syntax error in the process of sorting imports View Source class IntroducedSyntaxErrors ( ISortError ): \"\"\"Raised when isort has introduced a syntax error in the process of sorting imports\"\"\" def __init__ ( self , file_path: str ): super (). __init__ ( f \"isort introduced syntax errors when attempting to sort the imports contained within \" f \"{file_path}.\" ) self . file_path = file_path Ancestors (in MRO) isort.exceptions.ISortError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. ProfileDoesNotExist class ProfileDoesNotExist ( profile : str ) Raised when a profile is set by the user that doesn't exist View Source class ProfileDoesNotExist ( ISortError ): \"\"\"Raised when a profile is set by the user that doesn't exist\"\"\" def __init__ ( self , profile: str ): super (). __init__ ( f \"Specified profile of {profile} does not exist. \" f \"Available profiles: {','.join(profiles)}.\" ) self . profile = profile Ancestors (in MRO) isort.exceptions.ISortError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Exceptions"},{"location":"reference/isort/exceptions/#module-isortexceptions","text":"All isort specific exception classes should be defined here View Source \"\"\"All isort specific exception classes should be defined here\"\"\" from .profiles import profiles class ISortError ( Exception ): \"\"\"Base isort exception object from which all isort sourced exceptions should inherit\"\"\" class ExistingSyntaxErrors ( ISortError ): \"\"\"Raised when isort is told to sort imports within code that has existing syntax errors\"\"\" def __init__ ( self , file_path : str ): super () . __init__ ( f \"isort was told to sort imports within code that contains syntax errors: \" f \"{file_path}.\" ) self . file_path = file_path class IntroducedSyntaxErrors ( ISortError ): \"\"\"Raised when isort has introduced a syntax error in the process of sorting imports\"\"\" def __init__ ( self , file_path : str ): super () . __init__ ( f \"isort introduced syntax errors when attempting to sort the imports contained within \" f \"{file_path}.\" ) self . file_path = file_path class FileSkipped ( ISortError ): \"\"\"Should be raised when a file is skipped for any reason\"\"\" def __init__ ( self , message : str , file_path : str ): super () . __init__ ( message ) self . file_path = file_path class FileSkipComment ( FileSkipped ): \"\"\"Raised when an entire file is skipped due to a isort skip file comment\"\"\" def __init__ ( self , file_path : str ): super () . __init__ ( f \"{file_path} contains an file skip comment and was skipped.\" , file_path = file_path ) class FileSkipSetting ( FileSkipped ): \"\"\"Raised when an entire file is skipped due to provided isort settings\"\"\" def __init__ ( self , file_path : str ): super () . __init__ ( f \"{file_path} was skipped as it's listed in 'skip' setting\" \" or matches a glob in 'skip_glob' setting\" , file_path = file_path , ) class ProfileDoesNotExist ( ISortError ): \"\"\"Raised when a profile is set by the user that doesn't exist\"\"\" def __init__ ( self , profile : str ): super () . __init__ ( f \"Specified profile of {profile} does not exist. \" f \"Available profiles: {','.join(profiles)}.\" ) self . profile = profile","title":"Module isort.exceptions"},{"location":"reference/isort/exceptions/#variables","text":"profiles","title":"Variables"},{"location":"reference/isort/exceptions/#classes","text":"","title":"Classes"},{"location":"reference/isort/exceptions/#existingsyntaxerrors","text":"class ExistingSyntaxErrors ( file_path : str ) Raised when isort is told to sort imports within code that has existing syntax errors View Source class ExistingSyntaxErrors ( ISortError ): \"\"\"Raised when isort is told to sort imports within code that has existing syntax errors\"\"\" def __init__ ( self , file_path: str ): super (). __init__ ( f \"isort was told to sort imports within code that contains syntax errors: \" f \"{file_path}.\" ) self . file_path = file_path","title":"ExistingSyntaxErrors"},{"location":"reference/isort/exceptions/#ancestors-in-mro","text":"isort.exceptions.ISortError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#class-variables","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/exceptions/#fileskipcomment","text":"class FileSkipComment ( file_path : str ) Raised when an entire file is skipped due to a isort skip file comment View Source class FileSkipComment ( FileSkipped ): \"\"\"Raised when an entire file is skipped due to a isort skip file comment\"\"\" def __init__ ( self , file_path: str ): super (). __init__ ( f \"{file_path} contains an file skip comment and was skipped.\" , file_path = file_path )","title":"FileSkipComment"},{"location":"reference/isort/exceptions/#ancestors-in-mro_1","text":"isort.exceptions.FileSkipped isort.exceptions.ISortError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#class-variables_1","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods_1","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback_1","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/exceptions/#fileskipsetting","text":"class FileSkipSetting ( file_path : str ) Raised when an entire file is skipped due to provided isort settings View Source class FileSkipSetting ( FileSkipped ): \"\"\"Raised when an entire file is skipped due to provided isort settings\"\"\" def __init__ ( self , file_path: str ): super (). __init__ ( f \"{file_path} was skipped as it's listed in 'skip' setting\" \" or matches a glob in 'skip_glob' setting\" , file_path = file_path , )","title":"FileSkipSetting"},{"location":"reference/isort/exceptions/#ancestors-in-mro_2","text":"isort.exceptions.FileSkipped isort.exceptions.ISortError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#class-variables_2","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods_2","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback_2","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/exceptions/#fileskipped","text":"class FileSkipped ( message : str , file_path : str ) Should be raised when a file is skipped for any reason View Source class FileSkipped ( ISortError ): \"\"\"Should be raised when a file is skipped for any reason\"\"\" def __init__ ( self , message: str , file_path: str ): super (). __init__ ( message ) self . file_path = file_path","title":"FileSkipped"},{"location":"reference/isort/exceptions/#ancestors-in-mro_3","text":"isort.exceptions.ISortError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#descendants","text":"isort.exceptions.FileSkipComment isort.exceptions.FileSkipSetting","title":"Descendants"},{"location":"reference/isort/exceptions/#class-variables_3","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods_3","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback_3","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/exceptions/#isorterror","text":"class ISortError ( / , * args , ** kwargs ) Base isort exception object from which all isort sourced exceptions should inherit View Source class ISortError ( Exception ): \"\"\"Base isort exception object from which all isort sourced exceptions should inherit\"\"\"","title":"ISortError"},{"location":"reference/isort/exceptions/#ancestors-in-mro_4","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#descendants_1","text":"isort.exceptions.ExistingSyntaxErrors isort.exceptions.IntroducedSyntaxErrors isort.exceptions.FileSkipped isort.exceptions.ProfileDoesNotExist","title":"Descendants"},{"location":"reference/isort/exceptions/#class-variables_4","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods_4","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback_4","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/exceptions/#introducedsyntaxerrors","text":"class IntroducedSyntaxErrors ( file_path : str ) Raised when isort has introduced a syntax error in the process of sorting imports View Source class IntroducedSyntaxErrors ( ISortError ): \"\"\"Raised when isort has introduced a syntax error in the process of sorting imports\"\"\" def __init__ ( self , file_path: str ): super (). __init__ ( f \"isort introduced syntax errors when attempting to sort the imports contained within \" f \"{file_path}.\" ) self . file_path = file_path","title":"IntroducedSyntaxErrors"},{"location":"reference/isort/exceptions/#ancestors-in-mro_5","text":"isort.exceptions.ISortError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#class-variables_5","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods_5","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback_5","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/exceptions/#profiledoesnotexist","text":"class ProfileDoesNotExist ( profile : str ) Raised when a profile is set by the user that doesn't exist View Source class ProfileDoesNotExist ( ISortError ): \"\"\"Raised when a profile is set by the user that doesn't exist\"\"\" def __init__ ( self , profile: str ): super (). __init__ ( f \"Specified profile of {profile} does not exist. \" f \"Available profiles: {','.join(profiles)}.\" ) self . profile = profile","title":"ProfileDoesNotExist"},{"location":"reference/isort/exceptions/#ancestors-in-mro_6","text":"isort.exceptions.ISortError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#class-variables_6","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods_6","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback_6","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/format/","text":"Module isort.format View Source import sys from datetime import datetime from difflib import unified_diff from pathlib import Path from typing import Optional def format_simplified ( import_line : str ) -> str : import_line = import_line . strip () if import_line . startswith ( \"from \" ): import_line = import_line . replace ( \"from \" , \"\" ) import_line = import_line . replace ( \" import \" , \".\" ) elif import_line . startswith ( \"import \" ): import_line = import_line . replace ( \"import \" , \"\" ) return import_line def format_natural ( import_line : str ) -> str : import_line = import_line . strip () if not import_line . startswith ( \"from \" ) and not import_line . startswith ( \"import \" ): if \".\" not in import_line : return f \"import {import_line}\" parts = import_line . split ( \".\" ) end = parts . pop ( - 1 ) return f \"from {'.'.join(parts)} import {end}\" return import_line def show_unified_diff ( * , file_input : str , file_output : str , file_path : Optional [ Path ]): file_name = \"\" if file_path is None else str ( file_path ) file_mtime = str ( datetime . now () if file_path is None else datetime . fromtimestamp ( file_path . stat () . st_mtime ) ) unified_diff_lines = unified_diff ( file_input . splitlines ( keepends = True ), file_output . splitlines ( keepends = True ), fromfile = file_name + \":before\" , tofile = file_name + \":after\" , fromfiledate = file_mtime , tofiledate = str ( datetime . now ()), ) for line in unified_diff_lines : sys . stdout . write ( line ) def ask_whether_to_apply_changes_to_file ( file_path : str ) -> bool : answer = None while answer not in ( \"yes\" , \"y\" , \"no\" , \"n\" , \"quit\" , \"q\" ): answer = input ( f \"Apply suggested changes to '{file_path}' [y/n/q]? \" ) # nosec answer = answer . lower () if answer in ( \"no\" , \"n\" ): return False if answer in ( \"quit\" , \"q\" ): sys . exit ( 1 ) return True def remove_whitespace ( content : str , line_separator : str = \" \\n \" ) -> str : content = content . replace ( line_separator , \"\" ) . replace ( \" \" , \"\" ) . replace ( \" \\x0c \" , \"\" ) return content Functions ask_whether_to_apply_changes_to_file def ask_whether_to_apply_changes_to_file ( file_path : str ) -> bool View Source def ask_whether_to_apply_changes_to_file ( file_path : str ) -> bool : answer = None while answer not in ( \"yes\" , \"y\" , \"no\" , \"n\" , \"quit\" , \"q\" ): answer = input ( f \"Apply suggested changes to '{file_path}' [y/n/q]? \" ) # nosec answer = answer . lower () if answer in ( \"no\" , \"n\" ): return False if answer in ( \"quit\" , \"q\" ): sys . exit ( 1 ) return True format_natural def format_natural ( import_line : str ) -> str View Source def format_natural ( import_line : str ) -> str : import_line = import_line . strip () if not import_line . startswith ( \"from \" ) and not import_line . startswith ( \"import \" ): if \".\" not in import_line : return f \"import {import_line}\" parts = import_line . split ( \".\" ) end = parts . pop ( - 1 ) return f \"from {'.'.join(parts)} import {end}\" return import_line format_simplified def format_simplified ( import_line : str ) -> str View Source def format_simplified ( import_line : str ) -> str : import_line = import_line . strip () if import_line . startswith ( \"from \" ): import_line = import_line . replace ( \"from \" , \"\" ) import_line = import_line . replace ( \" import \" , \".\" ) elif import_line . startswith ( \"import \" ): import_line = import_line . replace ( \"import \" , \"\" ) return import_line remove_whitespace def remove_whitespace ( content : str , line_separator : str = ' \\n ' ) -> str View Source def remove_whitespace ( content : str , line_separator : str = \"\\n\" ) -> str : content = content . replace ( line_separator , \"\" ). replace ( \" \" , \"\" ). replace ( \"\\x0c\" , \"\" ) return content show_unified_diff def show_unified_diff ( * , file_input : str , file_output : str , file_path : Union [ pathlib . Path , NoneType ] ) View Source def show_unified_diff ( * , file_input : str , file_output : str , file_path : Optional [ Path ] ) : file_name = \"\" if file_path is None else str ( file_path ) file_mtime = str ( datetime . now () if file_path is None else datetime . fromtimestamp ( file_path . stat (). st_mtime ) ) unified_diff_lines = unified_diff ( file_input . splitlines ( keepends = True ), file_output . splitlines ( keepends = True ), fromfile = file_name + \":before\" , tofile = file_name + \":after\" , fromfiledate = file_mtime , tofiledate = str ( datetime . now ()), ) for line in unified_diff_lines : sys . stdout . write ( line )","title":"Format"},{"location":"reference/isort/format/#module-isortformat","text":"View Source import sys from datetime import datetime from difflib import unified_diff from pathlib import Path from typing import Optional def format_simplified ( import_line : str ) -> str : import_line = import_line . strip () if import_line . startswith ( \"from \" ): import_line = import_line . replace ( \"from \" , \"\" ) import_line = import_line . replace ( \" import \" , \".\" ) elif import_line . startswith ( \"import \" ): import_line = import_line . replace ( \"import \" , \"\" ) return import_line def format_natural ( import_line : str ) -> str : import_line = import_line . strip () if not import_line . startswith ( \"from \" ) and not import_line . startswith ( \"import \" ): if \".\" not in import_line : return f \"import {import_line}\" parts = import_line . split ( \".\" ) end = parts . pop ( - 1 ) return f \"from {'.'.join(parts)} import {end}\" return import_line def show_unified_diff ( * , file_input : str , file_output : str , file_path : Optional [ Path ]): file_name = \"\" if file_path is None else str ( file_path ) file_mtime = str ( datetime . now () if file_path is None else datetime . fromtimestamp ( file_path . stat () . st_mtime ) ) unified_diff_lines = unified_diff ( file_input . splitlines ( keepends = True ), file_output . splitlines ( keepends = True ), fromfile = file_name + \":before\" , tofile = file_name + \":after\" , fromfiledate = file_mtime , tofiledate = str ( datetime . now ()), ) for line in unified_diff_lines : sys . stdout . write ( line ) def ask_whether_to_apply_changes_to_file ( file_path : str ) -> bool : answer = None while answer not in ( \"yes\" , \"y\" , \"no\" , \"n\" , \"quit\" , \"q\" ): answer = input ( f \"Apply suggested changes to '{file_path}' [y/n/q]? \" ) # nosec answer = answer . lower () if answer in ( \"no\" , \"n\" ): return False if answer in ( \"quit\" , \"q\" ): sys . exit ( 1 ) return True def remove_whitespace ( content : str , line_separator : str = \" \\n \" ) -> str : content = content . replace ( line_separator , \"\" ) . replace ( \" \" , \"\" ) . replace ( \" \\x0c \" , \"\" ) return content","title":"Module isort.format"},{"location":"reference/isort/format/#functions","text":"","title":"Functions"},{"location":"reference/isort/format/#ask_whether_to_apply_changes_to_file","text":"def ask_whether_to_apply_changes_to_file ( file_path : str ) -> bool View Source def ask_whether_to_apply_changes_to_file ( file_path : str ) -> bool : answer = None while answer not in ( \"yes\" , \"y\" , \"no\" , \"n\" , \"quit\" , \"q\" ): answer = input ( f \"Apply suggested changes to '{file_path}' [y/n/q]? \" ) # nosec answer = answer . lower () if answer in ( \"no\" , \"n\" ): return False if answer in ( \"quit\" , \"q\" ): sys . exit ( 1 ) return True","title":"ask_whether_to_apply_changes_to_file"},{"location":"reference/isort/format/#format_natural","text":"def format_natural ( import_line : str ) -> str View Source def format_natural ( import_line : str ) -> str : import_line = import_line . strip () if not import_line . startswith ( \"from \" ) and not import_line . startswith ( \"import \" ): if \".\" not in import_line : return f \"import {import_line}\" parts = import_line . split ( \".\" ) end = parts . pop ( - 1 ) return f \"from {'.'.join(parts)} import {end}\" return import_line","title":"format_natural"},{"location":"reference/isort/format/#format_simplified","text":"def format_simplified ( import_line : str ) -> str View Source def format_simplified ( import_line : str ) -> str : import_line = import_line . strip () if import_line . startswith ( \"from \" ): import_line = import_line . replace ( \"from \" , \"\" ) import_line = import_line . replace ( \" import \" , \".\" ) elif import_line . startswith ( \"import \" ): import_line = import_line . replace ( \"import \" , \"\" ) return import_line","title":"format_simplified"},{"location":"reference/isort/format/#remove_whitespace","text":"def remove_whitespace ( content : str , line_separator : str = ' \\n ' ) -> str View Source def remove_whitespace ( content : str , line_separator : str = \"\\n\" ) -> str : content = content . replace ( line_separator , \"\" ). replace ( \" \" , \"\" ). replace ( \"\\x0c\" , \"\" ) return content","title":"remove_whitespace"},{"location":"reference/isort/format/#show_unified_diff","text":"def show_unified_diff ( * , file_input : str , file_output : str , file_path : Union [ pathlib . Path , NoneType ] ) View Source def show_unified_diff ( * , file_input : str , file_output : str , file_path : Optional [ Path ] ) : file_name = \"\" if file_path is None else str ( file_path ) file_mtime = str ( datetime . now () if file_path is None else datetime . fromtimestamp ( file_path . stat (). st_mtime ) ) unified_diff_lines = unified_diff ( file_input . splitlines ( keepends = True ), file_output . splitlines ( keepends = True ), fromfile = file_name + \":before\" , tofile = file_name + \":after\" , fromfiledate = file_mtime , tofiledate = str ( datetime . now ()), ) for line in unified_diff_lines : sys . stdout . write ( line )","title":"show_unified_diff"},{"location":"reference/isort/hooks/","text":"Module isort.hooks Defines a git hook to allow pre-commit warnings and errors about import order. usage: exit_code = git_hook(strict=True|False, modify=True|False) View Source \"\"\"Defines a git hook to allow pre-commit warnings and errors about import order. usage: exit_code = git_hook(strict=True|False, modify=True|False) \"\"\" import subprocess # nosec - Needed for hook from pathlib import Path from typing import List from isort import api def get_output ( command : List [ str ]) -> str : \"\"\" Run a command and return raw output :param str command: the command to run :returns: the stdout output of the command \"\"\" result = subprocess . run ( command , stdout = subprocess . PIPE , check = True ) # nosec - trusted input return result . stdout . decode () def get_lines ( command : List [ str ]) -> List [ str ]: \"\"\" Run a command and return lines of output :param str command: the command to run :returns: list of whitespace-stripped lines output by command \"\"\" stdout = get_output ( command ) return [ line . strip () for line in stdout . splitlines ()] def git_hook ( strict : bool = False , modify : bool = False ) -> int : \"\"\" Git pre-commit hook to check staged files for isort errors :param bool strict - if True, return number of errors on exit, causing the hook to fail. If False, return zero so it will just act as a warning. :param bool modify - if True, fix the sources if they are not sorted properly. If False, only report result without modifying anything. :return number of errors if in strict mode, 0 otherwise. \"\"\" # Get list of files modified and staged diff_cmd = [ \"git\" , \"diff-index\" , \"--cached\" , \"--name-only\" , \"--diff-filter=ACMRTUXB HEAD\" ] files_modified = get_lines ( diff_cmd ) errors = 0 for filename in files_modified : if filename . endswith ( \".py\" ): # Get the staged contents of the file staged_cmd = [ \"git\" , \"show\" , \": %s \" % filename ] staged_contents = get_output ( staged_cmd ) if not ( api . sort_file ( filename ) if modify else api . check_code_string ( staged_contents , file_path = Path ( filename )) ): errors += 1 return errors if strict else 0 Functions get_lines def get_lines ( command : List [ str ] ) -> List [ str ] Run a command and return lines of output :param str command: the command to run :returns: list of whitespace-stripped lines output by command View Source def get_lines ( command : List [ str ] ) -> List [ str ] : \"\"\" Run a command and return lines of output :param str command: the command to run :returns: list of whitespace-stripped lines output by command \"\"\" stdout = get_output ( command ) return [ line.strip() for line in stdout.splitlines() ] get_output def get_output ( command : List [ str ] ) -> str Run a command and return raw output :param str command: the command to run :returns: the stdout output of the command View Source def get_output ( command : List [ str ] ) -> str : \"\"\" Run a command and return raw output :param str command: the command to run :returns: the stdout output of the command \"\"\" result = subprocess . run ( command , stdout = subprocess . PIPE , check = True ) # nosec - trusted input return result . stdout . decode () git_hook def git_hook ( strict : bool = False , modify : bool = False ) -> int Git pre-commit hook to check staged files for isort errors :param bool strict - if True, return number of errors on exit, causing the hook to fail. If False, return zero so it will just act as a warning. :param bool modify - if True, fix the sources if they are not sorted properly. If False, only report result without modifying anything. :return number of errors if in strict mode, 0 otherwise. View Source def git_hook ( strict : bool = False , modify : bool = False ) -> int : \"\"\" Git pre-commit hook to check staged files for isort errors :param bool strict - if True, return number of errors on exit, causing the hook to fail. If False, return zero so it will just act as a warning. :param bool modify - if True, fix the sources if they are not sorted properly. If False, only report result without modifying anything. :return number of errors if in strict mode, 0 otherwise. \"\"\" # Get list of files modified and staged diff_cmd = [ \"git\" , \"diff-index\" , \"--cached\" , \"--name-only\" , \"--diff-filter=ACMRTUXB HEAD\" ] files_modified = get_lines ( diff_cmd ) errors = 0 for filename in files_modified : if filename . endswith ( \".py\" ): # Get the staged contents of the file staged_cmd = [ \"git\" , \"show\" , \":%s\" % filename ] staged_contents = get_output ( staged_cmd ) if not ( api . sort_file ( filename ) if modify else api . check_code_string ( staged_contents , file_path = Path ( filename )) ): errors += 1 return errors if strict else 0","title":"Hooks"},{"location":"reference/isort/hooks/#module-isorthooks","text":"Defines a git hook to allow pre-commit warnings and errors about import order. usage: exit_code = git_hook(strict=True|False, modify=True|False) View Source \"\"\"Defines a git hook to allow pre-commit warnings and errors about import order. usage: exit_code = git_hook(strict=True|False, modify=True|False) \"\"\" import subprocess # nosec - Needed for hook from pathlib import Path from typing import List from isort import api def get_output ( command : List [ str ]) -> str : \"\"\" Run a command and return raw output :param str command: the command to run :returns: the stdout output of the command \"\"\" result = subprocess . run ( command , stdout = subprocess . PIPE , check = True ) # nosec - trusted input return result . stdout . decode () def get_lines ( command : List [ str ]) -> List [ str ]: \"\"\" Run a command and return lines of output :param str command: the command to run :returns: list of whitespace-stripped lines output by command \"\"\" stdout = get_output ( command ) return [ line . strip () for line in stdout . splitlines ()] def git_hook ( strict : bool = False , modify : bool = False ) -> int : \"\"\" Git pre-commit hook to check staged files for isort errors :param bool strict - if True, return number of errors on exit, causing the hook to fail. If False, return zero so it will just act as a warning. :param bool modify - if True, fix the sources if they are not sorted properly. If False, only report result without modifying anything. :return number of errors if in strict mode, 0 otherwise. \"\"\" # Get list of files modified and staged diff_cmd = [ \"git\" , \"diff-index\" , \"--cached\" , \"--name-only\" , \"--diff-filter=ACMRTUXB HEAD\" ] files_modified = get_lines ( diff_cmd ) errors = 0 for filename in files_modified : if filename . endswith ( \".py\" ): # Get the staged contents of the file staged_cmd = [ \"git\" , \"show\" , \": %s \" % filename ] staged_contents = get_output ( staged_cmd ) if not ( api . sort_file ( filename ) if modify else api . check_code_string ( staged_contents , file_path = Path ( filename )) ): errors += 1 return errors if strict else 0","title":"Module isort.hooks"},{"location":"reference/isort/hooks/#functions","text":"","title":"Functions"},{"location":"reference/isort/hooks/#get_lines","text":"def get_lines ( command : List [ str ] ) -> List [ str ] Run a command and return lines of output :param str command: the command to run :returns: list of whitespace-stripped lines output by command View Source def get_lines ( command : List [ str ] ) -> List [ str ] : \"\"\" Run a command and return lines of output :param str command: the command to run :returns: list of whitespace-stripped lines output by command \"\"\" stdout = get_output ( command ) return [ line.strip() for line in stdout.splitlines() ]","title":"get_lines"},{"location":"reference/isort/hooks/#get_output","text":"def get_output ( command : List [ str ] ) -> str Run a command and return raw output :param str command: the command to run :returns: the stdout output of the command View Source def get_output ( command : List [ str ] ) -> str : \"\"\" Run a command and return raw output :param str command: the command to run :returns: the stdout output of the command \"\"\" result = subprocess . run ( command , stdout = subprocess . PIPE , check = True ) # nosec - trusted input return result . stdout . decode ()","title":"get_output"},{"location":"reference/isort/hooks/#git_hook","text":"def git_hook ( strict : bool = False , modify : bool = False ) -> int Git pre-commit hook to check staged files for isort errors :param bool strict - if True, return number of errors on exit, causing the hook to fail. If False, return zero so it will just act as a warning. :param bool modify - if True, fix the sources if they are not sorted properly. If False, only report result without modifying anything. :return number of errors if in strict mode, 0 otherwise. View Source def git_hook ( strict : bool = False , modify : bool = False ) -> int : \"\"\" Git pre-commit hook to check staged files for isort errors :param bool strict - if True, return number of errors on exit, causing the hook to fail. If False, return zero so it will just act as a warning. :param bool modify - if True, fix the sources if they are not sorted properly. If False, only report result without modifying anything. :return number of errors if in strict mode, 0 otherwise. \"\"\" # Get list of files modified and staged diff_cmd = [ \"git\" , \"diff-index\" , \"--cached\" , \"--name-only\" , \"--diff-filter=ACMRTUXB HEAD\" ] files_modified = get_lines ( diff_cmd ) errors = 0 for filename in files_modified : if filename . endswith ( \".py\" ): # Get the staged contents of the file staged_cmd = [ \"git\" , \"show\" , \":%s\" % filename ] staged_contents = get_output ( staged_cmd ) if not ( api . sort_file ( filename ) if modify else api . check_code_string ( staged_contents , file_path = Path ( filename )) ): errors += 1 return errors if strict else 0","title":"git_hook"},{"location":"reference/isort/io/","text":"Module isort.io Defines any IO utilities used by isort View Source \"\"\"Defines any IO utilities used by isort\"\"\" import re import tokenize from contextlib import contextmanager from io import BytesIO , StringIO , TextIOWrapper from pathlib import Path from typing import Iterator , List , NamedTuple , Optional , TextIO , Tuple , Union _ENCODING_PATTERN = re . compile ( br \"^[ \\t\\f]*#.*?coding[:=][ \\t]*([-_.a-zA-Z0-9]+)\" ) class File ( NamedTuple ): stream : TextIO path : Path encoding : str @staticmethod def from_contents ( contents : str , filename : str ) -> \"File\" : encoding , _ = tokenize . detect_encoding ( BytesIO ( contents . encode ( \"utf-8\" )) . readline ) return File ( StringIO ( contents ), path = Path ( filename ) . resolve (), encoding = encoding ) @property def extension ( self ): return self . path . suffix . lstrip ( \".\" ) @staticmethod def _open ( filename ): \"\"\"Open a file in read only mode using the encoding detected by detect_encoding(). \"\"\" buffer = open ( filename , \"rb\" ) try : encoding , _ = tokenize . detect_encoding ( buffer . readline ) buffer . seek ( 0 ) text = TextIOWrapper ( buffer , encoding , line_buffering = True , newline = \"\" ) text . mode = \"r\" # type: ignore return text except Exception : buffer . close () raise @staticmethod @contextmanager def read ( filename : Union [ str , Path ]) -> Iterator [ \"File\" ]: file_path = Path ( filename ) . resolve () stream = None try : stream = File . _open ( file_path ) yield File ( stream = stream , path = file_path , encoding = stream . encoding ) finally : if stream is not None : stream . close () class _EmptyIO ( StringIO ): def write ( self , * args , ** kwargs ): pass Empty = _EmptyIO () Variables Empty Classes File class File ( / , * args , ** kwargs ) File(stream, path, encoding) View Source class File ( NamedTuple ) : stream : TextIO path : Path encoding : str @staticmethod def from_contents ( contents : str , filename : str ) -> \"File\" : encoding , _ = tokenize . detect_encoding ( BytesIO ( contents . encode ( \"utf-8\" )). readline ) return File ( StringIO ( contents ), path = Path ( filename ). resolve (), encoding = encoding ) @property def extension ( self ) : return self . path . suffix . lstrip ( \".\" ) @staticmethod def _open ( filename ) : \"\"\"Open a file in read only mode using the encoding detected by detect_encoding(). \"\"\" buffer = open ( filename , \"rb\" ) try : encoding , _ = tokenize . detect_encoding ( buffer . readline ) buffer . seek ( 0 ) text = TextIOWrapper ( buffer , encoding , line_buffering = True , newline = \"\" ) text . mode = \"r\" # type : ignore return text except Exception : buffer . close () raise @staticmethod @contextmanager def read ( filename : Union [ str, Path ] ) -> Iterator [ \"File\" ] : file_path = Path ( filename ). resolve () stream = None try : stream = File . _open ( file_path ) yield File ( stream = stream , path = file_path , encoding = stream . encoding ) finally : if stream is not None : stream . close () Ancestors (in MRO) builtins.tuple Class variables encoding path stream Static methods from_contents def from_contents ( contents : str , filename : str ) -> 'File' View Source @staticmethod def from_contents ( contents : str , filename : str ) -> \"File\" : encoding , _ = tokenize . detect_encoding ( BytesIO ( contents . encode ( \"utf-8\" )). readline ) return File ( StringIO ( contents ), path = Path ( filename ). resolve (), encoding = encoding ) read def read ( filename : Union [ str , pathlib . Path ] ) -> Iterator [ ForwardRef ( 'File' )] View Source @staticmethod @contextmanager def read ( filename : Union [ str, Path ] ) -> Iterator [ \"File\" ] : file_path = Path ( filename ). resolve () stream = None try : stream = File . _open ( file_path ) yield File ( stream = stream , path = file_path , encoding = stream . encoding ) finally : if stream is not None : stream . close () Instance variables extension Methods count def count ( self , value , / ) Return number of occurrences of value. index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"Io"},{"location":"reference/isort/io/#module-isortio","text":"Defines any IO utilities used by isort View Source \"\"\"Defines any IO utilities used by isort\"\"\" import re import tokenize from contextlib import contextmanager from io import BytesIO , StringIO , TextIOWrapper from pathlib import Path from typing import Iterator , List , NamedTuple , Optional , TextIO , Tuple , Union _ENCODING_PATTERN = re . compile ( br \"^[ \\t\\f]*#.*?coding[:=][ \\t]*([-_.a-zA-Z0-9]+)\" ) class File ( NamedTuple ): stream : TextIO path : Path encoding : str @staticmethod def from_contents ( contents : str , filename : str ) -> \"File\" : encoding , _ = tokenize . detect_encoding ( BytesIO ( contents . encode ( \"utf-8\" )) . readline ) return File ( StringIO ( contents ), path = Path ( filename ) . resolve (), encoding = encoding ) @property def extension ( self ): return self . path . suffix . lstrip ( \".\" ) @staticmethod def _open ( filename ): \"\"\"Open a file in read only mode using the encoding detected by detect_encoding(). \"\"\" buffer = open ( filename , \"rb\" ) try : encoding , _ = tokenize . detect_encoding ( buffer . readline ) buffer . seek ( 0 ) text = TextIOWrapper ( buffer , encoding , line_buffering = True , newline = \"\" ) text . mode = \"r\" # type: ignore return text except Exception : buffer . close () raise @staticmethod @contextmanager def read ( filename : Union [ str , Path ]) -> Iterator [ \"File\" ]: file_path = Path ( filename ) . resolve () stream = None try : stream = File . _open ( file_path ) yield File ( stream = stream , path = file_path , encoding = stream . encoding ) finally : if stream is not None : stream . close () class _EmptyIO ( StringIO ): def write ( self , * args , ** kwargs ): pass Empty = _EmptyIO ()","title":"Module isort.io"},{"location":"reference/isort/io/#variables","text":"Empty","title":"Variables"},{"location":"reference/isort/io/#classes","text":"","title":"Classes"},{"location":"reference/isort/io/#file","text":"class File ( / , * args , ** kwargs ) File(stream, path, encoding) View Source class File ( NamedTuple ) : stream : TextIO path : Path encoding : str @staticmethod def from_contents ( contents : str , filename : str ) -> \"File\" : encoding , _ = tokenize . detect_encoding ( BytesIO ( contents . encode ( \"utf-8\" )). readline ) return File ( StringIO ( contents ), path = Path ( filename ). resolve (), encoding = encoding ) @property def extension ( self ) : return self . path . suffix . lstrip ( \".\" ) @staticmethod def _open ( filename ) : \"\"\"Open a file in read only mode using the encoding detected by detect_encoding(). \"\"\" buffer = open ( filename , \"rb\" ) try : encoding , _ = tokenize . detect_encoding ( buffer . readline ) buffer . seek ( 0 ) text = TextIOWrapper ( buffer , encoding , line_buffering = True , newline = \"\" ) text . mode = \"r\" # type : ignore return text except Exception : buffer . close () raise @staticmethod @contextmanager def read ( filename : Union [ str, Path ] ) -> Iterator [ \"File\" ] : file_path = Path ( filename ). resolve () stream = None try : stream = File . _open ( file_path ) yield File ( stream = stream , path = file_path , encoding = stream . encoding ) finally : if stream is not None : stream . close ()","title":"File"},{"location":"reference/isort/io/#ancestors-in-mro","text":"builtins.tuple","title":"Ancestors (in MRO)"},{"location":"reference/isort/io/#class-variables","text":"encoding path stream","title":"Class variables"},{"location":"reference/isort/io/#static-methods","text":"","title":"Static methods"},{"location":"reference/isort/io/#from_contents","text":"def from_contents ( contents : str , filename : str ) -> 'File' View Source @staticmethod def from_contents ( contents : str , filename : str ) -> \"File\" : encoding , _ = tokenize . detect_encoding ( BytesIO ( contents . encode ( \"utf-8\" )). readline ) return File ( StringIO ( contents ), path = Path ( filename ). resolve (), encoding = encoding )","title":"from_contents"},{"location":"reference/isort/io/#read","text":"def read ( filename : Union [ str , pathlib . Path ] ) -> Iterator [ ForwardRef ( 'File' )] View Source @staticmethod @contextmanager def read ( filename : Union [ str, Path ] ) -> Iterator [ \"File\" ] : file_path = Path ( filename ). resolve () stream = None try : stream = File . _open ( file_path ) yield File ( stream = stream , path = file_path , encoding = stream . encoding ) finally : if stream is not None : stream . close ()","title":"read"},{"location":"reference/isort/io/#instance-variables","text":"extension","title":"Instance variables"},{"location":"reference/isort/io/#methods","text":"","title":"Methods"},{"location":"reference/isort/io/#count","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/isort/io/#index","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/isort/logo/","text":"Module isort.logo _ _ ( _ ) ___ ___ _ __ | | _ | |/ _ / / _ \\ / '__ _/ | | \\ __ \\ / \\ _ \\ /| | | | _ | _ | \\ ___ / \\ ___ / \\ _ / \\ _ / isort your imports , so you don 't have to. VERSION 5.0 . 0 View Source from ._version import __version__ ASCII_ART = rf \"\"\" _ _ (_) ___ ___ _ __| |_ | |/ _/ / _ \\/ '__ _/ | |\\__ \\/\\_\\/| | | |_ |_|\\___/\\___/\\_/ \\_/ isort your imports, so you don't have to. VERSION {__version__} \"\"\" __doc__ = f \"\"\" ```python {ASCII_ART} ``` \"\"\" Variables ASCII_ART","title":"Logo"},{"location":"reference/isort/logo/#module-isortlogo","text":"_ _ ( _ ) ___ ___ _ __ | | _ | |/ _ / / _ \\ / '__ _/ | | \\ __ \\ / \\ _ \\ /| | | | _ | _ | \\ ___ / \\ ___ / \\ _ / \\ _ / isort your imports , so you don 't have to. VERSION 5.0 . 0 View Source from ._version import __version__ ASCII_ART = rf \"\"\" _ _ (_) ___ ___ _ __| |_ | |/ _/ / _ \\/ '__ _/ | |\\__ \\/\\_\\/| | | |_ |_|\\___/\\___/\\_/ \\_/ isort your imports, so you don't have to. VERSION {__version__} \"\"\" __doc__ = f \"\"\" ```python {ASCII_ART} ``` \"\"\"","title":"Module isort.logo"},{"location":"reference/isort/logo/#variables","text":"ASCII_ART","title":"Variables"},{"location":"reference/isort/main/","text":"Module isort.main Tool for sorting imports alphabetically, and automatically separated into sections. View Source \"\"\"Tool for sorting imports alphabetically, and automatically separated into sections.\"\"\" import argparse import functools import json import os import re import stat import sys from io import TextIOWrapper from pathlib import Path from typing import Any , Dict , Iterable , Iterator , List , Optional , Sequence from warnings import warn from . import __version__ , api , sections from .exceptions import FileSkipped from .logo import ASCII_ART from .profiles import profiles from .settings import SUPPORTED_EXTENSIONS , VALID_PY_TARGETS , Config , WrapModes try : from .setuptools_commands import ISortCommand # skipcq: PYL-W0611 except ImportError : pass shebang_re = re . compile ( br \"^#!.*\\bpython[23w]?\\b\" ) QUICK_GUIDE = f \"\"\" {ASCII_ART} Nothing to do: no files or paths have have been passed in! Try one of the following: `isort .` - sort all Python files, starting from the current directory, recursively. `isort . --interactive` - Do the same, but ask before making any changes. `isort . --check --diff` - Check to see if imports are correctly sorted within this project. `isort --help` - In-depth information about isort's available command-line options. Visit https://timothycrosley.github.io/isort/ for complete information about how to use isort. \"\"\" def is_python_file ( path : str ) -> bool : _root , ext = os . path . splitext ( path ) if ext in SUPPORTED_EXTENSIONS : return True if ext in ( \".pex\" ,): return False # Skip editor backup files. if path . endswith ( \"~\" ): return False try : if stat . S_ISFIFO ( os . stat ( path ) . st_mode ): return False except OSError : pass try : with open ( path , \"rb\" ) as fp : line = fp . readline ( 100 ) except OSError : return False else : return bool ( shebang_re . match ( line )) class SortAttempt : def __init__ ( self , incorrectly_sorted : bool , skipped : bool ) -> None : self . incorrectly_sorted = incorrectly_sorted self . skipped = skipped def sort_imports ( file_name : str , config : Config , check : bool = False , ask_to_apply : bool = False , write_to_stdout : bool = False , ** kwargs : Any , ) -> Optional [ SortAttempt ]: try : incorrectly_sorted : bool = False skipped : bool = False if check : try : incorrectly_sorted = not api . check_file ( file_name , config = config , ** kwargs ) except FileSkipped : skipped = True return SortAttempt ( incorrectly_sorted , skipped ) else : try : incorrectly_sorted = not api . sort_file ( file_name , config = config , ask_to_apply = ask_to_apply , write_to_stdout = write_to_stdout , ** kwargs , ) except FileSkipped : skipped = True return SortAttempt ( incorrectly_sorted , skipped ) except ( OSError , ValueError ) as error : warn ( f \"Unable to parse file {file_name} due to {error}\" ) return None def iter_source_code ( paths : Iterable [ str ], config : Config , skipped : List [ str ]) -> Iterator [ str ]: \"\"\"Iterate over all Python source files defined in paths.\"\"\" for path in paths : if os . path . isdir ( path ): for dirpath , dirnames , filenames in os . walk ( path , topdown = True , followlinks = True ): base_path = Path ( dirpath ) for dirname in list ( dirnames ): if config . is_skipped ( base_path / dirname ): skipped . append ( dirname ) dirnames . remove ( dirname ) for filename in filenames : filepath = os . path . join ( dirpath , filename ) if is_python_file ( filepath ): if config . is_skipped ( Path ( filepath )): skipped . append ( filename ) else : yield filepath else : yield path def _build_arg_parser () -> argparse . ArgumentParser : parser = argparse . ArgumentParser ( description = \"Sort Python import definitions alphabetically \" \"within logical sections. Run with no arguments to run \" \"interactively. Run with `-` as the first argument to read from \" \"stdin. Otherwise provide a list of files to sort.\" ) inline_args_group = parser . add_mutually_exclusive_group () parser . add_argument ( \"--src\" , \"--src-path\" , dest = \"src_paths\" , action = \"append\" , help = \"Add an explicitly defined source path \" \"(modules within src paths have their imports automatically catorgorized as first_party).\" , ) parser . add_argument ( \"-a\" , \"--add-import\" , dest = \"add_imports\" , action = \"append\" , help = \"Adds the specified import line to all files, \" \"automatically determining correct placement.\" , ) parser . add_argument ( \"--ac\" , \"--atomic\" , dest = \"atomic\" , action = \"store_true\" , help = \"Ensures the output doesn't save if the resulting file contains syntax errors.\" , ) parser . add_argument ( \"--af\" , \"--force-adds\" , dest = \"force_adds\" , action = \"store_true\" , help = \"Forces import adds even if the original file is empty.\" , ) parser . add_argument ( \"-b\" , \"--builtin\" , dest = \"known_standard_library\" , action = \"append\" , help = \"Force isort to recognize a module as part of Python's standard library.\" , ) parser . add_argument ( \"--extra-builtin\" , dest = \"extra_standard_library\" , action = \"append\" , help = \"Extra modules to be included in the list of ones in Python's standard library.\" , ) parser . add_argument ( \"-c\" , \"--check-only\" , \"--check\" , action = \"store_true\" , dest = \"check\" , help = \"Checks the file for unsorted / unformatted imports and prints them to the \" \"command line without modifying the file.\" , ) parser . add_argument ( \"--ca\" , \"--combine-as\" , dest = \"combine_as_imports\" , action = \"store_true\" , help = \"Combines as imports on the same line.\" , ) parser . add_argument ( \"--cs\" , \"--combine-star\" , dest = \"combine_star\" , action = \"store_true\" , help = \"Ensures that if a star import is present, \" \"nothing else is imported from that namespace.\" , ) parser . add_argument ( \"-d\" , \"--stdout\" , help = \"Force resulting output to stdout, instead of in-place.\" , dest = \"write_to_stdout\" , action = \"store_true\" , ) parser . add_argument ( \"--df\" , \"--diff\" , dest = \"show_diff\" , action = \"store_true\" , help = \"Prints a diff of all the changes isort would make to a file, instead of \" \"changing it in place\" , ) parser . add_argument ( \"--ds\" , \"--no-sections\" , help = \"Put all imports into the same section bucket\" , dest = \"no_sections\" , action = \"store_true\" , ) parser . add_argument ( \"-e\" , \"--balanced\" , dest = \"balanced_wrapping\" , action = \"store_true\" , help = \"Balances wrapping to produce the most consistent line length possible\" , ) parser . add_argument ( \"-f\" , \"--future\" , dest = \"known_future_library\" , action = \"append\" , help = \"Force isort to recognize a module as part of the future compatibility libraries.\" , ) parser . add_argument ( \"--fas\" , \"--force-alphabetical-sort\" , action = \"store_true\" , dest = \"force_alphabetical_sort\" , help = \"Force all imports to be sorted as a single section\" , ) parser . add_argument ( \"--fass\" , \"--force-alphabetical-sort-within-sections\" , action = \"store_true\" , dest = \"force_alphabetical_sort\" , help = \"Force all imports to be sorted alphabetically within a section\" , ) parser . add_argument ( \"--ff\" , \"--from-first\" , dest = \"from_first\" , help = \"Switches the typical ordering preference, \" \"showing from imports first then straight ones.\" , ) parser . add_argument ( \"--fgw\" , \"--force-grid-wrap\" , nargs = \"?\" , const = 2 , type = int , dest = \"force_grid_wrap\" , help = \"Force number of from imports (defaults to 2) to be grid wrapped regardless of line \" \"length\" , ) parser . add_argument ( \"--fss\" , \"--force-sort-within-sections\" , action = \"store_true\" , dest = \"force_sort_within_sections\" , help = \"Force imports to be sorted by module, independent of import_type\" , ) parser . add_argument ( \"-i\" , \"--indent\" , help = 'String to place for indents defaults to \" \" (4 spaces).' , dest = \"indent\" , type = str , ) parser . add_argument ( \"-j\" , \"--jobs\" , help = \"Number of files to process in parallel.\" , dest = \"jobs\" , type = int ) parser . add_argument ( \"-k\" , \"--keep-direct-and-as\" , dest = \"keep_direct_and_as_imports\" , action = \"store_true\" , help = \"Turns off default behavior that removes direct imports when as imports exist.\" , ) parser . add_argument ( \"--lai\" , \"--lines-after-imports\" , dest = \"lines_after_imports\" , type = int ) parser . add_argument ( \"--lbt\" , \"--lines-between-types\" , dest = \"lines_between_types\" , type = int ) parser . add_argument ( \"--le\" , \"--line-ending\" , dest = \"line_ending\" , help = \"Forces line endings to the specified value. \" \"If not set, values will be guessed per-file.\" , ) parser . add_argument ( \"--ls\" , \"--length-sort\" , help = \"Sort imports by their string length.\" , dest = \"length_sort\" , action = \"store_true\" , ) parser . add_argument ( \"-m\" , \"--multi-line\" , dest = \"multi_line_output\" , choices = list ( WrapModes . __members__ . keys ()) + [ str ( mode . value ) for mode in WrapModes . __members__ . values ()], type = str , help = \"Multi line output (0-grid, 1-vertical, 2-hanging, 3-vert-hanging, 4-vert-grid, \" \"5-vert-grid-grouped, 6-vert-grid-grouped-no-comma).\" , ) parser . add_argument ( \"-n\" , \"--ensure-newline-before-comments\" , dest = \"ensure_newline_before_comments\" , action = \"store_true\" , help = \"Inserts a blank line before a comment following an import.\" , ) inline_args_group . add_argument ( \"--nis\" , \"--no-inline-sort\" , dest = \"no_inline_sort\" , action = \"store_true\" , help = \"Leaves `from` imports with multiple imports 'as-is' \" \"(e.g. `from foo import a, c ,b`).\" , ) parser . add_argument ( \"--nlb\" , \"--no-lines-before\" , help = \"Sections which should not be split with previous by empty lines\" , dest = \"no_lines_before\" , action = \"append\" , ) parser . add_argument ( \"-o\" , \"--thirdparty\" , dest = \"known_third_party\" , action = \"append\" , help = \"Force isort to recognize a module as being part of a third party library.\" , ) parser . add_argument ( \"--ot\" , \"--order-by-type\" , dest = \"order_by_type\" , action = \"store_true\" , help = \"Order imports by type in addition to alphabetically\" , ) parser . add_argument ( \"--dt\" , \"--dont-order-by-type\" , dest = \"dont_order_by_type\" , action = \"store_true\" , help = \"Don't order imports by type in addition to alphabetically\" , ) parser . add_argument ( \"-p\" , \"--project\" , dest = \"known_first_party\" , action = \"append\" , help = \"Force isort to recognize a module as being part of the current python project.\" , ) parser . add_argument ( \"-q\" , \"--quiet\" , action = \"store_true\" , dest = \"quiet\" , help = \"Shows extra quiet output, only errors are outputted.\" , ) parser . add_argument ( \"--rm\" , \"--remove-import\" , dest = \"remove_imports\" , action = \"append\" , help = \"Removes the specified import from all files.\" , ) parser . add_argument ( \"--rr\" , \"--reverse-relative\" , dest = \"reverse_relative\" , action = \"store_true\" , help = \"Reverse order of relative imports.\" , ) parser . add_argument ( \"-s\" , \"--skip\" , help = \"Files that sort imports should skip over. If you want to skip multiple \" \"files you should specify twice: --skip file1 --skip file2.\" , dest = \"skip\" , action = \"append\" , ) parser . add_argument ( \"--sd\" , \"--section-default\" , dest = \"default_section\" , help = \"Sets the default section for imports (by default FIRSTPARTY) options: \" + str ( sections . DEFAULT ), ) parser . add_argument ( \"--sg\" , \"--skip-glob\" , help = \"Files that sort imports should skip over.\" , dest = \"skip_glob\" , action = \"append\" , ) inline_args_group . add_argument ( \"--sl\" , \"--force-single-line-imports\" , dest = \"force_single_line\" , action = \"store_true\" , help = \"Forces all from imports to appear on their own line\" , ) parser . add_argument ( \"--nsl\" , \"--single-line-exclusions\" , help = \"One or more modules to exclude from the single line rule.\" , dest = \"single_line_exclusions\" , action = \"append\" , ) parser . add_argument ( \"--sp\" , \"--settings-path\" , \"--settings-file\" , \"--settings\" , dest = \"settings_path\" , help = \"Explicitly set the settings path or file instead of auto determining \" \"based on file location.\" , ) parser . add_argument ( \"-t\" , \"--top\" , help = \"Force specific imports to the top of their appropriate section.\" , dest = \"force_to_top\" , action = \"append\" , ) parser . add_argument ( \"--tc\" , \"--trailing-comma\" , dest = \"include_trailing_comma\" , action = \"store_true\" , help = \"Includes a trailing comma on multi line imports that include parentheses.\" , ) parser . add_argument ( \"--up\" , \"--use-parentheses\" , dest = \"use_parentheses\" , action = \"store_true\" , help = \"Use parenthesis for line continuation on length limit instead of slashes.\" , ) parser . add_argument ( \"-V\" , \"--version\" , action = \"store_true\" , dest = \"show_version\" , help = \"Displays the currently installed version of isort.\" , ) parser . add_argument ( \"-v\" , \"--verbose\" , action = \"store_true\" , dest = \"verbose\" , help = \"Shows verbose output, such as when files are skipped or when a check is successful.\" , ) parser . add_argument ( \"--virtual-env\" , dest = \"virtual_env\" , help = \"Virtual environment to use for determining whether a package is third-party\" , ) parser . add_argument ( \"--conda-env\" , dest = \"conda_env\" , help = \"Conda environment to use for determining whether a package is third-party\" , ) parser . add_argument ( \"--vn\" , \"--version-number\" , action = \"version\" , version = __version__ , help = \"Returns just the current version number without the logo\" , ) parser . add_argument ( \"-l\" , \"-w\" , \"--line-length\" , \"--line-width\" , help = \"The max length of an import line (used for wrapping long imports).\" , dest = \"line_length\" , type = int , ) parser . add_argument ( \"--wl\" , \"--wrap-length\" , dest = \"wrap_length\" , type = int , help = \"Specifies how long lines that are wrapped should be, if not set line_length is used.\" \" \\n NOTE: wrap_length must be LOWER than or equal to line_length.\" , ) parser . add_argument ( \"--ws\" , \"--ignore-whitespace\" , action = \"store_true\" , dest = \"ignore_whitespace\" , help = \"Tells isort to ignore whitespace differences when --check-only is being used.\" , ) parser . add_argument ( \"--case-sensitive\" , dest = \"case_sensitive\" , action = \"store_true\" , help = \"Tells isort to include casing when sorting module names\" , ) parser . add_argument ( \"--filter-files\" , dest = \"filter_files\" , action = \"store_true\" , help = \"Tells isort to filter files even when they are explicitly passed in as \" \"part of the command\" , ) parser . add_argument ( \"files\" , nargs = \"*\" , help = \"One or more Python source files that need their imports sorted.\" ) parser . add_argument ( \"--py\" , \"--python-version\" , action = \"store\" , dest = \"py_version\" , choices = tuple ( VALID_PY_TARGETS ) + ( \"auto\" ,), help = \"Tells isort to set the known standard library based on the the specified Python \" \"version. Default is to assume any Python 3 version could be the target, and use a union \" \"off all stdlib modules across versions. If auto is specified, the version of the \" \"interpreter used to run isort \" f \"(currently: {sys.version_info.major}{sys.version_info.minor}) will be used.\" , ) parser . add_argument ( \"--profile\" , dest = \"profile\" , choices = list ( profiles . keys ()), type = str , help = \"Base profile type to use for configuration.\" , ) parser . add_argument ( \"--interactive\" , dest = \"ask_to_apply\" , action = \"store_true\" , help = \"Tells isort to apply changes interactively.\" , ) parser . add_argument ( \"--old-finders\" , \"--magic-placement\" , dest = \"old_finders\" , action = \"store_true\" , help = \"Use the old deprecated finder logic that relies on environment introspection magic.\" , ) parser . add_argument ( \"--show-config\" , dest = \"show_config\" , action = \"store_true\" , help = \"See isort's determined config, as well as sources of config options.\" , ) return parser def parse_args ( argv : Optional [ Sequence [ str ]] = None ) -> Dict [ str , Any ]: parser = _build_arg_parser () arguments = { key : value for key , value in vars ( parser . parse_args ( argv )) . items () if value } if \"dont_order_by_type\" in arguments : arguments [ \"order_by_type\" ] = False multi_line_output = arguments . get ( \"multi_line_output\" , None ) if multi_line_output : if multi_line_output . isdigit (): arguments [ \"multi_line_output\" ] = WrapModes ( int ( multi_line_output )) else : arguments [ \"multi_line_output\" ] = WrapModes [ multi_line_output ] return arguments def _preconvert ( item ): \"\"\"Preconverts objects from native types into JSONifyiable types\"\"\" if isinstance ( item , ( set , frozenset )): return list ( item ) elif isinstance ( item , WrapModes ): return item . name elif isinstance ( item , Path ): return str ( item ) else : raise TypeError ( \"Unserializable object {} of type {}\" . format ( item , type ( item ))) def main ( argv : Optional [ Sequence [ str ]] = None , stdin : Optional [ TextIOWrapper ] = None ) -> None : arguments = parse_args ( argv ) if arguments . get ( \"show_version\" ): print ( ASCII_ART ) return show_config : bool = arguments . pop ( \"show_config\" , False ) if \"settings_path\" in arguments : if os . path . isfile ( arguments [ \"settings_path\" ]): arguments [ \"settings_file\" ] = os . path . abspath ( arguments [ \"settings_path\" ]) arguments [ \"settings_path\" ] = os . path . dirname ( arguments [ \"settings_file\" ]) elif not os . path . isdir ( arguments [ \"settings_path\" ]): warn ( f \"settings_path dir does not exist: {arguments['settings_path']}\" ) else : arguments [ \"settings_path\" ] = os . path . abspath ( arguments [ \"settings_path\" ]) if \"virtual_env\" in arguments : venv = arguments [ \"virtual_env\" ] arguments [ \"virtual_env\" ] = os . path . abspath ( venv ) if not os . path . isdir ( arguments [ \"virtual_env\" ]): warn ( f \"virtual_env dir does not exist: {arguments['virtual_env']}\" ) file_names = arguments . pop ( \"files\" , []) if not file_names and not show_config : print ( QUICK_GUIDE ) return elif file_names == [ \"-\" ] and not show_config : api . sort_stream ( input_stream = sys . stdin if stdin is None else stdin , output_stream = sys . stdout , ** arguments , ) return if \"settings_path\" not in arguments : arguments [ \"settings_path\" ] = ( os . path . abspath ( file_names [ 0 ] if file_names else \".\" ) or os . getcwd () ) if not os . path . isdir ( arguments [ \"settings_path\" ]): arguments [ \"settings_path\" ] = os . path . dirname ( arguments [ \"settings_path\" ]) config_dict = arguments . copy () ask_to_apply = config_dict . pop ( \"ask_to_apply\" , False ) jobs = config_dict . pop ( \"jobs\" , ()) filter_files = config_dict . pop ( \"filter_files\" , False ) check = config_dict . pop ( \"check\" , False ) show_diff = config_dict . pop ( \"show_diff\" , False ) write_to_stdout = config_dict . pop ( \"write_to_stdout\" , False ) if \"src_paths\" in config_dict : config_dict [ \"src_paths\" ] = { Path ( src_path ) . resolve () for src_path in config_dict . get ( \"src_paths\" , ()) } config = Config ( ** config_dict ) if show_config : print ( json . dumps ( config . __dict__ , indent = 4 , separators = ( \",\" , \": \" ), default = _preconvert )) return wrong_sorted_files = False skipped : List [ str ] = [] if filter_files : filtered_files = [] for file_name in file_names : if config . is_skipped ( Path ( file_name )): skipped . append ( file_name ) else : filtered_files . append ( file_name ) file_names = filtered_files file_names = iter_source_code ( file_names , config , skipped ) num_skipped = 0 if config . verbose : print ( ASCII_ART ) if jobs : import multiprocessing executor = multiprocessing . Pool ( jobs ) attempt_iterator = executor . imap ( functools . partial ( sort_imports , config = config , check = check , ask_to_apply = ask_to_apply , write_to_stdout = write_to_stdout , ), file_names , ) else : # https://github.com/python/typeshed/pull/2814 attempt_iterator = ( sort_imports ( # type: ignore file_name , config = config , check = check , ask_to_apply = ask_to_apply , show_diff = show_diff , write_to_stdout = write_to_stdout , ) for file_name in file_names ) for sort_attempt in attempt_iterator : if not sort_attempt : continue # pragma: no cover - shouldn't happen, satisfies type constraint incorrectly_sorted = sort_attempt . incorrectly_sorted if arguments . get ( \"check\" , False ) and incorrectly_sorted : wrong_sorted_files = True if sort_attempt . skipped : num_skipped += 1 # pragma: no cover - shouldn't happen, due to skip in iter_source_code if wrong_sorted_files : sys . exit ( 1 ) num_skipped += len ( skipped ) if num_skipped and not arguments . get ( \"quiet\" , False ): if config . verbose : for was_skipped in skipped : warn ( f \"{was_skipped} was skipped as it's listed in 'skip' setting\" \" or matches a glob in 'skip_glob' setting\" ) print ( f \"Skipped {num_skipped} files\" ) if __name__ == \"__main__\" : main () Variables ASCII_ART QUICK_GUIDE SUPPORTED_EXTENSIONS VALID_PY_TARGETS profiles shebang_re Functions is_python_file def is_python_file ( path : str ) -> bool View Source def is_python_file ( path : str ) -> bool : _root , ext = os . path . splitext ( path ) if ext in SUPPORTED_EXTENSIONS : return True if ext in ( \".pex\" ,): return False # Skip editor backup files . if path . endswith ( \"~\" ): return False try : if stat . S_ISFIFO ( os . stat ( path ). st_mode ): return False except OSError : pass try : with open ( path , \"rb\" ) as fp : line = fp . readline ( 100 ) except OSError : return False else : return bool ( shebang_re . match ( line )) iter_source_code def iter_source_code ( paths : Iterable [ str ], config : isort . settings . Config , skipped : List [ str ] ) -> Iterator [ str ] Iterate over all Python source files defined in paths. View Source def iter_source_code ( paths : Iterable [ str ] , config : Config , skipped : List [ str ] ) -> Iterator [ str ] : \"\"\"Iterate over all Python source files defined in paths.\"\"\" for path in paths : if os . path . isdir ( path ) : for dirpath , dirnames , filenames in os . walk ( path , topdown = True , followlinks = True ) : base_path = Path ( dirpath ) for dirname in list ( dirnames ) : if config . is_skipped ( base_path / dirname ) : skipped . append ( dirname ) dirnames . remove ( dirname ) for filename in filenames : filepath = os . path . join ( dirpath , filename ) if is_python_file ( filepath ) : if config . is_skipped ( Path ( filepath )) : skipped . append ( filename ) else : yield filepath else : yield path main def main ( argv : Union [ Sequence [ str ], NoneType ] = None , stdin : Union [ _io . TextIOWrapper , NoneType ] = None ) -> None View Source def main ( argv : Optional [ Sequence[str ] ] = None , stdin : Optional [ TextIOWrapper ] = None ) -> None : arguments = parse_args ( argv ) if arguments . get ( \"show_version\" ) : print ( ASCII_ART ) return show_config : bool = arguments . pop ( \"show_config\" , False ) if \"settings_path\" in arguments : if os . path . isfile ( arguments [ \"settings_path\" ] ) : arguments [ \"settings_file\" ] = os . path . abspath ( arguments [ \"settings_path\" ] ) arguments [ \"settings_path\" ] = os . path . dirname ( arguments [ \"settings_file\" ] ) elif not os . path . isdir ( arguments [ \"settings_path\" ] ) : warn ( f \"settings_path dir does not exist: {arguments['settings_path']}\" ) else : arguments [ \"settings_path\" ] = os . path . abspath ( arguments [ \"settings_path\" ] ) if \"virtual_env\" in arguments : venv = arguments [ \"virtual_env\" ] arguments [ \"virtual_env\" ] = os . path . abspath ( venv ) if not os . path . isdir ( arguments [ \"virtual_env\" ] ) : warn ( f \"virtual_env dir does not exist: {arguments['virtual_env']}\" ) file_names = arguments . pop ( \"files\" , [] ) if not file_names and not show_config : print ( QUICK_GUIDE ) return elif file_names == [ \"-\" ] and not show_config : api . sort_stream ( input_stream = sys . stdin if stdin is None else stdin , output_stream = sys . stdout , ** arguments , ) return if \"settings_path\" not in arguments : arguments [ \"settings_path\" ] = ( os . path . abspath ( file_names [ 0 ] if file_names else \".\" ) or os . getcwd () ) if not os . path . isdir ( arguments [ \"settings_path\" ] ) : arguments [ \"settings_path\" ] = os . path . dirname ( arguments [ \"settings_path\" ] ) config_dict = arguments . copy () ask_to_apply = config_dict . pop ( \"ask_to_apply\" , False ) jobs = config_dict . pop ( \"jobs\" , ()) filter_files = config_dict . pop ( \"filter_files\" , False ) check = config_dict . pop ( \"check\" , False ) show_diff = config_dict . pop ( \"show_diff\" , False ) write_to_stdout = config_dict . pop ( \"write_to_stdout\" , False ) if \"src_paths\" in config_dict : config_dict [ \"src_paths\" ] = { Path ( src_path ). resolve () for src_path in config_dict . get ( \"src_paths\" , ()) } config = Config ( ** config_dict ) if show_config : print ( json . dumps ( config . __dict__ , indent = 4 , separators = ( \",\" , \": \" ), default = _preconvert )) return wrong_sorted_files = False skipped : List [ str ] = [] if filter_files : filtered_files = [] for file_name in file_names : if config . is_skipped ( Path ( file_name )) : skipped . append ( file_name ) else : filtered_files . append ( file_name ) file_names = filtered_files file_names = iter_source_code ( file_names , config , skipped ) num_skipped = 0 if config . verbose : print ( ASCII_ART ) if jobs : import multiprocessing executor = multiprocessing . Pool ( jobs ) attempt_iterator = executor . imap ( functools . partial ( sort_imports , config = config , check = check , ask_to_apply = ask_to_apply , write_to_stdout = write_to_stdout , ), file_names , ) else : # https : // github . com / python / typeshed / pull / 2814 attempt_iterator = ( sort_imports ( # type : ignore file_name , config = config , check = check , ask_to_apply = ask_to_apply , show_diff = show_diff , write_to_stdout = write_to_stdout , ) for file_name in file_names ) for sort_attempt in attempt_iterator : if not sort_attempt : continue # pragma : no cover - shouldn 't happen, satisfies type constraint incorrectly_sorted = sort_attempt.incorrectly_sorted if arguments.get(\"check\", False) and incorrectly_sorted: wrong_sorted_files = True if sort_attempt.skipped: num_skipped += 1 # pragma: no cover - shouldn' t happen , due to skip in iter_source_code if wrong_sorted_files : sys . exit ( 1 ) num_skipped += len ( skipped ) if num_skipped and not arguments . get ( \"quiet\" , False ) : if config . verbose : for was_skipped in skipped : warn ( f \"{was_skipped} was skipped as it's listed in 'skip' setting\" \" or matches a glob in 'skip_glob' setting\" ) print ( f \"Skipped {num_skipped} files\" ) parse_args def parse_args ( argv : Union [ Sequence [ str ], NoneType ] = None ) -> Dict [ str , Any ] View Source def parse_args ( argv : Optional [ Sequence[str ] ] = None ) -> Dict [ str, Any ] : parser = _build_arg_parser () arguments = { key : value for key , value in vars ( parser . parse_args ( argv )). items () if value } if \"dont_order_by_type\" in arguments : arguments [ \"order_by_type\" ] = False multi_line_output = arguments . get ( \"multi_line_output\" , None ) if multi_line_output : if multi_line_output . isdigit () : arguments [ \"multi_line_output\" ] = WrapModes ( int ( multi_line_output )) else : arguments [ \"multi_line_output\" ] = WrapModes [ multi_line_output ] return arguments sort_imports def sort_imports ( file_name : str , config : isort . settings . Config , check : bool = False , ask_to_apply : bool = False , write_to_stdout : bool = False , ** kwargs : Any ) -> Union [ isort . main . SortAttempt , NoneType ] View Source def sort_imports ( file_name : str , config : Config , check : bool = False , ask_to_apply : bool = False , write_to_stdout : bool = False , ** kwargs : Any , ) -> Optional [ SortAttempt ] : try : incorrectly_sorted : bool = False skipped : bool = False if check : try : incorrectly_sorted = not api . check_file ( file_name , config = config , ** kwargs ) except FileSkipped : skipped = True return SortAttempt ( incorrectly_sorted , skipped ) else : try : incorrectly_sorted = not api . sort_file ( file_name , config = config , ask_to_apply = ask_to_apply , write_to_stdout = write_to_stdout , ** kwargs , ) except FileSkipped : skipped = True return SortAttempt ( incorrectly_sorted , skipped ) except ( OSError , ValueError ) as error : warn ( f \"Unable to parse file {file_name} due to {error}\" ) return None Classes SortAttempt class SortAttempt ( incorrectly_sorted : bool , skipped : bool ) View Source class SortAttempt: def __init__ ( self , incorrectly_sorted: bool , skipped: bool ) -> None: self . incorrectly_sorted = incorrectly_sorted self . skipped = skipped","title":"Main"},{"location":"reference/isort/main/#module-isortmain","text":"Tool for sorting imports alphabetically, and automatically separated into sections. View Source \"\"\"Tool for sorting imports alphabetically, and automatically separated into sections.\"\"\" import argparse import functools import json import os import re import stat import sys from io import TextIOWrapper from pathlib import Path from typing import Any , Dict , Iterable , Iterator , List , Optional , Sequence from warnings import warn from . import __version__ , api , sections from .exceptions import FileSkipped from .logo import ASCII_ART from .profiles import profiles from .settings import SUPPORTED_EXTENSIONS , VALID_PY_TARGETS , Config , WrapModes try : from .setuptools_commands import ISortCommand # skipcq: PYL-W0611 except ImportError : pass shebang_re = re . compile ( br \"^#!.*\\bpython[23w]?\\b\" ) QUICK_GUIDE = f \"\"\" {ASCII_ART} Nothing to do: no files or paths have have been passed in! Try one of the following: `isort .` - sort all Python files, starting from the current directory, recursively. `isort . --interactive` - Do the same, but ask before making any changes. `isort . --check --diff` - Check to see if imports are correctly sorted within this project. `isort --help` - In-depth information about isort's available command-line options. Visit https://timothycrosley.github.io/isort/ for complete information about how to use isort. \"\"\" def is_python_file ( path : str ) -> bool : _root , ext = os . path . splitext ( path ) if ext in SUPPORTED_EXTENSIONS : return True if ext in ( \".pex\" ,): return False # Skip editor backup files. if path . endswith ( \"~\" ): return False try : if stat . S_ISFIFO ( os . stat ( path ) . st_mode ): return False except OSError : pass try : with open ( path , \"rb\" ) as fp : line = fp . readline ( 100 ) except OSError : return False else : return bool ( shebang_re . match ( line )) class SortAttempt : def __init__ ( self , incorrectly_sorted : bool , skipped : bool ) -> None : self . incorrectly_sorted = incorrectly_sorted self . skipped = skipped def sort_imports ( file_name : str , config : Config , check : bool = False , ask_to_apply : bool = False , write_to_stdout : bool = False , ** kwargs : Any , ) -> Optional [ SortAttempt ]: try : incorrectly_sorted : bool = False skipped : bool = False if check : try : incorrectly_sorted = not api . check_file ( file_name , config = config , ** kwargs ) except FileSkipped : skipped = True return SortAttempt ( incorrectly_sorted , skipped ) else : try : incorrectly_sorted = not api . sort_file ( file_name , config = config , ask_to_apply = ask_to_apply , write_to_stdout = write_to_stdout , ** kwargs , ) except FileSkipped : skipped = True return SortAttempt ( incorrectly_sorted , skipped ) except ( OSError , ValueError ) as error : warn ( f \"Unable to parse file {file_name} due to {error}\" ) return None def iter_source_code ( paths : Iterable [ str ], config : Config , skipped : List [ str ]) -> Iterator [ str ]: \"\"\"Iterate over all Python source files defined in paths.\"\"\" for path in paths : if os . path . isdir ( path ): for dirpath , dirnames , filenames in os . walk ( path , topdown = True , followlinks = True ): base_path = Path ( dirpath ) for dirname in list ( dirnames ): if config . is_skipped ( base_path / dirname ): skipped . append ( dirname ) dirnames . remove ( dirname ) for filename in filenames : filepath = os . path . join ( dirpath , filename ) if is_python_file ( filepath ): if config . is_skipped ( Path ( filepath )): skipped . append ( filename ) else : yield filepath else : yield path def _build_arg_parser () -> argparse . ArgumentParser : parser = argparse . ArgumentParser ( description = \"Sort Python import definitions alphabetically \" \"within logical sections. Run with no arguments to run \" \"interactively. Run with `-` as the first argument to read from \" \"stdin. Otherwise provide a list of files to sort.\" ) inline_args_group = parser . add_mutually_exclusive_group () parser . add_argument ( \"--src\" , \"--src-path\" , dest = \"src_paths\" , action = \"append\" , help = \"Add an explicitly defined source path \" \"(modules within src paths have their imports automatically catorgorized as first_party).\" , ) parser . add_argument ( \"-a\" , \"--add-import\" , dest = \"add_imports\" , action = \"append\" , help = \"Adds the specified import line to all files, \" \"automatically determining correct placement.\" , ) parser . add_argument ( \"--ac\" , \"--atomic\" , dest = \"atomic\" , action = \"store_true\" , help = \"Ensures the output doesn't save if the resulting file contains syntax errors.\" , ) parser . add_argument ( \"--af\" , \"--force-adds\" , dest = \"force_adds\" , action = \"store_true\" , help = \"Forces import adds even if the original file is empty.\" , ) parser . add_argument ( \"-b\" , \"--builtin\" , dest = \"known_standard_library\" , action = \"append\" , help = \"Force isort to recognize a module as part of Python's standard library.\" , ) parser . add_argument ( \"--extra-builtin\" , dest = \"extra_standard_library\" , action = \"append\" , help = \"Extra modules to be included in the list of ones in Python's standard library.\" , ) parser . add_argument ( \"-c\" , \"--check-only\" , \"--check\" , action = \"store_true\" , dest = \"check\" , help = \"Checks the file for unsorted / unformatted imports and prints them to the \" \"command line without modifying the file.\" , ) parser . add_argument ( \"--ca\" , \"--combine-as\" , dest = \"combine_as_imports\" , action = \"store_true\" , help = \"Combines as imports on the same line.\" , ) parser . add_argument ( \"--cs\" , \"--combine-star\" , dest = \"combine_star\" , action = \"store_true\" , help = \"Ensures that if a star import is present, \" \"nothing else is imported from that namespace.\" , ) parser . add_argument ( \"-d\" , \"--stdout\" , help = \"Force resulting output to stdout, instead of in-place.\" , dest = \"write_to_stdout\" , action = \"store_true\" , ) parser . add_argument ( \"--df\" , \"--diff\" , dest = \"show_diff\" , action = \"store_true\" , help = \"Prints a diff of all the changes isort would make to a file, instead of \" \"changing it in place\" , ) parser . add_argument ( \"--ds\" , \"--no-sections\" , help = \"Put all imports into the same section bucket\" , dest = \"no_sections\" , action = \"store_true\" , ) parser . add_argument ( \"-e\" , \"--balanced\" , dest = \"balanced_wrapping\" , action = \"store_true\" , help = \"Balances wrapping to produce the most consistent line length possible\" , ) parser . add_argument ( \"-f\" , \"--future\" , dest = \"known_future_library\" , action = \"append\" , help = \"Force isort to recognize a module as part of the future compatibility libraries.\" , ) parser . add_argument ( \"--fas\" , \"--force-alphabetical-sort\" , action = \"store_true\" , dest = \"force_alphabetical_sort\" , help = \"Force all imports to be sorted as a single section\" , ) parser . add_argument ( \"--fass\" , \"--force-alphabetical-sort-within-sections\" , action = \"store_true\" , dest = \"force_alphabetical_sort\" , help = \"Force all imports to be sorted alphabetically within a section\" , ) parser . add_argument ( \"--ff\" , \"--from-first\" , dest = \"from_first\" , help = \"Switches the typical ordering preference, \" \"showing from imports first then straight ones.\" , ) parser . add_argument ( \"--fgw\" , \"--force-grid-wrap\" , nargs = \"?\" , const = 2 , type = int , dest = \"force_grid_wrap\" , help = \"Force number of from imports (defaults to 2) to be grid wrapped regardless of line \" \"length\" , ) parser . add_argument ( \"--fss\" , \"--force-sort-within-sections\" , action = \"store_true\" , dest = \"force_sort_within_sections\" , help = \"Force imports to be sorted by module, independent of import_type\" , ) parser . add_argument ( \"-i\" , \"--indent\" , help = 'String to place for indents defaults to \" \" (4 spaces).' , dest = \"indent\" , type = str , ) parser . add_argument ( \"-j\" , \"--jobs\" , help = \"Number of files to process in parallel.\" , dest = \"jobs\" , type = int ) parser . add_argument ( \"-k\" , \"--keep-direct-and-as\" , dest = \"keep_direct_and_as_imports\" , action = \"store_true\" , help = \"Turns off default behavior that removes direct imports when as imports exist.\" , ) parser . add_argument ( \"--lai\" , \"--lines-after-imports\" , dest = \"lines_after_imports\" , type = int ) parser . add_argument ( \"--lbt\" , \"--lines-between-types\" , dest = \"lines_between_types\" , type = int ) parser . add_argument ( \"--le\" , \"--line-ending\" , dest = \"line_ending\" , help = \"Forces line endings to the specified value. \" \"If not set, values will be guessed per-file.\" , ) parser . add_argument ( \"--ls\" , \"--length-sort\" , help = \"Sort imports by their string length.\" , dest = \"length_sort\" , action = \"store_true\" , ) parser . add_argument ( \"-m\" , \"--multi-line\" , dest = \"multi_line_output\" , choices = list ( WrapModes . __members__ . keys ()) + [ str ( mode . value ) for mode in WrapModes . __members__ . values ()], type = str , help = \"Multi line output (0-grid, 1-vertical, 2-hanging, 3-vert-hanging, 4-vert-grid, \" \"5-vert-grid-grouped, 6-vert-grid-grouped-no-comma).\" , ) parser . add_argument ( \"-n\" , \"--ensure-newline-before-comments\" , dest = \"ensure_newline_before_comments\" , action = \"store_true\" , help = \"Inserts a blank line before a comment following an import.\" , ) inline_args_group . add_argument ( \"--nis\" , \"--no-inline-sort\" , dest = \"no_inline_sort\" , action = \"store_true\" , help = \"Leaves `from` imports with multiple imports 'as-is' \" \"(e.g. `from foo import a, c ,b`).\" , ) parser . add_argument ( \"--nlb\" , \"--no-lines-before\" , help = \"Sections which should not be split with previous by empty lines\" , dest = \"no_lines_before\" , action = \"append\" , ) parser . add_argument ( \"-o\" , \"--thirdparty\" , dest = \"known_third_party\" , action = \"append\" , help = \"Force isort to recognize a module as being part of a third party library.\" , ) parser . add_argument ( \"--ot\" , \"--order-by-type\" , dest = \"order_by_type\" , action = \"store_true\" , help = \"Order imports by type in addition to alphabetically\" , ) parser . add_argument ( \"--dt\" , \"--dont-order-by-type\" , dest = \"dont_order_by_type\" , action = \"store_true\" , help = \"Don't order imports by type in addition to alphabetically\" , ) parser . add_argument ( \"-p\" , \"--project\" , dest = \"known_first_party\" , action = \"append\" , help = \"Force isort to recognize a module as being part of the current python project.\" , ) parser . add_argument ( \"-q\" , \"--quiet\" , action = \"store_true\" , dest = \"quiet\" , help = \"Shows extra quiet output, only errors are outputted.\" , ) parser . add_argument ( \"--rm\" , \"--remove-import\" , dest = \"remove_imports\" , action = \"append\" , help = \"Removes the specified import from all files.\" , ) parser . add_argument ( \"--rr\" , \"--reverse-relative\" , dest = \"reverse_relative\" , action = \"store_true\" , help = \"Reverse order of relative imports.\" , ) parser . add_argument ( \"-s\" , \"--skip\" , help = \"Files that sort imports should skip over. If you want to skip multiple \" \"files you should specify twice: --skip file1 --skip file2.\" , dest = \"skip\" , action = \"append\" , ) parser . add_argument ( \"--sd\" , \"--section-default\" , dest = \"default_section\" , help = \"Sets the default section for imports (by default FIRSTPARTY) options: \" + str ( sections . DEFAULT ), ) parser . add_argument ( \"--sg\" , \"--skip-glob\" , help = \"Files that sort imports should skip over.\" , dest = \"skip_glob\" , action = \"append\" , ) inline_args_group . add_argument ( \"--sl\" , \"--force-single-line-imports\" , dest = \"force_single_line\" , action = \"store_true\" , help = \"Forces all from imports to appear on their own line\" , ) parser . add_argument ( \"--nsl\" , \"--single-line-exclusions\" , help = \"One or more modules to exclude from the single line rule.\" , dest = \"single_line_exclusions\" , action = \"append\" , ) parser . add_argument ( \"--sp\" , \"--settings-path\" , \"--settings-file\" , \"--settings\" , dest = \"settings_path\" , help = \"Explicitly set the settings path or file instead of auto determining \" \"based on file location.\" , ) parser . add_argument ( \"-t\" , \"--top\" , help = \"Force specific imports to the top of their appropriate section.\" , dest = \"force_to_top\" , action = \"append\" , ) parser . add_argument ( \"--tc\" , \"--trailing-comma\" , dest = \"include_trailing_comma\" , action = \"store_true\" , help = \"Includes a trailing comma on multi line imports that include parentheses.\" , ) parser . add_argument ( \"--up\" , \"--use-parentheses\" , dest = \"use_parentheses\" , action = \"store_true\" , help = \"Use parenthesis for line continuation on length limit instead of slashes.\" , ) parser . add_argument ( \"-V\" , \"--version\" , action = \"store_true\" , dest = \"show_version\" , help = \"Displays the currently installed version of isort.\" , ) parser . add_argument ( \"-v\" , \"--verbose\" , action = \"store_true\" , dest = \"verbose\" , help = \"Shows verbose output, such as when files are skipped or when a check is successful.\" , ) parser . add_argument ( \"--virtual-env\" , dest = \"virtual_env\" , help = \"Virtual environment to use for determining whether a package is third-party\" , ) parser . add_argument ( \"--conda-env\" , dest = \"conda_env\" , help = \"Conda environment to use for determining whether a package is third-party\" , ) parser . add_argument ( \"--vn\" , \"--version-number\" , action = \"version\" , version = __version__ , help = \"Returns just the current version number without the logo\" , ) parser . add_argument ( \"-l\" , \"-w\" , \"--line-length\" , \"--line-width\" , help = \"The max length of an import line (used for wrapping long imports).\" , dest = \"line_length\" , type = int , ) parser . add_argument ( \"--wl\" , \"--wrap-length\" , dest = \"wrap_length\" , type = int , help = \"Specifies how long lines that are wrapped should be, if not set line_length is used.\" \" \\n NOTE: wrap_length must be LOWER than or equal to line_length.\" , ) parser . add_argument ( \"--ws\" , \"--ignore-whitespace\" , action = \"store_true\" , dest = \"ignore_whitespace\" , help = \"Tells isort to ignore whitespace differences when --check-only is being used.\" , ) parser . add_argument ( \"--case-sensitive\" , dest = \"case_sensitive\" , action = \"store_true\" , help = \"Tells isort to include casing when sorting module names\" , ) parser . add_argument ( \"--filter-files\" , dest = \"filter_files\" , action = \"store_true\" , help = \"Tells isort to filter files even when they are explicitly passed in as \" \"part of the command\" , ) parser . add_argument ( \"files\" , nargs = \"*\" , help = \"One or more Python source files that need their imports sorted.\" ) parser . add_argument ( \"--py\" , \"--python-version\" , action = \"store\" , dest = \"py_version\" , choices = tuple ( VALID_PY_TARGETS ) + ( \"auto\" ,), help = \"Tells isort to set the known standard library based on the the specified Python \" \"version. Default is to assume any Python 3 version could be the target, and use a union \" \"off all stdlib modules across versions. If auto is specified, the version of the \" \"interpreter used to run isort \" f \"(currently: {sys.version_info.major}{sys.version_info.minor}) will be used.\" , ) parser . add_argument ( \"--profile\" , dest = \"profile\" , choices = list ( profiles . keys ()), type = str , help = \"Base profile type to use for configuration.\" , ) parser . add_argument ( \"--interactive\" , dest = \"ask_to_apply\" , action = \"store_true\" , help = \"Tells isort to apply changes interactively.\" , ) parser . add_argument ( \"--old-finders\" , \"--magic-placement\" , dest = \"old_finders\" , action = \"store_true\" , help = \"Use the old deprecated finder logic that relies on environment introspection magic.\" , ) parser . add_argument ( \"--show-config\" , dest = \"show_config\" , action = \"store_true\" , help = \"See isort's determined config, as well as sources of config options.\" , ) return parser def parse_args ( argv : Optional [ Sequence [ str ]] = None ) -> Dict [ str , Any ]: parser = _build_arg_parser () arguments = { key : value for key , value in vars ( parser . parse_args ( argv )) . items () if value } if \"dont_order_by_type\" in arguments : arguments [ \"order_by_type\" ] = False multi_line_output = arguments . get ( \"multi_line_output\" , None ) if multi_line_output : if multi_line_output . isdigit (): arguments [ \"multi_line_output\" ] = WrapModes ( int ( multi_line_output )) else : arguments [ \"multi_line_output\" ] = WrapModes [ multi_line_output ] return arguments def _preconvert ( item ): \"\"\"Preconverts objects from native types into JSONifyiable types\"\"\" if isinstance ( item , ( set , frozenset )): return list ( item ) elif isinstance ( item , WrapModes ): return item . name elif isinstance ( item , Path ): return str ( item ) else : raise TypeError ( \"Unserializable object {} of type {}\" . format ( item , type ( item ))) def main ( argv : Optional [ Sequence [ str ]] = None , stdin : Optional [ TextIOWrapper ] = None ) -> None : arguments = parse_args ( argv ) if arguments . get ( \"show_version\" ): print ( ASCII_ART ) return show_config : bool = arguments . pop ( \"show_config\" , False ) if \"settings_path\" in arguments : if os . path . isfile ( arguments [ \"settings_path\" ]): arguments [ \"settings_file\" ] = os . path . abspath ( arguments [ \"settings_path\" ]) arguments [ \"settings_path\" ] = os . path . dirname ( arguments [ \"settings_file\" ]) elif not os . path . isdir ( arguments [ \"settings_path\" ]): warn ( f \"settings_path dir does not exist: {arguments['settings_path']}\" ) else : arguments [ \"settings_path\" ] = os . path . abspath ( arguments [ \"settings_path\" ]) if \"virtual_env\" in arguments : venv = arguments [ \"virtual_env\" ] arguments [ \"virtual_env\" ] = os . path . abspath ( venv ) if not os . path . isdir ( arguments [ \"virtual_env\" ]): warn ( f \"virtual_env dir does not exist: {arguments['virtual_env']}\" ) file_names = arguments . pop ( \"files\" , []) if not file_names and not show_config : print ( QUICK_GUIDE ) return elif file_names == [ \"-\" ] and not show_config : api . sort_stream ( input_stream = sys . stdin if stdin is None else stdin , output_stream = sys . stdout , ** arguments , ) return if \"settings_path\" not in arguments : arguments [ \"settings_path\" ] = ( os . path . abspath ( file_names [ 0 ] if file_names else \".\" ) or os . getcwd () ) if not os . path . isdir ( arguments [ \"settings_path\" ]): arguments [ \"settings_path\" ] = os . path . dirname ( arguments [ \"settings_path\" ]) config_dict = arguments . copy () ask_to_apply = config_dict . pop ( \"ask_to_apply\" , False ) jobs = config_dict . pop ( \"jobs\" , ()) filter_files = config_dict . pop ( \"filter_files\" , False ) check = config_dict . pop ( \"check\" , False ) show_diff = config_dict . pop ( \"show_diff\" , False ) write_to_stdout = config_dict . pop ( \"write_to_stdout\" , False ) if \"src_paths\" in config_dict : config_dict [ \"src_paths\" ] = { Path ( src_path ) . resolve () for src_path in config_dict . get ( \"src_paths\" , ()) } config = Config ( ** config_dict ) if show_config : print ( json . dumps ( config . __dict__ , indent = 4 , separators = ( \",\" , \": \" ), default = _preconvert )) return wrong_sorted_files = False skipped : List [ str ] = [] if filter_files : filtered_files = [] for file_name in file_names : if config . is_skipped ( Path ( file_name )): skipped . append ( file_name ) else : filtered_files . append ( file_name ) file_names = filtered_files file_names = iter_source_code ( file_names , config , skipped ) num_skipped = 0 if config . verbose : print ( ASCII_ART ) if jobs : import multiprocessing executor = multiprocessing . Pool ( jobs ) attempt_iterator = executor . imap ( functools . partial ( sort_imports , config = config , check = check , ask_to_apply = ask_to_apply , write_to_stdout = write_to_stdout , ), file_names , ) else : # https://github.com/python/typeshed/pull/2814 attempt_iterator = ( sort_imports ( # type: ignore file_name , config = config , check = check , ask_to_apply = ask_to_apply , show_diff = show_diff , write_to_stdout = write_to_stdout , ) for file_name in file_names ) for sort_attempt in attempt_iterator : if not sort_attempt : continue # pragma: no cover - shouldn't happen, satisfies type constraint incorrectly_sorted = sort_attempt . incorrectly_sorted if arguments . get ( \"check\" , False ) and incorrectly_sorted : wrong_sorted_files = True if sort_attempt . skipped : num_skipped += 1 # pragma: no cover - shouldn't happen, due to skip in iter_source_code if wrong_sorted_files : sys . exit ( 1 ) num_skipped += len ( skipped ) if num_skipped and not arguments . get ( \"quiet\" , False ): if config . verbose : for was_skipped in skipped : warn ( f \"{was_skipped} was skipped as it's listed in 'skip' setting\" \" or matches a glob in 'skip_glob' setting\" ) print ( f \"Skipped {num_skipped} files\" ) if __name__ == \"__main__\" : main ()","title":"Module isort.main"},{"location":"reference/isort/main/#variables","text":"ASCII_ART QUICK_GUIDE SUPPORTED_EXTENSIONS VALID_PY_TARGETS profiles shebang_re","title":"Variables"},{"location":"reference/isort/main/#functions","text":"","title":"Functions"},{"location":"reference/isort/main/#is_python_file","text":"def is_python_file ( path : str ) -> bool View Source def is_python_file ( path : str ) -> bool : _root , ext = os . path . splitext ( path ) if ext in SUPPORTED_EXTENSIONS : return True if ext in ( \".pex\" ,): return False # Skip editor backup files . if path . endswith ( \"~\" ): return False try : if stat . S_ISFIFO ( os . stat ( path ). st_mode ): return False except OSError : pass try : with open ( path , \"rb\" ) as fp : line = fp . readline ( 100 ) except OSError : return False else : return bool ( shebang_re . match ( line ))","title":"is_python_file"},{"location":"reference/isort/main/#iter_source_code","text":"def iter_source_code ( paths : Iterable [ str ], config : isort . settings . Config , skipped : List [ str ] ) -> Iterator [ str ] Iterate over all Python source files defined in paths. View Source def iter_source_code ( paths : Iterable [ str ] , config : Config , skipped : List [ str ] ) -> Iterator [ str ] : \"\"\"Iterate over all Python source files defined in paths.\"\"\" for path in paths : if os . path . isdir ( path ) : for dirpath , dirnames , filenames in os . walk ( path , topdown = True , followlinks = True ) : base_path = Path ( dirpath ) for dirname in list ( dirnames ) : if config . is_skipped ( base_path / dirname ) : skipped . append ( dirname ) dirnames . remove ( dirname ) for filename in filenames : filepath = os . path . join ( dirpath , filename ) if is_python_file ( filepath ) : if config . is_skipped ( Path ( filepath )) : skipped . append ( filename ) else : yield filepath else : yield path","title":"iter_source_code"},{"location":"reference/isort/main/#main","text":"def main ( argv : Union [ Sequence [ str ], NoneType ] = None , stdin : Union [ _io . TextIOWrapper , NoneType ] = None ) -> None View Source def main ( argv : Optional [ Sequence[str ] ] = None , stdin : Optional [ TextIOWrapper ] = None ) -> None : arguments = parse_args ( argv ) if arguments . get ( \"show_version\" ) : print ( ASCII_ART ) return show_config : bool = arguments . pop ( \"show_config\" , False ) if \"settings_path\" in arguments : if os . path . isfile ( arguments [ \"settings_path\" ] ) : arguments [ \"settings_file\" ] = os . path . abspath ( arguments [ \"settings_path\" ] ) arguments [ \"settings_path\" ] = os . path . dirname ( arguments [ \"settings_file\" ] ) elif not os . path . isdir ( arguments [ \"settings_path\" ] ) : warn ( f \"settings_path dir does not exist: {arguments['settings_path']}\" ) else : arguments [ \"settings_path\" ] = os . path . abspath ( arguments [ \"settings_path\" ] ) if \"virtual_env\" in arguments : venv = arguments [ \"virtual_env\" ] arguments [ \"virtual_env\" ] = os . path . abspath ( venv ) if not os . path . isdir ( arguments [ \"virtual_env\" ] ) : warn ( f \"virtual_env dir does not exist: {arguments['virtual_env']}\" ) file_names = arguments . pop ( \"files\" , [] ) if not file_names and not show_config : print ( QUICK_GUIDE ) return elif file_names == [ \"-\" ] and not show_config : api . sort_stream ( input_stream = sys . stdin if stdin is None else stdin , output_stream = sys . stdout , ** arguments , ) return if \"settings_path\" not in arguments : arguments [ \"settings_path\" ] = ( os . path . abspath ( file_names [ 0 ] if file_names else \".\" ) or os . getcwd () ) if not os . path . isdir ( arguments [ \"settings_path\" ] ) : arguments [ \"settings_path\" ] = os . path . dirname ( arguments [ \"settings_path\" ] ) config_dict = arguments . copy () ask_to_apply = config_dict . pop ( \"ask_to_apply\" , False ) jobs = config_dict . pop ( \"jobs\" , ()) filter_files = config_dict . pop ( \"filter_files\" , False ) check = config_dict . pop ( \"check\" , False ) show_diff = config_dict . pop ( \"show_diff\" , False ) write_to_stdout = config_dict . pop ( \"write_to_stdout\" , False ) if \"src_paths\" in config_dict : config_dict [ \"src_paths\" ] = { Path ( src_path ). resolve () for src_path in config_dict . get ( \"src_paths\" , ()) } config = Config ( ** config_dict ) if show_config : print ( json . dumps ( config . __dict__ , indent = 4 , separators = ( \",\" , \": \" ), default = _preconvert )) return wrong_sorted_files = False skipped : List [ str ] = [] if filter_files : filtered_files = [] for file_name in file_names : if config . is_skipped ( Path ( file_name )) : skipped . append ( file_name ) else : filtered_files . append ( file_name ) file_names = filtered_files file_names = iter_source_code ( file_names , config , skipped ) num_skipped = 0 if config . verbose : print ( ASCII_ART ) if jobs : import multiprocessing executor = multiprocessing . Pool ( jobs ) attempt_iterator = executor . imap ( functools . partial ( sort_imports , config = config , check = check , ask_to_apply = ask_to_apply , write_to_stdout = write_to_stdout , ), file_names , ) else : # https : // github . com / python / typeshed / pull / 2814 attempt_iterator = ( sort_imports ( # type : ignore file_name , config = config , check = check , ask_to_apply = ask_to_apply , show_diff = show_diff , write_to_stdout = write_to_stdout , ) for file_name in file_names ) for sort_attempt in attempt_iterator : if not sort_attempt : continue # pragma : no cover - shouldn 't happen, satisfies type constraint incorrectly_sorted = sort_attempt.incorrectly_sorted if arguments.get(\"check\", False) and incorrectly_sorted: wrong_sorted_files = True if sort_attempt.skipped: num_skipped += 1 # pragma: no cover - shouldn' t happen , due to skip in iter_source_code if wrong_sorted_files : sys . exit ( 1 ) num_skipped += len ( skipped ) if num_skipped and not arguments . get ( \"quiet\" , False ) : if config . verbose : for was_skipped in skipped : warn ( f \"{was_skipped} was skipped as it's listed in 'skip' setting\" \" or matches a glob in 'skip_glob' setting\" ) print ( f \"Skipped {num_skipped} files\" )","title":"main"},{"location":"reference/isort/main/#parse_args","text":"def parse_args ( argv : Union [ Sequence [ str ], NoneType ] = None ) -> Dict [ str , Any ] View Source def parse_args ( argv : Optional [ Sequence[str ] ] = None ) -> Dict [ str, Any ] : parser = _build_arg_parser () arguments = { key : value for key , value in vars ( parser . parse_args ( argv )). items () if value } if \"dont_order_by_type\" in arguments : arguments [ \"order_by_type\" ] = False multi_line_output = arguments . get ( \"multi_line_output\" , None ) if multi_line_output : if multi_line_output . isdigit () : arguments [ \"multi_line_output\" ] = WrapModes ( int ( multi_line_output )) else : arguments [ \"multi_line_output\" ] = WrapModes [ multi_line_output ] return arguments","title":"parse_args"},{"location":"reference/isort/main/#sort_imports","text":"def sort_imports ( file_name : str , config : isort . settings . Config , check : bool = False , ask_to_apply : bool = False , write_to_stdout : bool = False , ** kwargs : Any ) -> Union [ isort . main . SortAttempt , NoneType ] View Source def sort_imports ( file_name : str , config : Config , check : bool = False , ask_to_apply : bool = False , write_to_stdout : bool = False , ** kwargs : Any , ) -> Optional [ SortAttempt ] : try : incorrectly_sorted : bool = False skipped : bool = False if check : try : incorrectly_sorted = not api . check_file ( file_name , config = config , ** kwargs ) except FileSkipped : skipped = True return SortAttempt ( incorrectly_sorted , skipped ) else : try : incorrectly_sorted = not api . sort_file ( file_name , config = config , ask_to_apply = ask_to_apply , write_to_stdout = write_to_stdout , ** kwargs , ) except FileSkipped : skipped = True return SortAttempt ( incorrectly_sorted , skipped ) except ( OSError , ValueError ) as error : warn ( f \"Unable to parse file {file_name} due to {error}\" ) return None","title":"sort_imports"},{"location":"reference/isort/main/#classes","text":"","title":"Classes"},{"location":"reference/isort/main/#sortattempt","text":"class SortAttempt ( incorrectly_sorted : bool , skipped : bool ) View Source class SortAttempt: def __init__ ( self , incorrectly_sorted: bool , skipped: bool ) -> None: self . incorrectly_sorted = incorrectly_sorted self . skipped = skipped","title":"SortAttempt"},{"location":"reference/isort/output/","text":"Module isort.output View Source import copy import itertools from functools import partial from typing import Iterable , List , Tuple from isort.format import format_simplified from . import parse , sorting , wrap from .comments import add_to_line as with_comments from .settings import DEFAULT_CONFIG , Config STATEMENT_DECLERATIONS : Tuple [ str , ... ] = ( \"def \" , \"cdef \" , \"cpdef \" , \"class \" , \"@\" , \"async def\" ) def sorted_imports ( parsed : parse . ParsedContent , config : Config = DEFAULT_CONFIG , extension : str = \"py\" , import_type : str = \"import\" , ) -> str : \"\"\"Adds the imports back to the file. (at the index of the first import) sorted alphabetically and split between groups \"\"\" if parsed . import_index == - 1 : return _output_as_string ( parsed . lines_without_imports , parsed . line_separator ) formatted_output : List [ str ] = parsed . lines_without_imports . copy () remove_imports = [ format_simplified ( removal ) for removal in config . remove_imports ] sort_ignore_case = config . force_alphabetical_sort_within_sections sections : Iterable [ str ] = itertools . chain ( parsed . sections , config . forced_separate ) if config . no_sections : parsed . imports [ \"no_sections\" ] = { \"straight\" : {}, \"from\" : {}} base_sections : Tuple [ str , ... ] = () for section in sections : if section == \"FUTURE\" : base_sections = ( \"FUTURE\" ,) continue parsed . imports [ \"no_sections\" ][ \"straight\" ] . update ( parsed . imports [ section ] . get ( \"straight\" , {}) ) parsed . imports [ \"no_sections\" ][ \"from\" ] . update ( parsed . imports [ section ] . get ( \"from\" , {})) sections = base_sections + ( \"no_sections\" ,) output : List [ str ] = [] pending_lines_before = False for section in sections : straight_modules = parsed . imports [ section ][ \"straight\" ] straight_modules = sorting . naturally ( straight_modules , key = lambda key : sorting . module_key ( key , config , section_name = section ) ) from_modules = parsed . imports [ section ][ \"from\" ] from_modules = sorting . naturally ( from_modules , key = lambda key : sorting . module_key ( key , config , section_name = section ) ) if config . force_sort_within_sections : copied_comments = copy . deepcopy ( parsed . categorized_comments ) section_output : List [ str ] = [] if config . from_first : section_output = _with_from_imports ( parsed , config , from_modules , section , section_output , sort_ignore_case , remove_imports , import_type , ) if config . lines_between_types and from_modules and straight_modules : section_output . extend ([ \"\" ] * config . lines_between_types ) section_output = _with_straight_imports ( parsed , config , straight_modules , section , section_output , remove_imports , import_type , ) else : section_output = _with_straight_imports ( parsed , config , straight_modules , section , section_output , remove_imports , import_type , ) if config . lines_between_types and from_modules and straight_modules : section_output . extend ([ \"\" ] * config . lines_between_types ) section_output = _with_from_imports ( parsed , config , from_modules , section , section_output , sort_ignore_case , remove_imports , import_type , ) if config . force_sort_within_sections : # Remove comments section_output = [ line for line in section_output if not line . startswith ( \"#\" )] section_output = sorting . naturally ( section_output , key = partial ( sorting . section_key , order_by_type = config . order_by_type , force_to_top = config . force_to_top , lexicographical = config . lexicographical , length_sort = config . length_sort , ), ) # Add comments back all_comments = copied_comments [ \"above\" ][ \"from\" ] all_comments . update ( copied_comments [ \"above\" ][ \"straight\" ]) comment_indexes = {} for module , comment_list in all_comments . items (): for idx , line in enumerate ( section_output ): if module in line : comment_indexes [ idx ] = comment_list added = 0 for idx , comment_list in comment_indexes . items (): for comment in comment_list : section_output . insert ( idx + added , comment ) added += 1 section_name = section no_lines_before = section_name in config . no_lines_before if section_output : if section_name in parsed . place_imports : parsed . place_imports [ section_name ] = section_output continue section_title = config . import_headings . get ( section_name . lower (), \"\" ) if section_title : section_comment = f \"# {section_title}\" if section_comment not in parsed . lines_without_imports [ 0 : 1 ]: section_output . insert ( 0 , section_comment ) if pending_lines_before or not no_lines_before : output += [ \"\" ] * config . lines_between_sections output += section_output pending_lines_before = False else : pending_lines_before = pending_lines_before or not no_lines_before while output and output [ - 1 ] . strip () == \"\" : output . pop () # pragma: no cover while output and output [ 0 ] . strip () == \"\" : output . pop ( 0 ) output_at = 0 if parsed . import_index < parsed . original_line_count : output_at = parsed . import_index formatted_output [ output_at : 0 ] = output imports_tail = output_at + len ( output ) while [ character . strip () for character in formatted_output [ imports_tail : imports_tail + 1 ] ] == [ \"\" ]: formatted_output . pop ( imports_tail ) if len ( formatted_output ) > imports_tail : next_construct = \"\" _in_quote : str = \"\" tail = formatted_output [ imports_tail :] for index , line in enumerate ( tail ): in_quote = _in_quote should_skip , _in_quote , * _ = parse . skip_line ( line , in_quote = _in_quote , index = len ( formatted_output ), section_comments = parsed . section_comments , ) if not should_skip and line . strip (): if ( line . strip () . startswith ( \"#\" ) and len ( tail ) > ( index + 1 ) and tail [ index + 1 ] . strip () ): continue next_construct = line break elif not in_quote : parts = line . split () if ( len ( parts ) >= 3 and parts [ 1 ] == \"=\" and \"'\" not in parts [ 0 ] and '\"' not in parts [ 0 ] ): next_construct = line break if config . lines_after_imports != - 1 : formatted_output [ imports_tail : 0 ] = [ \"\" for line in range ( config . lines_after_imports )] elif extension != \"pyi\" and next_construct . startswith ( STATEMENT_DECLERATIONS ): formatted_output [ imports_tail : 0 ] = [ \"\" , \"\" ] else : formatted_output [ imports_tail : 0 ] = [ \"\" ] if parsed . place_imports : new_out_lines = [] for index , line in enumerate ( formatted_output ): new_out_lines . append ( line ) if line in parsed . import_placements : new_out_lines . extend ( parsed . place_imports [ parsed . import_placements [ line ]]) if len ( formatted_output ) <= index or formatted_output [ index + 1 ] . strip () != \"\" : new_out_lines . append ( \"\" ) formatted_output = new_out_lines return _output_as_string ( formatted_output , parsed . line_separator ) def _with_from_imports ( parsed : parse . ParsedContent , config : Config , from_modules : Iterable [ str ], section : str , section_output : List [ str ], ignore_case : bool , remove_imports : List [ str ], import_type : str , ) -> List [ str ]: new_section_output = section_output . copy () for module in from_modules : if module in remove_imports : continue import_start = f \"from {module} {import_type} \" from_imports = list ( parsed . imports [ section ][ \"from\" ][ module ]) if not config . no_inline_sort or ( config . force_single_line and module not in config . single_line_exclusions ): from_imports = sorting . naturally ( from_imports , key = lambda key : sorting . module_key ( key , config , True , ignore_case , section_name = section ), ) if remove_imports : from_imports = [ line for line in from_imports if f \"{module}.{line}\" not in remove_imports ] sub_modules = [ f \"{module}.{from_import}\" for from_import in from_imports ] as_imports = { from_import : [ f \"{from_import} as {as_module}\" for as_module in parsed . as_map [ sub_module ] ] for from_import , sub_module in zip ( from_imports , sub_modules ) if sub_module in parsed . as_map } if config . combine_as_imports and not ( \"*\" in from_imports and config . combine_star ): if not config . no_inline_sort : for as_import in as_imports : as_imports [ as_import ] = sorting . naturally ( as_imports [ as_import ]) for from_import in copy . copy ( from_imports ): if from_import in as_imports : idx = from_imports . index ( from_import ) if ( config . keep_direct_and_as_imports and parsed . imports [ section ][ \"from\" ][ module ][ from_import ] ): from_imports [( idx + 1 ) : ( idx + 1 )] = as_imports . pop ( from_import ) else : from_imports [ idx : ( idx + 1 )] = as_imports . pop ( from_import ) while from_imports : comments = parsed . categorized_comments [ \"from\" ] . pop ( module , ()) if \"*\" in from_imports and config . combine_star : import_statement = wrap . line ( with_comments ( comments , f \"{import_start}*\" , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ), parsed . line_separator , config , ) from_imports = [] elif config . force_single_line and module not in config . single_line_exclusions : import_statement = \"\" while from_imports : from_import = from_imports . pop ( 0 ) single_import_line = with_comments ( comments , import_start + from_import , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) comment = ( parsed . categorized_comments [ \"nested\" ] . get ( module , {}) . pop ( from_import , None ) ) if comment : single_import_line += ( f \"{comments and ';' or config.comment_prefix} \" f \"{comment}\" ) if from_import in as_imports : if ( config . keep_direct_and_as_imports and parsed . imports [ section ][ \"from\" ][ module ][ from_import ] ): new_section_output . append ( wrap . line ( single_import_line , parsed . line_separator , config ) ) from_comments = parsed . categorized_comments [ \"straight\" ] . get ( f \"{module}.{from_import}\" ) new_section_output . extend ( with_comments ( from_comments , wrap . line ( import_start + as_import , parsed . line_separator , config ), removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) for as_import in sorting . naturally ( as_imports [ from_import ]) ) else : new_section_output . append ( wrap . line ( single_import_line , parsed . line_separator , config ) ) comments = None else : above_comments = parsed . categorized_comments [ \"above\" ][ \"from\" ] . pop ( module , None ) if above_comments : if new_section_output and config . ensure_newline_before_comments : new_section_output . append ( \"\" ) new_section_output . extend ( above_comments ) while from_imports and from_imports [ 0 ] in as_imports : from_import = from_imports . pop ( 0 ) as_imports [ from_import ] = sorting . naturally ( as_imports [ from_import ]) from_comments = parsed . categorized_comments [ \"straight\" ] . get ( f \"{module}.{from_import}\" ) if ( config . keep_direct_and_as_imports and parsed . imports [ section ][ \"from\" ][ module ][ from_import ] ): new_section_output . append ( with_comments ( from_comments , wrap . line ( import_start + from_import , parsed . line_separator , config ), removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) ) new_section_output . extend ( with_comments ( from_comments , wrap . line ( import_start + as_import , parsed . line_separator , config ), removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) for as_import in as_imports [ from_import ] ) star_import = False if \"*\" in from_imports : new_section_output . append ( with_comments ( comments , f \"{import_start}*\" , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) ) from_imports . remove ( \"*\" ) star_import = True comments = None for from_import in copy . copy ( from_imports ): if from_import in as_imports and not config . keep_direct_and_as_imports : continue comment = ( parsed . categorized_comments [ \"nested\" ] . get ( module , {}) . pop ( from_import , None ) ) if comment : single_import_line = with_comments ( comments , import_start + from_import , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) single_import_line += ( f \"{comments and ';' or config.comment_prefix} \" f \"{comment}\" ) new_section_output . append ( wrap . line ( single_import_line , parsed . line_separator , config ) ) from_imports . remove ( from_import ) comments = None from_import_section = [] while from_imports and ( from_imports [ 0 ] not in as_imports or ( config . keep_direct_and_as_imports and config . combine_as_imports and parsed . imports [ section ][ \"from\" ][ module ][ from_import ] ) ): from_import_section . append ( from_imports . pop ( 0 )) if star_import : import_statement = import_start + ( \", \" ) . join ( from_import_section ) else : import_statement = with_comments ( comments , import_start + ( \", \" ) . join ( from_import_section ), removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) if not from_import_section : import_statement = \"\" do_multiline_reformat = False force_grid_wrap = config . force_grid_wrap if force_grid_wrap and len ( from_import_section ) >= force_grid_wrap : do_multiline_reformat = True if len ( import_statement ) > config . line_length and len ( from_import_section ) > 1 : do_multiline_reformat = True # If line too long AND have imports AND we are # NOT using GRID or VERTICAL wrap modes if ( len ( import_statement ) > config . line_length and len ( from_import_section ) > 0 and config . multi_line_output not in ( wrap . Modes . GRID , wrap . Modes . VERTICAL ) # type: ignore ): do_multiline_reformat = True if do_multiline_reformat : import_statement = wrap . import_statement ( import_start = import_start , from_imports = from_import_section , comments = comments , line_separator = parsed . line_separator , config = config , ) if config . multi_line_output == wrap . Modes . GRID : # type: ignore other_import_statement = wrap . import_statement ( import_start = import_start , from_imports = from_import_section , comments = comments , line_separator = parsed . line_separator , config = config , multi_line_output = wrap . Modes . VERTICAL_GRID , # type: ignore ) if max ( len ( x ) for x in import_statement . split ( \" \\n \" )) > config . line_length : import_statement = other_import_statement if not do_multiline_reformat and len ( import_statement ) > config . line_length : import_statement = wrap . line ( import_statement , parsed . line_separator , config ) if import_statement : above_comments = parsed . categorized_comments [ \"above\" ][ \"from\" ] . pop ( module , None ) if above_comments : # pragma: no cover if new_section_output and config . ensure_newline_before_comments : new_section_output . append ( \"\" ) new_section_output . extend ( above_comments ) new_section_output . append ( import_statement ) return new_section_output def _with_straight_imports ( parsed : parse . ParsedContent , config : Config , straight_modules : Iterable [ str ], section : str , section_output : List [ str ], remove_imports : List [ str ], import_type : str , ) -> List [ str ]: new_section_output = section_output . copy () for module in straight_modules : if module in remove_imports : continue import_definition = [] if module in parsed . as_map : if config . keep_direct_and_as_imports and parsed . imports [ section ][ \"straight\" ][ module ]: import_definition . append ( f \"{import_type} {module}\" ) import_definition . extend ( f \"{import_type} {module} as {as_import}\" for as_import in parsed . as_map [ module ] ) else : import_definition . append ( f \"{import_type} {module}\" ) comments_above = parsed . categorized_comments [ \"above\" ][ \"straight\" ] . pop ( module , None ) if comments_above : if new_section_output and config . ensure_newline_before_comments : new_section_output . append ( \"\" ) new_section_output . extend ( comments_above ) new_section_output . extend ( with_comments ( parsed . categorized_comments [ \"straight\" ] . get ( module ), idef , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) for idef in import_definition ) return new_section_output def _output_as_string ( lines : List [ str ], line_separator : str ) -> str : return line_separator . join ( _normalize_empty_lines ( lines )) def _normalize_empty_lines ( lines : List [ str ]) -> List [ str ]: while lines and lines [ - 1 ] . strip () == \"\" : lines . pop ( - 1 ) lines . append ( \"\" ) return lines Variables STATEMENT_DECLERATIONS Functions sorted_imports def sorted_imports ( parsed : isort . parse . ParsedContent , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ), extension : str = 'py' , import_type : str = 'import' ) -> str Adds the imports back to the file. (at the index of the first import) sorted alphabetically and split between groups View Source def sorted_imports ( parsed : parse . ParsedContent , config : Config = DEFAULT_CONFIG , extension : str = \"py\" , import_type : str = \"import\" , ) -> str : \"\"\"Adds the imports back to the file. ( at the index of the first import ) sorted alphabetically and split between groups \"\"\" if parsed . import_index == - 1 : return _output_as_string ( parsed . lines_without_imports , parsed . line_separator ) formatted_output : List [ str ] = parsed . lines_without_imports . copy () remove_imports = [ format_simplified ( removal ) for removal in config . remove_imports ] sort_ignore_case = config . force_alphabetical_sort_within_sections sections : Iterable [ str ] = itertools . chain ( parsed . sections , config . forced_separate ) if config . no_sections : parsed . imports [ \"no_sections\" ] = { \"straight\" : {}, \"from\" : {}} base_sections : Tuple [ str , ...] = () for section in sections : if section == \"FUTURE\" : base_sections = ( \"FUTURE\" ,) continue parsed . imports [ \"no_sections\" ][ \"straight\" ]. update ( parsed . imports [ section ]. get ( \"straight\" , {}) ) parsed . imports [ \"no_sections\" ][ \"from\" ]. update ( parsed . imports [ section ]. get ( \"from\" , {})) sections = base_sections + ( \"no_sections\" ,) output : List [ str ] = [] pending_lines_before = False for section in sections : straight_modules = parsed . imports [ section ][ \"straight\" ] straight_modules = sorting . naturally ( straight_modules , key = lambda key : sorting . module_key ( key , config , section_name = section ) ) from_modules = parsed . imports [ section ][ \"from\" ] from_modules = sorting . naturally ( from_modules , key = lambda key : sorting . module_key ( key , config , section_name = section ) ) if config . force_sort_within_sections : copied_comments = copy . deepcopy ( parsed . categorized_comments ) section_output : List [ str ] = [] if config . from_first : section_output = _with_from_imports ( parsed , config , from_modules , section , section_output , sort_ignore_case , remove_imports , import_type , ) if config . lines_between_types and from_modules and straight_modules : section_output . extend ([ \"\" ] * config . lines_between_types ) section_output = _with_straight_imports ( parsed , config , straight_modules , section , section_output , remove_imports , import_type , ) else : section_output = _with_straight_imports ( parsed , config , straight_modules , section , section_output , remove_imports , import_type , ) if config . lines_between_types and from_modules and straight_modules : section_output . extend ([ \"\" ] * config . lines_between_types ) section_output = _with_from_imports ( parsed , config , from_modules , section , section_output , sort_ignore_case , remove_imports , import_type , ) if config . force_sort_within_sections : # Remove comments section_output = [ line for line in section_output if not line . startswith ( \"#\" )] section_output = sorting . naturally ( section_output , key = partial ( sorting . section_key , order_by_type = config . order_by_type , force_to_top = config . force_to_top , lexicographical = config . lexicographical , length_sort = config . length_sort , ), ) # Add comments back all_comments = copied_comments [ \"above\" ][ \"from\" ] all_comments . update ( copied_comments [ \"above\" ][ \"straight\" ]) comment_indexes = {} for module , comment_list in all_comments . items () : for idx , line in enumerate ( section_output ) : if module in line : comment_indexes [ idx ] = comment_list added = 0 for idx , comment_list in comment_indexes . items () : for comment in comment_list : section_output . insert ( idx + added , comment ) added += 1 section_name = section no_lines_before = section_name in config . no_lines_before if section_output : if section_name in parsed . place_imports : parsed . place_imports [ section_name ] = section_output continue section_title = config . import_headings . get ( section_name . lower (), \"\" ) if section_title : section_comment = f \"# {section_title}\" if section_comment not in parsed . lines_without_imports [ 0 : 1 ] : section_output . insert ( 0 , section_comment ) if pending_lines_before or not no_lines_before : output += [ \"\" ] * config . lines_between_sections output += section_output pending_lines_before = False else : pending_lines_before = pending_lines_before or not no_lines_before while output and output [ - 1 ]. strip () == \"\" : output . pop () # pragma : no cover while output and output [ 0 ]. strip () == \"\" : output . pop ( 0 ) output_at = 0 if parsed . import_index < parsed . original_line_count : output_at = parsed . import_index formatted_output [ output_at : 0 ] = output imports_tail = output_at + len ( output ) while [ character . strip () for character in formatted_output [ imports_tail : imports_tail + 1 ] ] == [ \"\" ] : formatted_output . pop ( imports_tail ) if len ( formatted_output ) > imports_tail : next_construct = \"\" _in_quote : str = \"\" tail = formatted_output [ imports_tail :] for index , line in enumerate ( tail ) : in_quote = _in_quote should_skip , _in_quote , * _ = parse . skip_line ( line , in_quote = _in_quote , index = len ( formatted_output ), section_comments = parsed . section_comments , ) if not should_skip and line . strip () : if ( line . strip (). startswith ( \"#\" ) and len ( tail ) > ( index + 1 ) and tail [ index + 1 ]. strip () ) : continue next_construct = line break elif not in_quote : parts = line . split () if ( len ( parts ) >= 3 and parts [ 1 ] == \"=\" and \"'\" not in parts [ 0 ] and '\"' not in parts [ 0 ] ) : next_construct = line break if config . lines_after_imports != - 1 : formatted_output [ imports_tail : 0 ] = [ \"\" for line in range ( config . lines_after_imports )] elif extension != \"pyi\" and next_construct . startswith ( STATEMENT_DECLERATIONS ) : formatted_output [ imports_tail : 0 ] = [ \"\" , \"\" ] else : formatted_output [ imports_tail : 0 ] = [ \"\" ] if parsed . place_imports : new_out_lines = [] for index , line in enumerate ( formatted_output ) : new_out_lines . append ( line ) if line in parsed . import_placements : new_out_lines . extend ( parsed . place_imports [ parsed . import_placements [ line ]]) if len ( formatted_output ) <= index or formatted_output [ index + 1 ]. strip () != \"\" : new_out_lines . append ( \"\" ) formatted_output = new_out_lines return _output_as_string ( formatted_output , parsed . line_separator )","title":"Output"},{"location":"reference/isort/output/#module-isortoutput","text":"View Source import copy import itertools from functools import partial from typing import Iterable , List , Tuple from isort.format import format_simplified from . import parse , sorting , wrap from .comments import add_to_line as with_comments from .settings import DEFAULT_CONFIG , Config STATEMENT_DECLERATIONS : Tuple [ str , ... ] = ( \"def \" , \"cdef \" , \"cpdef \" , \"class \" , \"@\" , \"async def\" ) def sorted_imports ( parsed : parse . ParsedContent , config : Config = DEFAULT_CONFIG , extension : str = \"py\" , import_type : str = \"import\" , ) -> str : \"\"\"Adds the imports back to the file. (at the index of the first import) sorted alphabetically and split between groups \"\"\" if parsed . import_index == - 1 : return _output_as_string ( parsed . lines_without_imports , parsed . line_separator ) formatted_output : List [ str ] = parsed . lines_without_imports . copy () remove_imports = [ format_simplified ( removal ) for removal in config . remove_imports ] sort_ignore_case = config . force_alphabetical_sort_within_sections sections : Iterable [ str ] = itertools . chain ( parsed . sections , config . forced_separate ) if config . no_sections : parsed . imports [ \"no_sections\" ] = { \"straight\" : {}, \"from\" : {}} base_sections : Tuple [ str , ... ] = () for section in sections : if section == \"FUTURE\" : base_sections = ( \"FUTURE\" ,) continue parsed . imports [ \"no_sections\" ][ \"straight\" ] . update ( parsed . imports [ section ] . get ( \"straight\" , {}) ) parsed . imports [ \"no_sections\" ][ \"from\" ] . update ( parsed . imports [ section ] . get ( \"from\" , {})) sections = base_sections + ( \"no_sections\" ,) output : List [ str ] = [] pending_lines_before = False for section in sections : straight_modules = parsed . imports [ section ][ \"straight\" ] straight_modules = sorting . naturally ( straight_modules , key = lambda key : sorting . module_key ( key , config , section_name = section ) ) from_modules = parsed . imports [ section ][ \"from\" ] from_modules = sorting . naturally ( from_modules , key = lambda key : sorting . module_key ( key , config , section_name = section ) ) if config . force_sort_within_sections : copied_comments = copy . deepcopy ( parsed . categorized_comments ) section_output : List [ str ] = [] if config . from_first : section_output = _with_from_imports ( parsed , config , from_modules , section , section_output , sort_ignore_case , remove_imports , import_type , ) if config . lines_between_types and from_modules and straight_modules : section_output . extend ([ \"\" ] * config . lines_between_types ) section_output = _with_straight_imports ( parsed , config , straight_modules , section , section_output , remove_imports , import_type , ) else : section_output = _with_straight_imports ( parsed , config , straight_modules , section , section_output , remove_imports , import_type , ) if config . lines_between_types and from_modules and straight_modules : section_output . extend ([ \"\" ] * config . lines_between_types ) section_output = _with_from_imports ( parsed , config , from_modules , section , section_output , sort_ignore_case , remove_imports , import_type , ) if config . force_sort_within_sections : # Remove comments section_output = [ line for line in section_output if not line . startswith ( \"#\" )] section_output = sorting . naturally ( section_output , key = partial ( sorting . section_key , order_by_type = config . order_by_type , force_to_top = config . force_to_top , lexicographical = config . lexicographical , length_sort = config . length_sort , ), ) # Add comments back all_comments = copied_comments [ \"above\" ][ \"from\" ] all_comments . update ( copied_comments [ \"above\" ][ \"straight\" ]) comment_indexes = {} for module , comment_list in all_comments . items (): for idx , line in enumerate ( section_output ): if module in line : comment_indexes [ idx ] = comment_list added = 0 for idx , comment_list in comment_indexes . items (): for comment in comment_list : section_output . insert ( idx + added , comment ) added += 1 section_name = section no_lines_before = section_name in config . no_lines_before if section_output : if section_name in parsed . place_imports : parsed . place_imports [ section_name ] = section_output continue section_title = config . import_headings . get ( section_name . lower (), \"\" ) if section_title : section_comment = f \"# {section_title}\" if section_comment not in parsed . lines_without_imports [ 0 : 1 ]: section_output . insert ( 0 , section_comment ) if pending_lines_before or not no_lines_before : output += [ \"\" ] * config . lines_between_sections output += section_output pending_lines_before = False else : pending_lines_before = pending_lines_before or not no_lines_before while output and output [ - 1 ] . strip () == \"\" : output . pop () # pragma: no cover while output and output [ 0 ] . strip () == \"\" : output . pop ( 0 ) output_at = 0 if parsed . import_index < parsed . original_line_count : output_at = parsed . import_index formatted_output [ output_at : 0 ] = output imports_tail = output_at + len ( output ) while [ character . strip () for character in formatted_output [ imports_tail : imports_tail + 1 ] ] == [ \"\" ]: formatted_output . pop ( imports_tail ) if len ( formatted_output ) > imports_tail : next_construct = \"\" _in_quote : str = \"\" tail = formatted_output [ imports_tail :] for index , line in enumerate ( tail ): in_quote = _in_quote should_skip , _in_quote , * _ = parse . skip_line ( line , in_quote = _in_quote , index = len ( formatted_output ), section_comments = parsed . section_comments , ) if not should_skip and line . strip (): if ( line . strip () . startswith ( \"#\" ) and len ( tail ) > ( index + 1 ) and tail [ index + 1 ] . strip () ): continue next_construct = line break elif not in_quote : parts = line . split () if ( len ( parts ) >= 3 and parts [ 1 ] == \"=\" and \"'\" not in parts [ 0 ] and '\"' not in parts [ 0 ] ): next_construct = line break if config . lines_after_imports != - 1 : formatted_output [ imports_tail : 0 ] = [ \"\" for line in range ( config . lines_after_imports )] elif extension != \"pyi\" and next_construct . startswith ( STATEMENT_DECLERATIONS ): formatted_output [ imports_tail : 0 ] = [ \"\" , \"\" ] else : formatted_output [ imports_tail : 0 ] = [ \"\" ] if parsed . place_imports : new_out_lines = [] for index , line in enumerate ( formatted_output ): new_out_lines . append ( line ) if line in parsed . import_placements : new_out_lines . extend ( parsed . place_imports [ parsed . import_placements [ line ]]) if len ( formatted_output ) <= index or formatted_output [ index + 1 ] . strip () != \"\" : new_out_lines . append ( \"\" ) formatted_output = new_out_lines return _output_as_string ( formatted_output , parsed . line_separator ) def _with_from_imports ( parsed : parse . ParsedContent , config : Config , from_modules : Iterable [ str ], section : str , section_output : List [ str ], ignore_case : bool , remove_imports : List [ str ], import_type : str , ) -> List [ str ]: new_section_output = section_output . copy () for module in from_modules : if module in remove_imports : continue import_start = f \"from {module} {import_type} \" from_imports = list ( parsed . imports [ section ][ \"from\" ][ module ]) if not config . no_inline_sort or ( config . force_single_line and module not in config . single_line_exclusions ): from_imports = sorting . naturally ( from_imports , key = lambda key : sorting . module_key ( key , config , True , ignore_case , section_name = section ), ) if remove_imports : from_imports = [ line for line in from_imports if f \"{module}.{line}\" not in remove_imports ] sub_modules = [ f \"{module}.{from_import}\" for from_import in from_imports ] as_imports = { from_import : [ f \"{from_import} as {as_module}\" for as_module in parsed . as_map [ sub_module ] ] for from_import , sub_module in zip ( from_imports , sub_modules ) if sub_module in parsed . as_map } if config . combine_as_imports and not ( \"*\" in from_imports and config . combine_star ): if not config . no_inline_sort : for as_import in as_imports : as_imports [ as_import ] = sorting . naturally ( as_imports [ as_import ]) for from_import in copy . copy ( from_imports ): if from_import in as_imports : idx = from_imports . index ( from_import ) if ( config . keep_direct_and_as_imports and parsed . imports [ section ][ \"from\" ][ module ][ from_import ] ): from_imports [( idx + 1 ) : ( idx + 1 )] = as_imports . pop ( from_import ) else : from_imports [ idx : ( idx + 1 )] = as_imports . pop ( from_import ) while from_imports : comments = parsed . categorized_comments [ \"from\" ] . pop ( module , ()) if \"*\" in from_imports and config . combine_star : import_statement = wrap . line ( with_comments ( comments , f \"{import_start}*\" , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ), parsed . line_separator , config , ) from_imports = [] elif config . force_single_line and module not in config . single_line_exclusions : import_statement = \"\" while from_imports : from_import = from_imports . pop ( 0 ) single_import_line = with_comments ( comments , import_start + from_import , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) comment = ( parsed . categorized_comments [ \"nested\" ] . get ( module , {}) . pop ( from_import , None ) ) if comment : single_import_line += ( f \"{comments and ';' or config.comment_prefix} \" f \"{comment}\" ) if from_import in as_imports : if ( config . keep_direct_and_as_imports and parsed . imports [ section ][ \"from\" ][ module ][ from_import ] ): new_section_output . append ( wrap . line ( single_import_line , parsed . line_separator , config ) ) from_comments = parsed . categorized_comments [ \"straight\" ] . get ( f \"{module}.{from_import}\" ) new_section_output . extend ( with_comments ( from_comments , wrap . line ( import_start + as_import , parsed . line_separator , config ), removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) for as_import in sorting . naturally ( as_imports [ from_import ]) ) else : new_section_output . append ( wrap . line ( single_import_line , parsed . line_separator , config ) ) comments = None else : above_comments = parsed . categorized_comments [ \"above\" ][ \"from\" ] . pop ( module , None ) if above_comments : if new_section_output and config . ensure_newline_before_comments : new_section_output . append ( \"\" ) new_section_output . extend ( above_comments ) while from_imports and from_imports [ 0 ] in as_imports : from_import = from_imports . pop ( 0 ) as_imports [ from_import ] = sorting . naturally ( as_imports [ from_import ]) from_comments = parsed . categorized_comments [ \"straight\" ] . get ( f \"{module}.{from_import}\" ) if ( config . keep_direct_and_as_imports and parsed . imports [ section ][ \"from\" ][ module ][ from_import ] ): new_section_output . append ( with_comments ( from_comments , wrap . line ( import_start + from_import , parsed . line_separator , config ), removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) ) new_section_output . extend ( with_comments ( from_comments , wrap . line ( import_start + as_import , parsed . line_separator , config ), removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) for as_import in as_imports [ from_import ] ) star_import = False if \"*\" in from_imports : new_section_output . append ( with_comments ( comments , f \"{import_start}*\" , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) ) from_imports . remove ( \"*\" ) star_import = True comments = None for from_import in copy . copy ( from_imports ): if from_import in as_imports and not config . keep_direct_and_as_imports : continue comment = ( parsed . categorized_comments [ \"nested\" ] . get ( module , {}) . pop ( from_import , None ) ) if comment : single_import_line = with_comments ( comments , import_start + from_import , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) single_import_line += ( f \"{comments and ';' or config.comment_prefix} \" f \"{comment}\" ) new_section_output . append ( wrap . line ( single_import_line , parsed . line_separator , config ) ) from_imports . remove ( from_import ) comments = None from_import_section = [] while from_imports and ( from_imports [ 0 ] not in as_imports or ( config . keep_direct_and_as_imports and config . combine_as_imports and parsed . imports [ section ][ \"from\" ][ module ][ from_import ] ) ): from_import_section . append ( from_imports . pop ( 0 )) if star_import : import_statement = import_start + ( \", \" ) . join ( from_import_section ) else : import_statement = with_comments ( comments , import_start + ( \", \" ) . join ( from_import_section ), removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) if not from_import_section : import_statement = \"\" do_multiline_reformat = False force_grid_wrap = config . force_grid_wrap if force_grid_wrap and len ( from_import_section ) >= force_grid_wrap : do_multiline_reformat = True if len ( import_statement ) > config . line_length and len ( from_import_section ) > 1 : do_multiline_reformat = True # If line too long AND have imports AND we are # NOT using GRID or VERTICAL wrap modes if ( len ( import_statement ) > config . line_length and len ( from_import_section ) > 0 and config . multi_line_output not in ( wrap . Modes . GRID , wrap . Modes . VERTICAL ) # type: ignore ): do_multiline_reformat = True if do_multiline_reformat : import_statement = wrap . import_statement ( import_start = import_start , from_imports = from_import_section , comments = comments , line_separator = parsed . line_separator , config = config , ) if config . multi_line_output == wrap . Modes . GRID : # type: ignore other_import_statement = wrap . import_statement ( import_start = import_start , from_imports = from_import_section , comments = comments , line_separator = parsed . line_separator , config = config , multi_line_output = wrap . Modes . VERTICAL_GRID , # type: ignore ) if max ( len ( x ) for x in import_statement . split ( \" \\n \" )) > config . line_length : import_statement = other_import_statement if not do_multiline_reformat and len ( import_statement ) > config . line_length : import_statement = wrap . line ( import_statement , parsed . line_separator , config ) if import_statement : above_comments = parsed . categorized_comments [ \"above\" ][ \"from\" ] . pop ( module , None ) if above_comments : # pragma: no cover if new_section_output and config . ensure_newline_before_comments : new_section_output . append ( \"\" ) new_section_output . extend ( above_comments ) new_section_output . append ( import_statement ) return new_section_output def _with_straight_imports ( parsed : parse . ParsedContent , config : Config , straight_modules : Iterable [ str ], section : str , section_output : List [ str ], remove_imports : List [ str ], import_type : str , ) -> List [ str ]: new_section_output = section_output . copy () for module in straight_modules : if module in remove_imports : continue import_definition = [] if module in parsed . as_map : if config . keep_direct_and_as_imports and parsed . imports [ section ][ \"straight\" ][ module ]: import_definition . append ( f \"{import_type} {module}\" ) import_definition . extend ( f \"{import_type} {module} as {as_import}\" for as_import in parsed . as_map [ module ] ) else : import_definition . append ( f \"{import_type} {module}\" ) comments_above = parsed . categorized_comments [ \"above\" ][ \"straight\" ] . pop ( module , None ) if comments_above : if new_section_output and config . ensure_newline_before_comments : new_section_output . append ( \"\" ) new_section_output . extend ( comments_above ) new_section_output . extend ( with_comments ( parsed . categorized_comments [ \"straight\" ] . get ( module ), idef , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) for idef in import_definition ) return new_section_output def _output_as_string ( lines : List [ str ], line_separator : str ) -> str : return line_separator . join ( _normalize_empty_lines ( lines )) def _normalize_empty_lines ( lines : List [ str ]) -> List [ str ]: while lines and lines [ - 1 ] . strip () == \"\" : lines . pop ( - 1 ) lines . append ( \"\" ) return lines","title":"Module isort.output"},{"location":"reference/isort/output/#variables","text":"STATEMENT_DECLERATIONS","title":"Variables"},{"location":"reference/isort/output/#functions","text":"","title":"Functions"},{"location":"reference/isort/output/#sorted_imports","text":"def sorted_imports ( parsed : isort . parse . ParsedContent , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ), extension : str = 'py' , import_type : str = 'import' ) -> str Adds the imports back to the file. (at the index of the first import) sorted alphabetically and split between groups View Source def sorted_imports ( parsed : parse . ParsedContent , config : Config = DEFAULT_CONFIG , extension : str = \"py\" , import_type : str = \"import\" , ) -> str : \"\"\"Adds the imports back to the file. ( at the index of the first import ) sorted alphabetically and split between groups \"\"\" if parsed . import_index == - 1 : return _output_as_string ( parsed . lines_without_imports , parsed . line_separator ) formatted_output : List [ str ] = parsed . lines_without_imports . copy () remove_imports = [ format_simplified ( removal ) for removal in config . remove_imports ] sort_ignore_case = config . force_alphabetical_sort_within_sections sections : Iterable [ str ] = itertools . chain ( parsed . sections , config . forced_separate ) if config . no_sections : parsed . imports [ \"no_sections\" ] = { \"straight\" : {}, \"from\" : {}} base_sections : Tuple [ str , ...] = () for section in sections : if section == \"FUTURE\" : base_sections = ( \"FUTURE\" ,) continue parsed . imports [ \"no_sections\" ][ \"straight\" ]. update ( parsed . imports [ section ]. get ( \"straight\" , {}) ) parsed . imports [ \"no_sections\" ][ \"from\" ]. update ( parsed . imports [ section ]. get ( \"from\" , {})) sections = base_sections + ( \"no_sections\" ,) output : List [ str ] = [] pending_lines_before = False for section in sections : straight_modules = parsed . imports [ section ][ \"straight\" ] straight_modules = sorting . naturally ( straight_modules , key = lambda key : sorting . module_key ( key , config , section_name = section ) ) from_modules = parsed . imports [ section ][ \"from\" ] from_modules = sorting . naturally ( from_modules , key = lambda key : sorting . module_key ( key , config , section_name = section ) ) if config . force_sort_within_sections : copied_comments = copy . deepcopy ( parsed . categorized_comments ) section_output : List [ str ] = [] if config . from_first : section_output = _with_from_imports ( parsed , config , from_modules , section , section_output , sort_ignore_case , remove_imports , import_type , ) if config . lines_between_types and from_modules and straight_modules : section_output . extend ([ \"\" ] * config . lines_between_types ) section_output = _with_straight_imports ( parsed , config , straight_modules , section , section_output , remove_imports , import_type , ) else : section_output = _with_straight_imports ( parsed , config , straight_modules , section , section_output , remove_imports , import_type , ) if config . lines_between_types and from_modules and straight_modules : section_output . extend ([ \"\" ] * config . lines_between_types ) section_output = _with_from_imports ( parsed , config , from_modules , section , section_output , sort_ignore_case , remove_imports , import_type , ) if config . force_sort_within_sections : # Remove comments section_output = [ line for line in section_output if not line . startswith ( \"#\" )] section_output = sorting . naturally ( section_output , key = partial ( sorting . section_key , order_by_type = config . order_by_type , force_to_top = config . force_to_top , lexicographical = config . lexicographical , length_sort = config . length_sort , ), ) # Add comments back all_comments = copied_comments [ \"above\" ][ \"from\" ] all_comments . update ( copied_comments [ \"above\" ][ \"straight\" ]) comment_indexes = {} for module , comment_list in all_comments . items () : for idx , line in enumerate ( section_output ) : if module in line : comment_indexes [ idx ] = comment_list added = 0 for idx , comment_list in comment_indexes . items () : for comment in comment_list : section_output . insert ( idx + added , comment ) added += 1 section_name = section no_lines_before = section_name in config . no_lines_before if section_output : if section_name in parsed . place_imports : parsed . place_imports [ section_name ] = section_output continue section_title = config . import_headings . get ( section_name . lower (), \"\" ) if section_title : section_comment = f \"# {section_title}\" if section_comment not in parsed . lines_without_imports [ 0 : 1 ] : section_output . insert ( 0 , section_comment ) if pending_lines_before or not no_lines_before : output += [ \"\" ] * config . lines_between_sections output += section_output pending_lines_before = False else : pending_lines_before = pending_lines_before or not no_lines_before while output and output [ - 1 ]. strip () == \"\" : output . pop () # pragma : no cover while output and output [ 0 ]. strip () == \"\" : output . pop ( 0 ) output_at = 0 if parsed . import_index < parsed . original_line_count : output_at = parsed . import_index formatted_output [ output_at : 0 ] = output imports_tail = output_at + len ( output ) while [ character . strip () for character in formatted_output [ imports_tail : imports_tail + 1 ] ] == [ \"\" ] : formatted_output . pop ( imports_tail ) if len ( formatted_output ) > imports_tail : next_construct = \"\" _in_quote : str = \"\" tail = formatted_output [ imports_tail :] for index , line in enumerate ( tail ) : in_quote = _in_quote should_skip , _in_quote , * _ = parse . skip_line ( line , in_quote = _in_quote , index = len ( formatted_output ), section_comments = parsed . section_comments , ) if not should_skip and line . strip () : if ( line . strip (). startswith ( \"#\" ) and len ( tail ) > ( index + 1 ) and tail [ index + 1 ]. strip () ) : continue next_construct = line break elif not in_quote : parts = line . split () if ( len ( parts ) >= 3 and parts [ 1 ] == \"=\" and \"'\" not in parts [ 0 ] and '\"' not in parts [ 0 ] ) : next_construct = line break if config . lines_after_imports != - 1 : formatted_output [ imports_tail : 0 ] = [ \"\" for line in range ( config . lines_after_imports )] elif extension != \"pyi\" and next_construct . startswith ( STATEMENT_DECLERATIONS ) : formatted_output [ imports_tail : 0 ] = [ \"\" , \"\" ] else : formatted_output [ imports_tail : 0 ] = [ \"\" ] if parsed . place_imports : new_out_lines = [] for index , line in enumerate ( formatted_output ) : new_out_lines . append ( line ) if line in parsed . import_placements : new_out_lines . extend ( parsed . place_imports [ parsed . import_placements [ line ]]) if len ( formatted_output ) <= index or formatted_output [ index + 1 ]. strip () != \"\" : new_out_lines . append ( \"\" ) formatted_output = new_out_lines return _output_as_string ( formatted_output , parsed . line_separator )","title":"sorted_imports"},{"location":"reference/isort/parse/","text":"Module isort.parse Defines parsing functions used by isort for parsing import definitions View Source \"\"\"Defines parsing functions used by isort for parsing import definitions\"\"\" from collections import OrderedDict , defaultdict from functools import partial from itertools import chain from typing import TYPE_CHECKING , Any , Dict , List , NamedTuple , Optional , Tuple from warnings import warn from . import place from .comments import parse as parse_comments from .deprecated.finders import FindersManager from .settings import DEFAULT_CONFIG , Config if TYPE_CHECKING : from mypy_extensions import TypedDict CommentsAboveDict = TypedDict ( \"CommentsAboveDict\" , { \"straight\" : Dict [ str , Any ], \"from\" : Dict [ str , Any ]} ) CommentsDict = TypedDict ( \"CommentsDict\" , { \"from\" : Dict [ str , Any ], \"straight\" : Dict [ str , Any ], \"nested\" : Dict [ str , Any ], \"above\" : CommentsAboveDict , }, ) def _infer_line_separator ( contents : str ) -> str : if \" \\r\\n \" in contents : return \" \\r\\n \" elif \" \\r \" in contents : return \" \\r \" else : return \" \\n \" def _normalize_line ( raw_line : str ) -> Tuple [ str , str ]: \"\"\"Normalizes import related statements in the provided line. Returns (normalized_line: str, raw_line: str) \"\"\" line = raw_line . replace ( \"from.import \" , \"from . import \" ) line = line . replace ( \"from.cimport \" , \"from . cimport \" ) line = line . replace ( \"import*\" , \"import *\" ) line = line . replace ( \" .import \" , \" . import \" ) line = line . replace ( \" .cimport \" , \" . cimport \" ) line = line . replace ( \" \\t \" , \" \" ) return ( line , raw_line ) def import_type ( line : str ) -> Optional [ str ]: \"\"\"If the current line is an import line it will return its type (from or straight)\"\"\" if \"isort:skip\" in line or \"isort: skip\" in line or \"NOQA\" in line : return None elif line . startswith (( \"import \" , \"cimport \" )): return \"straight\" elif line . startswith ( \"from \" ): return \"from\" return None def _strip_syntax ( import_string : str ) -> str : import_string = import_string . replace ( \"_import\" , \"[[i]]\" ) import_string = import_string . replace ( \"_cimport\" , \"[[ci]]\" ) for remove_syntax in [ \" \\\\ \" , \"(\" , \")\" , \",\" ]: import_string = import_string . replace ( remove_syntax , \" \" ) import_list = import_string . split () for key in ( \"from\" , \"import\" , \"cimport\" ): if key in import_list : import_list . remove ( key ) import_string = \" \" . join ( import_list ) import_string = import_string . replace ( \"[[i]]\" , \"_import\" ) import_string = import_string . replace ( \"[[ci]]\" , \"_cimport\" ) return import_string . replace ( \"{ \" , \"{|\" ) . replace ( \" }\" , \"|}\" ) def skip_line ( line : str , in_quote : str , index : int , section_comments : List [ str ] ) -> Tuple [ bool , str ]: \"\"\"Determine if a given line should be skipped. Returns back a tuple containing: (skip_line: bool, in_quote: str,) \"\"\" should_skip = bool ( in_quote ) if '\"' in line or \"'\" in line : char_index = 0 while char_index < len ( line ): if line [ char_index ] == \" \\\\ \" : char_index += 1 elif in_quote : if line [ char_index : char_index + len ( in_quote )] == in_quote : in_quote = \"\" elif line [ char_index ] in ( \"'\" , '\"' ): long_quote = line [ char_index : char_index + 3 ] if long_quote in ( '\"\"\"' , \"'''\" ): in_quote = long_quote char_index += 2 else : in_quote = line [ char_index ] elif line [ char_index ] == \"#\" : break char_index += 1 if \";\" in line : for part in ( part . strip () for part in line . split ( \";\" )): if ( part and not part . startswith ( \"from \" ) and not part . startswith (( \"import \" , \"cimport \" )) ): should_skip = True return ( bool ( should_skip or in_quote ), in_quote ) class ParsedContent ( NamedTuple ): in_lines : List [ str ] lines_without_imports : List [ str ] import_index : int place_imports : Dict [ str , List [ str ]] import_placements : Dict [ str , str ] as_map : Dict [ str , List [ str ]] imports : Dict [ str , Dict [ str , Any ]] categorized_comments : \"CommentsDict\" change_count : int original_line_count : int line_separator : str sections : Any section_comments : List [ str ] def file_contents ( contents : str , config : Config = DEFAULT_CONFIG ) -> ParsedContent : \"\"\"Parses a python file taking out and categorizing imports.\"\"\" line_separator : str = config . line_ending or _infer_line_separator ( contents ) in_lines = contents . split ( line_separator ) out_lines = [] original_line_count = len ( in_lines ) section_comments = [ f \"# {heading}\" for heading in config . import_headings . values ()] if config . old_finders : finder = FindersManager ( config = config ) . find else : finder = partial ( place . module , config = config ) line_count = len ( in_lines ) place_imports : Dict [ str , List [ str ]] = {} import_placements : Dict [ str , str ] = {} as_map : Dict [ str , List [ str ]] = defaultdict ( list ) imports : OrderedDict [ str , Dict [ str , Any ]] = OrderedDict () for section in chain ( config . sections , config . forced_separate ): imports [ section ] = { \"straight\" : OrderedDict (), \"from\" : OrderedDict ()} categorized_comments : CommentsDict = { \"from\" : {}, \"straight\" : {}, \"nested\" : {}, \"above\" : { \"straight\" : {}, \"from\" : {}}, } index = 0 import_index = - 1 in_quote = \"\" while index < line_count : line = in_lines [ index ] index += 1 statement_index = index ( skipping_line , in_quote ) = skip_line ( line , in_quote = in_quote , index = index , section_comments = section_comments ) if line in section_comments and not skipping_line : if import_index == - 1 : import_index = index - 1 continue if \"isort:imports-\" in line and line . startswith ( \"#\" ): section = line . split ( \"isort:imports-\" )[ - 1 ] . split ()[ 0 ] . upper () place_imports [ section ] = [] import_placements [ line ] = section elif \"isort: imports-\" in line and line . startswith ( \"#\" ): section = line . split ( \"isort: imports-\" )[ - 1 ] . split ()[ 0 ] . upper () place_imports [ section ] = [] import_placements [ line ] = section if skipping_line : out_lines . append ( line ) continue for line in ( ( line . strip () for line in line . split ( \";\" )) if \";\" in line else ( line ,) # type: ignore ): line , raw_line = _normalize_line ( line ) type_of_import = import_type ( line ) or \"\" if not type_of_import : out_lines . append ( raw_line ) continue if import_index == - 1 : import_index = index - 1 nested_comments = {} import_string , comment = parse_comments ( line ) comments = [ comment ] if comment else [] line_parts = [ part for part in _strip_syntax ( import_string ) . strip () . split ( \" \" ) if part ] if ( type_of_import == \"from\" and len ( line_parts ) == 2 and line_parts [ 1 ] != \"*\" and comments ): nested_comments [ line_parts [ - 1 ]] = comments [ 0 ] if \"(\" in line . split ( \"#\" )[ 0 ] and index < line_count : while not line . split ( \"#\" )[ 0 ] . strip () . endswith ( \")\" ) and index < line_count : line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) stripped_line = _strip_syntax ( line ) . strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line and new_comment ): nested_comments [ stripped_line ] = comments [ - 1 ] import_string += line_separator + line else : while line . strip () . endswith ( \" \\\\ \" ): line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) # Still need to check for parentheses after an escaped line if ( \"(\" in line . split ( \"#\" )[ 0 ] and \")\" not in line . split ( \"#\" )[ 0 ] and index < line_count ): stripped_line = _strip_syntax ( line ) . strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line and new_comment ): nested_comments [ stripped_line ] = comments [ - 1 ] import_string += line_separator + line while not line . split ( \"#\" )[ 0 ] . strip () . endswith ( \")\" ) and index < line_count : line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) stripped_line = _strip_syntax ( line ) . strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line and new_comment ): nested_comments [ stripped_line ] = comments [ - 1 ] import_string += line_separator + line stripped_line = _strip_syntax ( line ) . strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line and new_comment ): nested_comments [ stripped_line ] = comments [ - 1 ] if import_string . strip () . endswith ( ( \" import\" , \" cimport\" ) ) or line . strip () . startswith (( \"import \" , \"cimport \" )): import_string += line_separator + line else : import_string = import_string . rstrip () . rstrip ( \" \\\\ \" ) + \" \" + line . lstrip () if type_of_import == \"from\" : cimports : bool import_string = import_string . replace ( \"import(\" , \"import (\" ) if \" cimport \" in import_string : parts = import_string . split ( \" cimport \" ) cimports = True else : parts = import_string . split ( \" import \" ) cimports = False from_import = parts [ 0 ] . split ( \" \" ) import_string = ( \" cimport \" if cimports else \" import \" ) . join ( [ from_import [ 0 ] + \" \" + \"\" . join ( from_import [ 1 :])] + parts [ 1 :] ) just_imports = [ item . replace ( \"{|\" , \"{ \" ) . replace ( \"|}\" , \" }\" ) for item in _strip_syntax ( import_string ) . split () ] straight_import = True if \"as\" in just_imports and ( just_imports . index ( \"as\" ) + 1 ) < len ( just_imports ): straight_import = False while \"as\" in just_imports : as_index = just_imports . index ( \"as\" ) if type_of_import == \"from\" : module = just_imports [ 0 ] + \".\" + just_imports [ as_index - 1 ] as_name = just_imports [ as_index + 1 ] if as_name not in as_map [ module ]: as_map [ module ] . append ( as_name ) else : module = just_imports [ as_index - 1 ] as_name = just_imports [ as_index + 1 ] if as_name not in as_map [ module ]: as_map [ module ] . append ( as_name ) if \".\" in module : type_of_import = \"from\" just_imports [: as_index ] = module . rsplit ( \".\" , 1 ) as_index = just_imports . index ( \"as\" ) if not config . combine_as_imports : categorized_comments [ \"straight\" ][ module ] = comments comments = [] del just_imports [ as_index : as_index + 2 ] if type_of_import == \"from\" : import_from = just_imports . pop ( 0 ) placed_module = finder ( import_from ) if config . verbose : print ( f \"from-type place_module for {import_from} returned {placed_module}\" ) if placed_module == \"\" : warn ( f \"could not place module {import_from} of line {line} --\" \" Do you need to define a default section?\" ) root = imports [ placed_module ][ type_of_import ] # type: ignore for import_name in just_imports : associated_comment = nested_comments . get ( import_name ) if associated_comment : categorized_comments [ \"nested\" ] . setdefault ( import_from , {})[ import_name ] = associated_comment if associated_comment in comments : comments . pop ( comments . index ( associated_comment )) if comments : categorized_comments [ \"from\" ] . setdefault ( import_from , []) . extend ( comments ) if len ( out_lines ) > max ( import_index , 1 ) - 1 : last = out_lines and out_lines [ - 1 ] . rstrip () or \"\" while ( last . startswith ( \"#\" ) and not last . endswith ( '\"\"\"' ) and not last . endswith ( \"'''\" ) and \"isort:imports-\" not in last and \"isort: imports-\" not in last ): categorized_comments [ \"above\" ][ \"from\" ] . setdefault ( import_from , []) . insert ( 0 , out_lines . pop ( - 1 ) ) if len ( out_lines ) > max ( import_index - 1 , 1 ) - 1 : last = out_lines [ - 1 ] . rstrip () else : last = \"\" if statement_index - 1 == import_index : import_index -= len ( categorized_comments [ \"above\" ][ \"from\" ] . get ( import_from , []) ) if import_from not in root : root [ import_from ] = OrderedDict ( ( module , straight_import ) for module in just_imports ) else : root [ import_from ] . update ( ( module , straight_import | root [ import_from ] . get ( module , False )) for module in just_imports ) else : for module in just_imports : if comments : categorized_comments [ \"straight\" ][ module ] = comments comments = [] if len ( out_lines ) > max ( import_index , + 1 , 1 ) - 1 : last = out_lines and out_lines [ - 1 ] . rstrip () or \"\" while ( last . startswith ( \"#\" ) and not last . endswith ( '\"\"\"' ) and not last . endswith ( \"'''\" ) and \"isort:imports-\" not in last and \"isort: imports-\" not in last ): categorized_comments [ \"above\" ][ \"straight\" ] . setdefault ( module , []) . insert ( 0 , out_lines . pop ( - 1 ) ) if out_lines : last = out_lines [ - 1 ] . rstrip () else : last = \"\" if index - 1 == import_index : import_index -= len ( categorized_comments [ \"above\" ][ \"straight\" ] . get ( module , []) ) placed_module = finder ( module ) if config . verbose : print ( f \"else-type place_module for {module} returned {placed_module}\" ) if placed_module == \"\" : warn ( f \"could not place module {module} of line {line} --\" \" Do you need to define a default section?\" ) imports . setdefault ( \"\" , { \"straight\" : OrderedDict (), \"from\" : OrderedDict ()}) straight_import |= imports [ placed_module ][ type_of_import ] . get ( # type: ignore module , False ) imports [ placed_module ][ type_of_import ][ module ] = straight_import # type: ignore change_count = len ( out_lines ) - original_line_count return ParsedContent ( in_lines = in_lines , lines_without_imports = out_lines , import_index = import_index , place_imports = place_imports , import_placements = import_placements , as_map = as_map , imports = imports , categorized_comments = categorized_comments , change_count = change_count , original_line_count = original_line_count , line_separator = line_separator , sections = config . sections , section_comments = section_comments , ) Variables TYPE_CHECKING Functions file_contents def file_contents ( contents : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ) ) -> isort . parse . ParsedContent Parses a python file taking out and categorizing imports. View Source def file_contents ( contents : str , config : Config = DEFAULT_CONFIG ) -> ParsedContent : \"\"\"Parses a python file taking out and categorizing imports.\"\"\" line_separator : str = config . line_ending or _infer_line_separator ( contents ) in_lines = contents . split ( line_separator ) out_lines = [] original_line_count = len ( in_lines ) section_comments = [ f \"# { heading } \" for heading in config.import_headings.values()] if config . old_finders : finder = FindersManager ( config = config ). find else : finder = partial ( place . module , config = config ) line_count = len ( in_lines ) place_imports : Dict [ str , List [ str ]] = {} import_placements : Dict [ str , str ] = {} as_map : Dict [ str , List [ str ]] = defaultdict ( list ) imports : OrderedDict [ str , Dict [ str , Any ]] = OrderedDict () for section in chain ( config . sections , config . forced_separate ) : imports [ section ] = { \"straight\" : OrderedDict (), \"from\" : OrderedDict ()} categorized_comments : CommentsDict = { \"from\" : {}, \"straight\" : {}, \"nested\" : {}, \"above\" : { \"straight\" : {}, \"from\" : {}}, } index = 0 import_index = - 1 in_quote = \"\" while index < line_count : line = in_lines [ index ] index += 1 statement_index = index ( skipping_line , in_quote ) = skip_line ( line , in_quote = in_quote , index = index , section_comments = section_comments ) if line in section_comments and not skipping_line : if import_index == - 1 : import_index = index - 1 continue if \"isort:imports-\" in line and line . startswith ( \"#\" ) : section = line . split ( \"isort:imports-\" )[ - 1 ]. split ()[ 0 ]. upper () place_imports [ section ] = [] import_placements [ line ] = section elif \"isort: imports-\" in line and line . startswith ( \"#\" ) : section = line . split ( \"isort: imports-\" )[ - 1 ]. split ()[ 0 ]. upper () place_imports [ section ] = [] import_placements [ line ] = section if skipping_line : out_lines . append ( line ) continue for line in ( ( line . strip () for line in line . split ( \";\" )) if \";\" in line else ( line ,) # type : ignore ) : line , raw_line = _normalize_line ( line ) type_of_import = import_type ( line ) or \"\" if not type_of_import : out_lines . append ( raw_line ) continue if import_index == - 1 : import_index = index - 1 nested_comments = {} import_string , comment = parse_comments ( line ) comments = [ comment ] if comment else [] line_parts = [ part for part in _strip_syntax ( import_string ). strip (). split ( \" \" ) if part ] if ( type_of_import == \"from\" and len ( line_parts ) == 2 and line_parts [ 1 ] != \"*\" and comments ) : nested_comments [ line_parts [ - 1 ]] = comments [ 0 ] if \"(\" in line . split ( \"#\" )[ 0 ] and index < line_count : while not line . split ( \"#\" )[ 0 ]. strip (). endswith ( \")\" ) and index < line_count : line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) stripped_line = _strip_syntax ( line ). strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line and new_comment ) : nested_comments [ stripped_line ] = comments [ - 1 ] import_string += line_separator + line else : while line . strip (). endswith ( \" \\\\ \" ) : line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) # Still need to check for parentheses after an escaped line if ( \"(\" in line . split ( \"#\" )[ 0 ] and \")\" not in line . split ( \"#\" )[ 0 ] and index < line_count ) : stripped_line = _strip_syntax ( line ). strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line and new_comment ) : nested_comments [ stripped_line ] = comments [ - 1 ] import_string += line_separator + line while not line . split ( \"#\" )[ 0 ]. strip (). endswith ( \")\" ) and index < line_count : line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) stripped_line = _strip_syntax ( line ). strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line and new_comment ) : nested_comments [ stripped_line ] = comments [ - 1 ] import_string += line_separator + line stripped_line = _strip_syntax ( line ). strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line and new_comment ) : nested_comments [ stripped_line ] = comments [ - 1 ] if import_string . strip (). endswith ( ( \" import\" , \" cimport\" ) ) or line . strip (). startswith (( \"import \" , \"cimport \" )) : import_string += line_separator + line else : import_string = import_string . rstrip (). rstrip ( \" \\\\ \" ) + \" \" + line . lstrip () if type_of_import == \"from\" : cimports : bool import_string = import_string . replace ( \"import(\" , \"import (\" ) if \" cimport \" in import_string : parts = import_string . split ( \" cimport \" ) cimports = True else : parts = import_string . split ( \" import \" ) cimports = False from_import = parts [ 0 ]. split ( \" \" ) import_string = ( \" cimport \" if cimports else \" import \" ). join ( [ from_import [ 0 ] + \" \" + \"\" . join ( from_import [ 1 : ])] + parts [ 1 : ] ) just_imports = [ item . replace ( \"{|\" , \"{ \" ). replace ( \"|}\" , \" }\" ) for item in _strip_syntax ( import_string ). split () ] straight_import = True if \"as\" in just_imports and ( just_imports . index ( \"as\" ) + 1 ) < len ( just_imports ) : straight_import = False while \"as\" in just_imports : as_index = just_imports . index ( \"as\" ) if type_of_import == \"from\" : module = just_imports [ 0 ] + \".\" + just_imports [ as_index - 1 ] as_name = just_imports [ as_index + 1 ] if as_name not in as_map [ module ] : as_map [ module ]. append ( as_name ) else : module = just_imports [ as_index - 1 ] as_name = just_imports [ as_index + 1 ] if as_name not in as_map [ module ] : as_map [ module ]. append ( as_name ) if \".\" in module : type_of_import = \"from\" just_imports [ : as_index ] = module . rsplit ( \".\" , 1 ) as_index = just_imports . index ( \"as\" ) if not config . combine_as_imports : categorized_comments [ \"straight\" ][ module ] = comments comments = [] del just_imports [ as_index : as_index + 2 ] if type_of_import == \"from\" : import_from = just_imports . pop ( 0 ) placed_module = finder ( import_from ) if config . verbose : print ( f \"from-type place_module for {import_from} returned {placed_module}\" ) if placed_module == \"\" : warn ( f \"could not place module {import_from} of line {line} --\" \" Do you need to define a default section?\" ) root = imports [ placed_module ][ type_of_import ] # type : ignore for import_name in just_imports : associated_comment = nested_comments . get ( import_name ) if associated_comment : categorized_comments [ \"nested\" ]. setdefault ( import_from , {})[ import_name ] = associated_comment if associated_comment in comments : comments . pop ( comments . index ( associated_comment )) if comments : categorized_comments [ \"from\" ]. setdefault ( import_from , []). extend ( comments ) if len ( out_lines ) > max ( import_index , 1 ) - 1 : last = out_lines and out_lines [ - 1 ]. rstrip () or \"\" while ( last . startswith ( \"#\" ) and not last . endswith ( ' \"\"\"') and not last . endswith ( \"'''\" ) and \"isort:imports-\" not in last and \"isort: imports-\" not in last ) : categorized_comments [ \"above\" ][ \"from\" ]. setdefault ( import_from , []). insert ( 0 , out_lines . pop ( - 1 ) ) if len ( out_lines ) > max ( import_index - 1 , 1 ) - 1 : last = out_lines [ - 1 ]. rstrip () else : last = \"\" if statement_index - 1 == import_index : import_index -= len ( categorized_comments [ \"above\" ][ \"from\" ]. get ( import_from , []) ) if import_from not in root : root [ import_from ] = OrderedDict ( ( module , straight_import ) for module in just_imports ) else : root [ import_from ]. update ( ( module , straight_import | root [ import_from ]. get ( module , False )) for module in just_imports ) else : for module in just_imports : if comments : categorized_comments [ \"straight\" ][ module ] = comments comments = [] if len ( out_lines ) > max ( import_index , + 1 , 1 ) - 1 : last = out_lines and out_lines [ - 1 ]. rstrip () or \"\" while ( last . startswith ( \"#\" ) and not last . endswith ( ' \"\"\"') and not last . endswith ( \"'''\" ) and \"isort:imports-\" not in last and \"isort: imports-\" not in last ) : categorized_comments [ \"above\" ][ \"straight\" ]. setdefault ( module , []). insert ( 0 , out_lines . pop ( - 1 ) ) if out_lines : last = out_lines [ - 1 ]. rstrip () else : last = \"\" if index - 1 == import_index : import_index -= len ( categorized_comments [ \"above\" ][ \"straight\" ]. get ( module , []) ) placed_module = finder ( module ) if config . verbose : print ( f \"else-type place_module for {module} returned {placed_module}\" ) if placed_module == \"\" : warn ( f \"could not place module {module} of line {line} --\" \" Do you need to define a default section?\" ) imports . setdefault ( \"\" , { \"straight\" : OrderedDict (), \"from\" : OrderedDict ()}) straight_import |= imports [ placed_module ][ type_of_import ]. get ( # type : ignore module , False ) imports [ placed_module ][ type_of_import ][ module ] = straight_import # type : ignore change_count = len ( out_lines ) - original_line_count return ParsedContent ( in_lines = in_lines , lines_without_imports = out_lines , import_index = import_index , place_imports = place_imports , import_placements = import_placements , as_map = as_map , imports = imports , categorized_comments = categorized_comments , change_count = change_count , original_line_count = original_line_count , line_separator = line_separator , sections = config . sections , section_comments = section_comments , ) import_type def import_type ( line : str ) -> Union [ str , NoneType ] If the current line is an import line it will return its type (from or straight) View Source def import_type ( line : str ) -> Optional [ str ]: \"\"\"If the current line is an import line it will return its type (from or straight)\"\"\" if \"isort:skip\" in line or \"isort: skip\" in line or \"NOQA\" in line : return None elif line . startswith (( \"import \" , \"cimport \" )): return \"straight\" elif line . startswith ( \"from \" ): return \"from\" return None skip_line def skip_line ( line : str , in_quote : str , index : int , section_comments : List [ str ] ) -> Tuple [ bool , str ] Determine if a given line should be skipped. Returns back a tuple containing: (skip_line: bool, in_quote: str,) View Source def skip_line ( line : str , in_quote : str , index : int , section_comments : List [ str ] ) -> Tuple [ bool , str ] : \"\"\"Determine if a given line should be skipped. Returns back a tuple containing : ( skip_line : bool , in_quote : str ,) \"\"\" should_skip = bool ( in_quote ) if '\"' in line or \"'\" in line : char_index = 0 while char_index < len ( line ) : if line [ char_index ] == \" \\\\ \" : char_index += 1 elif in_quote : if line [ char_index : char_index + len ( in_quote )] == in_quote : in_quote = \"\" elif line [ char_index ] in ( \"'\" , '\"' ) : long_quote = line [ char_index : char_index + 3 ] if long_quote in ( ' \"\"\"', \" ''' \"): in_quote = long_quote char_index += 2 else : in_quote = line [ char_index ] elif line [ char_index ] == \"#\" : break char_index += 1 if \" ; \" in line: for part in ( part . strip () for part in line . split ( \" ; \")): if ( part and not part . startswith ( \"from \" ) and not part . startswith (( \"import \" , \"cimport \" )) ) : should_skip = True return ( bool ( should_skip or in_quote ), in_quote ) Classes ParsedContent class ParsedContent ( / , * args , ** kwargs ) ParsedContent(in_lines, lines_without_imports, import_index, place_imports, import_placements, as_map, imports, categorized_comments, change_count, original_line_count, line_separator, sections, section_comments) View Source class ParsedContent ( NamedTuple ) : in_lines : List [ str ] lines_without_imports : List [ str ] import_index : int place_imports : Dict [ str, List[str ] ] import_placements : Dict [ str, str ] as_map : Dict [ str, List[str ] ] imports : Dict [ str, Dict[str, Any ] ] categorized_comments : \"CommentsDict\" change_count : int original_line_count : int line_separator : str sections : Any section_comments : List [ str ] Ancestors (in MRO) builtins.tuple Class variables as_map categorized_comments change_count import_index import_placements imports in_lines line_separator lines_without_imports original_line_count place_imports section_comments sections Methods count def count ( self , value , / ) Return number of occurrences of value. index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"Parse"},{"location":"reference/isort/parse/#module-isortparse","text":"Defines parsing functions used by isort for parsing import definitions View Source \"\"\"Defines parsing functions used by isort for parsing import definitions\"\"\" from collections import OrderedDict , defaultdict from functools import partial from itertools import chain from typing import TYPE_CHECKING , Any , Dict , List , NamedTuple , Optional , Tuple from warnings import warn from . import place from .comments import parse as parse_comments from .deprecated.finders import FindersManager from .settings import DEFAULT_CONFIG , Config if TYPE_CHECKING : from mypy_extensions import TypedDict CommentsAboveDict = TypedDict ( \"CommentsAboveDict\" , { \"straight\" : Dict [ str , Any ], \"from\" : Dict [ str , Any ]} ) CommentsDict = TypedDict ( \"CommentsDict\" , { \"from\" : Dict [ str , Any ], \"straight\" : Dict [ str , Any ], \"nested\" : Dict [ str , Any ], \"above\" : CommentsAboveDict , }, ) def _infer_line_separator ( contents : str ) -> str : if \" \\r\\n \" in contents : return \" \\r\\n \" elif \" \\r \" in contents : return \" \\r \" else : return \" \\n \" def _normalize_line ( raw_line : str ) -> Tuple [ str , str ]: \"\"\"Normalizes import related statements in the provided line. Returns (normalized_line: str, raw_line: str) \"\"\" line = raw_line . replace ( \"from.import \" , \"from . import \" ) line = line . replace ( \"from.cimport \" , \"from . cimport \" ) line = line . replace ( \"import*\" , \"import *\" ) line = line . replace ( \" .import \" , \" . import \" ) line = line . replace ( \" .cimport \" , \" . cimport \" ) line = line . replace ( \" \\t \" , \" \" ) return ( line , raw_line ) def import_type ( line : str ) -> Optional [ str ]: \"\"\"If the current line is an import line it will return its type (from or straight)\"\"\" if \"isort:skip\" in line or \"isort: skip\" in line or \"NOQA\" in line : return None elif line . startswith (( \"import \" , \"cimport \" )): return \"straight\" elif line . startswith ( \"from \" ): return \"from\" return None def _strip_syntax ( import_string : str ) -> str : import_string = import_string . replace ( \"_import\" , \"[[i]]\" ) import_string = import_string . replace ( \"_cimport\" , \"[[ci]]\" ) for remove_syntax in [ \" \\\\ \" , \"(\" , \")\" , \",\" ]: import_string = import_string . replace ( remove_syntax , \" \" ) import_list = import_string . split () for key in ( \"from\" , \"import\" , \"cimport\" ): if key in import_list : import_list . remove ( key ) import_string = \" \" . join ( import_list ) import_string = import_string . replace ( \"[[i]]\" , \"_import\" ) import_string = import_string . replace ( \"[[ci]]\" , \"_cimport\" ) return import_string . replace ( \"{ \" , \"{|\" ) . replace ( \" }\" , \"|}\" ) def skip_line ( line : str , in_quote : str , index : int , section_comments : List [ str ] ) -> Tuple [ bool , str ]: \"\"\"Determine if a given line should be skipped. Returns back a tuple containing: (skip_line: bool, in_quote: str,) \"\"\" should_skip = bool ( in_quote ) if '\"' in line or \"'\" in line : char_index = 0 while char_index < len ( line ): if line [ char_index ] == \" \\\\ \" : char_index += 1 elif in_quote : if line [ char_index : char_index + len ( in_quote )] == in_quote : in_quote = \"\" elif line [ char_index ] in ( \"'\" , '\"' ): long_quote = line [ char_index : char_index + 3 ] if long_quote in ( '\"\"\"' , \"'''\" ): in_quote = long_quote char_index += 2 else : in_quote = line [ char_index ] elif line [ char_index ] == \"#\" : break char_index += 1 if \";\" in line : for part in ( part . strip () for part in line . split ( \";\" )): if ( part and not part . startswith ( \"from \" ) and not part . startswith (( \"import \" , \"cimport \" )) ): should_skip = True return ( bool ( should_skip or in_quote ), in_quote ) class ParsedContent ( NamedTuple ): in_lines : List [ str ] lines_without_imports : List [ str ] import_index : int place_imports : Dict [ str , List [ str ]] import_placements : Dict [ str , str ] as_map : Dict [ str , List [ str ]] imports : Dict [ str , Dict [ str , Any ]] categorized_comments : \"CommentsDict\" change_count : int original_line_count : int line_separator : str sections : Any section_comments : List [ str ] def file_contents ( contents : str , config : Config = DEFAULT_CONFIG ) -> ParsedContent : \"\"\"Parses a python file taking out and categorizing imports.\"\"\" line_separator : str = config . line_ending or _infer_line_separator ( contents ) in_lines = contents . split ( line_separator ) out_lines = [] original_line_count = len ( in_lines ) section_comments = [ f \"# {heading}\" for heading in config . import_headings . values ()] if config . old_finders : finder = FindersManager ( config = config ) . find else : finder = partial ( place . module , config = config ) line_count = len ( in_lines ) place_imports : Dict [ str , List [ str ]] = {} import_placements : Dict [ str , str ] = {} as_map : Dict [ str , List [ str ]] = defaultdict ( list ) imports : OrderedDict [ str , Dict [ str , Any ]] = OrderedDict () for section in chain ( config . sections , config . forced_separate ): imports [ section ] = { \"straight\" : OrderedDict (), \"from\" : OrderedDict ()} categorized_comments : CommentsDict = { \"from\" : {}, \"straight\" : {}, \"nested\" : {}, \"above\" : { \"straight\" : {}, \"from\" : {}}, } index = 0 import_index = - 1 in_quote = \"\" while index < line_count : line = in_lines [ index ] index += 1 statement_index = index ( skipping_line , in_quote ) = skip_line ( line , in_quote = in_quote , index = index , section_comments = section_comments ) if line in section_comments and not skipping_line : if import_index == - 1 : import_index = index - 1 continue if \"isort:imports-\" in line and line . startswith ( \"#\" ): section = line . split ( \"isort:imports-\" )[ - 1 ] . split ()[ 0 ] . upper () place_imports [ section ] = [] import_placements [ line ] = section elif \"isort: imports-\" in line and line . startswith ( \"#\" ): section = line . split ( \"isort: imports-\" )[ - 1 ] . split ()[ 0 ] . upper () place_imports [ section ] = [] import_placements [ line ] = section if skipping_line : out_lines . append ( line ) continue for line in ( ( line . strip () for line in line . split ( \";\" )) if \";\" in line else ( line ,) # type: ignore ): line , raw_line = _normalize_line ( line ) type_of_import = import_type ( line ) or \"\" if not type_of_import : out_lines . append ( raw_line ) continue if import_index == - 1 : import_index = index - 1 nested_comments = {} import_string , comment = parse_comments ( line ) comments = [ comment ] if comment else [] line_parts = [ part for part in _strip_syntax ( import_string ) . strip () . split ( \" \" ) if part ] if ( type_of_import == \"from\" and len ( line_parts ) == 2 and line_parts [ 1 ] != \"*\" and comments ): nested_comments [ line_parts [ - 1 ]] = comments [ 0 ] if \"(\" in line . split ( \"#\" )[ 0 ] and index < line_count : while not line . split ( \"#\" )[ 0 ] . strip () . endswith ( \")\" ) and index < line_count : line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) stripped_line = _strip_syntax ( line ) . strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line and new_comment ): nested_comments [ stripped_line ] = comments [ - 1 ] import_string += line_separator + line else : while line . strip () . endswith ( \" \\\\ \" ): line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) # Still need to check for parentheses after an escaped line if ( \"(\" in line . split ( \"#\" )[ 0 ] and \")\" not in line . split ( \"#\" )[ 0 ] and index < line_count ): stripped_line = _strip_syntax ( line ) . strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line and new_comment ): nested_comments [ stripped_line ] = comments [ - 1 ] import_string += line_separator + line while not line . split ( \"#\" )[ 0 ] . strip () . endswith ( \")\" ) and index < line_count : line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) stripped_line = _strip_syntax ( line ) . strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line and new_comment ): nested_comments [ stripped_line ] = comments [ - 1 ] import_string += line_separator + line stripped_line = _strip_syntax ( line ) . strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line and new_comment ): nested_comments [ stripped_line ] = comments [ - 1 ] if import_string . strip () . endswith ( ( \" import\" , \" cimport\" ) ) or line . strip () . startswith (( \"import \" , \"cimport \" )): import_string += line_separator + line else : import_string = import_string . rstrip () . rstrip ( \" \\\\ \" ) + \" \" + line . lstrip () if type_of_import == \"from\" : cimports : bool import_string = import_string . replace ( \"import(\" , \"import (\" ) if \" cimport \" in import_string : parts = import_string . split ( \" cimport \" ) cimports = True else : parts = import_string . split ( \" import \" ) cimports = False from_import = parts [ 0 ] . split ( \" \" ) import_string = ( \" cimport \" if cimports else \" import \" ) . join ( [ from_import [ 0 ] + \" \" + \"\" . join ( from_import [ 1 :])] + parts [ 1 :] ) just_imports = [ item . replace ( \"{|\" , \"{ \" ) . replace ( \"|}\" , \" }\" ) for item in _strip_syntax ( import_string ) . split () ] straight_import = True if \"as\" in just_imports and ( just_imports . index ( \"as\" ) + 1 ) < len ( just_imports ): straight_import = False while \"as\" in just_imports : as_index = just_imports . index ( \"as\" ) if type_of_import == \"from\" : module = just_imports [ 0 ] + \".\" + just_imports [ as_index - 1 ] as_name = just_imports [ as_index + 1 ] if as_name not in as_map [ module ]: as_map [ module ] . append ( as_name ) else : module = just_imports [ as_index - 1 ] as_name = just_imports [ as_index + 1 ] if as_name not in as_map [ module ]: as_map [ module ] . append ( as_name ) if \".\" in module : type_of_import = \"from\" just_imports [: as_index ] = module . rsplit ( \".\" , 1 ) as_index = just_imports . index ( \"as\" ) if not config . combine_as_imports : categorized_comments [ \"straight\" ][ module ] = comments comments = [] del just_imports [ as_index : as_index + 2 ] if type_of_import == \"from\" : import_from = just_imports . pop ( 0 ) placed_module = finder ( import_from ) if config . verbose : print ( f \"from-type place_module for {import_from} returned {placed_module}\" ) if placed_module == \"\" : warn ( f \"could not place module {import_from} of line {line} --\" \" Do you need to define a default section?\" ) root = imports [ placed_module ][ type_of_import ] # type: ignore for import_name in just_imports : associated_comment = nested_comments . get ( import_name ) if associated_comment : categorized_comments [ \"nested\" ] . setdefault ( import_from , {})[ import_name ] = associated_comment if associated_comment in comments : comments . pop ( comments . index ( associated_comment )) if comments : categorized_comments [ \"from\" ] . setdefault ( import_from , []) . extend ( comments ) if len ( out_lines ) > max ( import_index , 1 ) - 1 : last = out_lines and out_lines [ - 1 ] . rstrip () or \"\" while ( last . startswith ( \"#\" ) and not last . endswith ( '\"\"\"' ) and not last . endswith ( \"'''\" ) and \"isort:imports-\" not in last and \"isort: imports-\" not in last ): categorized_comments [ \"above\" ][ \"from\" ] . setdefault ( import_from , []) . insert ( 0 , out_lines . pop ( - 1 ) ) if len ( out_lines ) > max ( import_index - 1 , 1 ) - 1 : last = out_lines [ - 1 ] . rstrip () else : last = \"\" if statement_index - 1 == import_index : import_index -= len ( categorized_comments [ \"above\" ][ \"from\" ] . get ( import_from , []) ) if import_from not in root : root [ import_from ] = OrderedDict ( ( module , straight_import ) for module in just_imports ) else : root [ import_from ] . update ( ( module , straight_import | root [ import_from ] . get ( module , False )) for module in just_imports ) else : for module in just_imports : if comments : categorized_comments [ \"straight\" ][ module ] = comments comments = [] if len ( out_lines ) > max ( import_index , + 1 , 1 ) - 1 : last = out_lines and out_lines [ - 1 ] . rstrip () or \"\" while ( last . startswith ( \"#\" ) and not last . endswith ( '\"\"\"' ) and not last . endswith ( \"'''\" ) and \"isort:imports-\" not in last and \"isort: imports-\" not in last ): categorized_comments [ \"above\" ][ \"straight\" ] . setdefault ( module , []) . insert ( 0 , out_lines . pop ( - 1 ) ) if out_lines : last = out_lines [ - 1 ] . rstrip () else : last = \"\" if index - 1 == import_index : import_index -= len ( categorized_comments [ \"above\" ][ \"straight\" ] . get ( module , []) ) placed_module = finder ( module ) if config . verbose : print ( f \"else-type place_module for {module} returned {placed_module}\" ) if placed_module == \"\" : warn ( f \"could not place module {module} of line {line} --\" \" Do you need to define a default section?\" ) imports . setdefault ( \"\" , { \"straight\" : OrderedDict (), \"from\" : OrderedDict ()}) straight_import |= imports [ placed_module ][ type_of_import ] . get ( # type: ignore module , False ) imports [ placed_module ][ type_of_import ][ module ] = straight_import # type: ignore change_count = len ( out_lines ) - original_line_count return ParsedContent ( in_lines = in_lines , lines_without_imports = out_lines , import_index = import_index , place_imports = place_imports , import_placements = import_placements , as_map = as_map , imports = imports , categorized_comments = categorized_comments , change_count = change_count , original_line_count = original_line_count , line_separator = line_separator , sections = config . sections , section_comments = section_comments , )","title":"Module isort.parse"},{"location":"reference/isort/parse/#variables","text":"TYPE_CHECKING","title":"Variables"},{"location":"reference/isort/parse/#functions","text":"","title":"Functions"},{"location":"reference/isort/parse/#file_contents","text":"def file_contents ( contents : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ) ) -> isort . parse . ParsedContent Parses a python file taking out and categorizing imports. View Source def file_contents ( contents : str , config : Config = DEFAULT_CONFIG ) -> ParsedContent : \"\"\"Parses a python file taking out and categorizing imports.\"\"\" line_separator : str = config . line_ending or _infer_line_separator ( contents ) in_lines = contents . split ( line_separator ) out_lines = [] original_line_count = len ( in_lines ) section_comments = [ f \"# { heading } \" for heading in config.import_headings.values()] if config . old_finders : finder = FindersManager ( config = config ). find else : finder = partial ( place . module , config = config ) line_count = len ( in_lines ) place_imports : Dict [ str , List [ str ]] = {} import_placements : Dict [ str , str ] = {} as_map : Dict [ str , List [ str ]] = defaultdict ( list ) imports : OrderedDict [ str , Dict [ str , Any ]] = OrderedDict () for section in chain ( config . sections , config . forced_separate ) : imports [ section ] = { \"straight\" : OrderedDict (), \"from\" : OrderedDict ()} categorized_comments : CommentsDict = { \"from\" : {}, \"straight\" : {}, \"nested\" : {}, \"above\" : { \"straight\" : {}, \"from\" : {}}, } index = 0 import_index = - 1 in_quote = \"\" while index < line_count : line = in_lines [ index ] index += 1 statement_index = index ( skipping_line , in_quote ) = skip_line ( line , in_quote = in_quote , index = index , section_comments = section_comments ) if line in section_comments and not skipping_line : if import_index == - 1 : import_index = index - 1 continue if \"isort:imports-\" in line and line . startswith ( \"#\" ) : section = line . split ( \"isort:imports-\" )[ - 1 ]. split ()[ 0 ]. upper () place_imports [ section ] = [] import_placements [ line ] = section elif \"isort: imports-\" in line and line . startswith ( \"#\" ) : section = line . split ( \"isort: imports-\" )[ - 1 ]. split ()[ 0 ]. upper () place_imports [ section ] = [] import_placements [ line ] = section if skipping_line : out_lines . append ( line ) continue for line in ( ( line . strip () for line in line . split ( \";\" )) if \";\" in line else ( line ,) # type : ignore ) : line , raw_line = _normalize_line ( line ) type_of_import = import_type ( line ) or \"\" if not type_of_import : out_lines . append ( raw_line ) continue if import_index == - 1 : import_index = index - 1 nested_comments = {} import_string , comment = parse_comments ( line ) comments = [ comment ] if comment else [] line_parts = [ part for part in _strip_syntax ( import_string ). strip (). split ( \" \" ) if part ] if ( type_of_import == \"from\" and len ( line_parts ) == 2 and line_parts [ 1 ] != \"*\" and comments ) : nested_comments [ line_parts [ - 1 ]] = comments [ 0 ] if \"(\" in line . split ( \"#\" )[ 0 ] and index < line_count : while not line . split ( \"#\" )[ 0 ]. strip (). endswith ( \")\" ) and index < line_count : line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) stripped_line = _strip_syntax ( line ). strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line and new_comment ) : nested_comments [ stripped_line ] = comments [ - 1 ] import_string += line_separator + line else : while line . strip (). endswith ( \" \\\\ \" ) : line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) # Still need to check for parentheses after an escaped line if ( \"(\" in line . split ( \"#\" )[ 0 ] and \")\" not in line . split ( \"#\" )[ 0 ] and index < line_count ) : stripped_line = _strip_syntax ( line ). strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line and new_comment ) : nested_comments [ stripped_line ] = comments [ - 1 ] import_string += line_separator + line while not line . split ( \"#\" )[ 0 ]. strip (). endswith ( \")\" ) and index < line_count : line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) stripped_line = _strip_syntax ( line ). strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line and new_comment ) : nested_comments [ stripped_line ] = comments [ - 1 ] import_string += line_separator + line stripped_line = _strip_syntax ( line ). strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line and new_comment ) : nested_comments [ stripped_line ] = comments [ - 1 ] if import_string . strip (). endswith ( ( \" import\" , \" cimport\" ) ) or line . strip (). startswith (( \"import \" , \"cimport \" )) : import_string += line_separator + line else : import_string = import_string . rstrip (). rstrip ( \" \\\\ \" ) + \" \" + line . lstrip () if type_of_import == \"from\" : cimports : bool import_string = import_string . replace ( \"import(\" , \"import (\" ) if \" cimport \" in import_string : parts = import_string . split ( \" cimport \" ) cimports = True else : parts = import_string . split ( \" import \" ) cimports = False from_import = parts [ 0 ]. split ( \" \" ) import_string = ( \" cimport \" if cimports else \" import \" ). join ( [ from_import [ 0 ] + \" \" + \"\" . join ( from_import [ 1 : ])] + parts [ 1 : ] ) just_imports = [ item . replace ( \"{|\" , \"{ \" ). replace ( \"|}\" , \" }\" ) for item in _strip_syntax ( import_string ). split () ] straight_import = True if \"as\" in just_imports and ( just_imports . index ( \"as\" ) + 1 ) < len ( just_imports ) : straight_import = False while \"as\" in just_imports : as_index = just_imports . index ( \"as\" ) if type_of_import == \"from\" : module = just_imports [ 0 ] + \".\" + just_imports [ as_index - 1 ] as_name = just_imports [ as_index + 1 ] if as_name not in as_map [ module ] : as_map [ module ]. append ( as_name ) else : module = just_imports [ as_index - 1 ] as_name = just_imports [ as_index + 1 ] if as_name not in as_map [ module ] : as_map [ module ]. append ( as_name ) if \".\" in module : type_of_import = \"from\" just_imports [ : as_index ] = module . rsplit ( \".\" , 1 ) as_index = just_imports . index ( \"as\" ) if not config . combine_as_imports : categorized_comments [ \"straight\" ][ module ] = comments comments = [] del just_imports [ as_index : as_index + 2 ] if type_of_import == \"from\" : import_from = just_imports . pop ( 0 ) placed_module = finder ( import_from ) if config . verbose : print ( f \"from-type place_module for {import_from} returned {placed_module}\" ) if placed_module == \"\" : warn ( f \"could not place module {import_from} of line {line} --\" \" Do you need to define a default section?\" ) root = imports [ placed_module ][ type_of_import ] # type : ignore for import_name in just_imports : associated_comment = nested_comments . get ( import_name ) if associated_comment : categorized_comments [ \"nested\" ]. setdefault ( import_from , {})[ import_name ] = associated_comment if associated_comment in comments : comments . pop ( comments . index ( associated_comment )) if comments : categorized_comments [ \"from\" ]. setdefault ( import_from , []). extend ( comments ) if len ( out_lines ) > max ( import_index , 1 ) - 1 : last = out_lines and out_lines [ - 1 ]. rstrip () or \"\" while ( last . startswith ( \"#\" ) and not last . endswith ( ' \"\"\"') and not last . endswith ( \"'''\" ) and \"isort:imports-\" not in last and \"isort: imports-\" not in last ) : categorized_comments [ \"above\" ][ \"from\" ]. setdefault ( import_from , []). insert ( 0 , out_lines . pop ( - 1 ) ) if len ( out_lines ) > max ( import_index - 1 , 1 ) - 1 : last = out_lines [ - 1 ]. rstrip () else : last = \"\" if statement_index - 1 == import_index : import_index -= len ( categorized_comments [ \"above\" ][ \"from\" ]. get ( import_from , []) ) if import_from not in root : root [ import_from ] = OrderedDict ( ( module , straight_import ) for module in just_imports ) else : root [ import_from ]. update ( ( module , straight_import | root [ import_from ]. get ( module , False )) for module in just_imports ) else : for module in just_imports : if comments : categorized_comments [ \"straight\" ][ module ] = comments comments = [] if len ( out_lines ) > max ( import_index , + 1 , 1 ) - 1 : last = out_lines and out_lines [ - 1 ]. rstrip () or \"\" while ( last . startswith ( \"#\" ) and not last . endswith ( ' \"\"\"') and not last . endswith ( \"'''\" ) and \"isort:imports-\" not in last and \"isort: imports-\" not in last ) : categorized_comments [ \"above\" ][ \"straight\" ]. setdefault ( module , []). insert ( 0 , out_lines . pop ( - 1 ) ) if out_lines : last = out_lines [ - 1 ]. rstrip () else : last = \"\" if index - 1 == import_index : import_index -= len ( categorized_comments [ \"above\" ][ \"straight\" ]. get ( module , []) ) placed_module = finder ( module ) if config . verbose : print ( f \"else-type place_module for {module} returned {placed_module}\" ) if placed_module == \"\" : warn ( f \"could not place module {module} of line {line} --\" \" Do you need to define a default section?\" ) imports . setdefault ( \"\" , { \"straight\" : OrderedDict (), \"from\" : OrderedDict ()}) straight_import |= imports [ placed_module ][ type_of_import ]. get ( # type : ignore module , False ) imports [ placed_module ][ type_of_import ][ module ] = straight_import # type : ignore change_count = len ( out_lines ) - original_line_count return ParsedContent ( in_lines = in_lines , lines_without_imports = out_lines , import_index = import_index , place_imports = place_imports , import_placements = import_placements , as_map = as_map , imports = imports , categorized_comments = categorized_comments , change_count = change_count , original_line_count = original_line_count , line_separator = line_separator , sections = config . sections , section_comments = section_comments , )","title":"file_contents"},{"location":"reference/isort/parse/#import_type","text":"def import_type ( line : str ) -> Union [ str , NoneType ] If the current line is an import line it will return its type (from or straight) View Source def import_type ( line : str ) -> Optional [ str ]: \"\"\"If the current line is an import line it will return its type (from or straight)\"\"\" if \"isort:skip\" in line or \"isort: skip\" in line or \"NOQA\" in line : return None elif line . startswith (( \"import \" , \"cimport \" )): return \"straight\" elif line . startswith ( \"from \" ): return \"from\" return None","title":"import_type"},{"location":"reference/isort/parse/#skip_line","text":"def skip_line ( line : str , in_quote : str , index : int , section_comments : List [ str ] ) -> Tuple [ bool , str ] Determine if a given line should be skipped. Returns back a tuple containing: (skip_line: bool, in_quote: str,) View Source def skip_line ( line : str , in_quote : str , index : int , section_comments : List [ str ] ) -> Tuple [ bool , str ] : \"\"\"Determine if a given line should be skipped. Returns back a tuple containing : ( skip_line : bool , in_quote : str ,) \"\"\" should_skip = bool ( in_quote ) if '\"' in line or \"'\" in line : char_index = 0 while char_index < len ( line ) : if line [ char_index ] == \" \\\\ \" : char_index += 1 elif in_quote : if line [ char_index : char_index + len ( in_quote )] == in_quote : in_quote = \"\" elif line [ char_index ] in ( \"'\" , '\"' ) : long_quote = line [ char_index : char_index + 3 ] if long_quote in ( ' \"\"\"', \" ''' \"): in_quote = long_quote char_index += 2 else : in_quote = line [ char_index ] elif line [ char_index ] == \"#\" : break char_index += 1 if \" ; \" in line: for part in ( part . strip () for part in line . split ( \" ; \")): if ( part and not part . startswith ( \"from \" ) and not part . startswith (( \"import \" , \"cimport \" )) ) : should_skip = True return ( bool ( should_skip or in_quote ), in_quote )","title":"skip_line"},{"location":"reference/isort/parse/#classes","text":"","title":"Classes"},{"location":"reference/isort/parse/#parsedcontent","text":"class ParsedContent ( / , * args , ** kwargs ) ParsedContent(in_lines, lines_without_imports, import_index, place_imports, import_placements, as_map, imports, categorized_comments, change_count, original_line_count, line_separator, sections, section_comments) View Source class ParsedContent ( NamedTuple ) : in_lines : List [ str ] lines_without_imports : List [ str ] import_index : int place_imports : Dict [ str, List[str ] ] import_placements : Dict [ str, str ] as_map : Dict [ str, List[str ] ] imports : Dict [ str, Dict[str, Any ] ] categorized_comments : \"CommentsDict\" change_count : int original_line_count : int line_separator : str sections : Any section_comments : List [ str ]","title":"ParsedContent"},{"location":"reference/isort/parse/#ancestors-in-mro","text":"builtins.tuple","title":"Ancestors (in MRO)"},{"location":"reference/isort/parse/#class-variables","text":"as_map categorized_comments change_count import_index import_placements imports in_lines line_separator lines_without_imports original_line_count place_imports section_comments sections","title":"Class variables"},{"location":"reference/isort/parse/#methods","text":"","title":"Methods"},{"location":"reference/isort/parse/#count","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/isort/parse/#index","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/isort/place/","text":"Module isort.place Contains all logic related to placing an import within a certain section. View Source \"\"\"Contains all logic related to placing an import within a certain section.\"\"\" import importlib from fnmatch import fnmatch from functools import lru_cache from pathlib import Path from typing import Dict , Optional , Tuple from isort import sections from isort.settings import DEFAULT_CONFIG , Config from isort.utils import exists_case_sensitive LOCAL = \"LOCALFOLDER\" def module ( name : str , config : Config = DEFAULT_CONFIG ) -> str : \"\"\"Returns the section placement for the given module name.\"\"\" return module_with_reason ( name , config )[ 0 ] @lru_cache ( maxsize = 1000 ) def module_with_reason ( name : str , config : Config = DEFAULT_CONFIG ) -> Tuple [ str , str ]: \"\"\"Returns the section placement for the given module name alongside the reasoning.\"\"\" return ( _forced_separate ( name , config ) or _local ( name , config ) or _known_pattern ( name , config ) or _src_path ( name , config ) or ( config . default_section , \"Default option in Config or universal default.\" ) ) def _forced_separate ( name : str , config : Config ) -> Optional [ Tuple [ str , str ]]: for forced_separate in config . forced_separate : # Ensure all forced_separate patterns will match to end of string path_glob = forced_separate if not forced_separate . endswith ( \"*\" ): path_glob = \" %s *\" % forced_separate if fnmatch ( name , path_glob ) or fnmatch ( name , \".\" + path_glob ): return ( forced_separate , f \"Matched forced_separate ({forced_separate}) config value.\" ) return None def _local ( name : str , config : Config ) -> Optional [ Tuple [ str , str ]]: if name . startswith ( \".\" ): return ( LOCAL , \"Module name started with a dot.\" ) return None def _known_pattern ( name : str , config : Config ) -> Optional [ Tuple [ str , str ]]: parts = name . split ( \".\" ) module_names_to_check = ( \".\" . join ( parts [: first_k ]) for first_k in range ( len ( parts ), 0 , - 1 )) for module_name_to_check in module_names_to_check : for pattern , placement in config . known_patterns : if pattern . match ( module_name_to_check ): return ( placement , f \"Matched configured known pattern {pattern}\" ) return None def _src_path ( name : str , config : Config ) -> Optional [ Tuple [ str , str ]]: for src_path in config . src_paths : root_module_name = name . split ( \".\" )[ 0 ] module_path = ( src_path / root_module_name ) . resolve () if ( _is_module ( module_path ) or _is_package ( module_path ) or _src_path_is_module ( src_path , root_module_name ) ): return ( sections . FIRSTPARTY , f \"Found in one of the configured src_paths: {src_path}.\" ) return None def _is_module ( path : Path ) -> bool : return ( exists_case_sensitive ( str ( path . with_suffix ( \".py\" ))) or any ( exists_case_sensitive ( str ( path . with_suffix ( ext_suffix ))) for ext_suffix in importlib . machinery . EXTENSION_SUFFIXES ) or exists_case_sensitive ( str ( path / \"__init__.py\" )) ) def _is_package ( path : Path ) -> bool : return exists_case_sensitive ( str ( path )) and path . is_dir () def _src_path_is_module ( src_path : Path , module_name : str ) -> bool : return ( module_name == src_path . name and src_path . is_dir () and exists_case_sensitive ( str ( src_path )) ) Variables LOCAL Functions module def module ( name : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ) ) -> str Returns the section placement for the given module name. View Source def module ( name : str , config : Config = DEFAULT_CONFIG ) -> str : \"\"\"Returns the section placement for the given module name.\"\"\" return module_with_reason ( name , config )[ 0 ] module_with_reason def module_with_reason ( name : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ) ) -> Tuple [ str , str ] Returns the section placement for the given module name alongside the reasoning. View Source @ lru_cache ( maxsize = 1000 ) def module_with_reason ( name : str , config : Config = DEFAULT_CONFIG ) -> Tuple [ str , str ] : \"\"\"Returns the section placement for the given module name alongside the reasoning.\"\"\" return ( _forced_separate(name, config) or _local(name, config) or _known_pattern(name, config) or _src_path(name, config) or (config.default_section, \"Default option in Config or universal default.\") )","title":"Place"},{"location":"reference/isort/place/#module-isortplace","text":"Contains all logic related to placing an import within a certain section. View Source \"\"\"Contains all logic related to placing an import within a certain section.\"\"\" import importlib from fnmatch import fnmatch from functools import lru_cache from pathlib import Path from typing import Dict , Optional , Tuple from isort import sections from isort.settings import DEFAULT_CONFIG , Config from isort.utils import exists_case_sensitive LOCAL = \"LOCALFOLDER\" def module ( name : str , config : Config = DEFAULT_CONFIG ) -> str : \"\"\"Returns the section placement for the given module name.\"\"\" return module_with_reason ( name , config )[ 0 ] @lru_cache ( maxsize = 1000 ) def module_with_reason ( name : str , config : Config = DEFAULT_CONFIG ) -> Tuple [ str , str ]: \"\"\"Returns the section placement for the given module name alongside the reasoning.\"\"\" return ( _forced_separate ( name , config ) or _local ( name , config ) or _known_pattern ( name , config ) or _src_path ( name , config ) or ( config . default_section , \"Default option in Config or universal default.\" ) ) def _forced_separate ( name : str , config : Config ) -> Optional [ Tuple [ str , str ]]: for forced_separate in config . forced_separate : # Ensure all forced_separate patterns will match to end of string path_glob = forced_separate if not forced_separate . endswith ( \"*\" ): path_glob = \" %s *\" % forced_separate if fnmatch ( name , path_glob ) or fnmatch ( name , \".\" + path_glob ): return ( forced_separate , f \"Matched forced_separate ({forced_separate}) config value.\" ) return None def _local ( name : str , config : Config ) -> Optional [ Tuple [ str , str ]]: if name . startswith ( \".\" ): return ( LOCAL , \"Module name started with a dot.\" ) return None def _known_pattern ( name : str , config : Config ) -> Optional [ Tuple [ str , str ]]: parts = name . split ( \".\" ) module_names_to_check = ( \".\" . join ( parts [: first_k ]) for first_k in range ( len ( parts ), 0 , - 1 )) for module_name_to_check in module_names_to_check : for pattern , placement in config . known_patterns : if pattern . match ( module_name_to_check ): return ( placement , f \"Matched configured known pattern {pattern}\" ) return None def _src_path ( name : str , config : Config ) -> Optional [ Tuple [ str , str ]]: for src_path in config . src_paths : root_module_name = name . split ( \".\" )[ 0 ] module_path = ( src_path / root_module_name ) . resolve () if ( _is_module ( module_path ) or _is_package ( module_path ) or _src_path_is_module ( src_path , root_module_name ) ): return ( sections . FIRSTPARTY , f \"Found in one of the configured src_paths: {src_path}.\" ) return None def _is_module ( path : Path ) -> bool : return ( exists_case_sensitive ( str ( path . with_suffix ( \".py\" ))) or any ( exists_case_sensitive ( str ( path . with_suffix ( ext_suffix ))) for ext_suffix in importlib . machinery . EXTENSION_SUFFIXES ) or exists_case_sensitive ( str ( path / \"__init__.py\" )) ) def _is_package ( path : Path ) -> bool : return exists_case_sensitive ( str ( path )) and path . is_dir () def _src_path_is_module ( src_path : Path , module_name : str ) -> bool : return ( module_name == src_path . name and src_path . is_dir () and exists_case_sensitive ( str ( src_path )) )","title":"Module isort.place"},{"location":"reference/isort/place/#variables","text":"LOCAL","title":"Variables"},{"location":"reference/isort/place/#functions","text":"","title":"Functions"},{"location":"reference/isort/place/#module","text":"def module ( name : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ) ) -> str Returns the section placement for the given module name. View Source def module ( name : str , config : Config = DEFAULT_CONFIG ) -> str : \"\"\"Returns the section placement for the given module name.\"\"\" return module_with_reason ( name , config )[ 0 ]","title":"module"},{"location":"reference/isort/place/#module_with_reason","text":"def module_with_reason ( name : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ) ) -> Tuple [ str , str ] Returns the section placement for the given module name alongside the reasoning. View Source @ lru_cache ( maxsize = 1000 ) def module_with_reason ( name : str , config : Config = DEFAULT_CONFIG ) -> Tuple [ str , str ] : \"\"\"Returns the section placement for the given module name alongside the reasoning.\"\"\" return ( _forced_separate(name, config) or _local(name, config) or _known_pattern(name, config) or _src_path(name, config) or (config.default_section, \"Default option in Config or universal default.\") )","title":"module_with_reason"},{"location":"reference/isort/profiles/","text":"Module isort.profiles Common profiles are defined here to be easily used within a project using --profile {name} View Source \"\"\"Common profiles are defined here to be easily used within a project using --profile {name}\"\"\" from typing import Any , Dict black = { \"multi_line_output\" : 3 , \"include_trailing_comma\" : True , \"force_grid_wrap\" : 0 , \"use_parentheses\" : True , \"ensure_newline_before_comments\" : True , \"line_length\" : 88 , } django = { \"combine_as_imports\" : True , \"include_trailing_comma\" : True , \"multi_line_output\" : 5 , \"line_length\" : 79 , } pycharm = { \"multi_line_output\" : 3 , \"force_grid_wrap\" : 2 } google = { \"force_single_line\" : True , \"force_sort_within_sections\" : True , \"lexicographical\" : True , \"single_line_exclusions\" : ( \"typing\" ,), } open_stack = { \"force_single_line\" : True , \"force_sort_within_sections\" : True , \"lexicographical\" : True , } plone = { \"force_alphabetical_sort\" : True , \"force_single_line\" : True , \"ines_after_imports\" : 2 , \"line_length\" : 200 , } attrs = { \"atomic\" : True , \"force_grid_wrap\" : 0 , \"include_trailing_comma\" : True , \"lines_after_imports\" : 2 , \"lines_between_types\" : 1 , \"multi_line_output\" : 3 , \"not_skip\" : \"__init__.py\" , \"use_parentheses\" : True , } hug = { \"multi_line_output\" : 3 , \"include_trailing_comma\" : True , \"force_grid_wrap\" : 0 , \"use_parentheses\" : True , \"line_length\" : 100 , } profiles : Dict [ str , Dict [ str , Any ]] = { \"black\" : black , \"django\" : django , \"pycharm\" : pycharm , \"google\" : google , \"open_stack\" : open_stack , \"plone\" : plone , \"attrs\" : attrs , \"hug\" : hug , } Variables attrs black django google hug open_stack plone profiles pycharm","title":"Profiles"},{"location":"reference/isort/profiles/#module-isortprofiles","text":"Common profiles are defined here to be easily used within a project using --profile {name} View Source \"\"\"Common profiles are defined here to be easily used within a project using --profile {name}\"\"\" from typing import Any , Dict black = { \"multi_line_output\" : 3 , \"include_trailing_comma\" : True , \"force_grid_wrap\" : 0 , \"use_parentheses\" : True , \"ensure_newline_before_comments\" : True , \"line_length\" : 88 , } django = { \"combine_as_imports\" : True , \"include_trailing_comma\" : True , \"multi_line_output\" : 5 , \"line_length\" : 79 , } pycharm = { \"multi_line_output\" : 3 , \"force_grid_wrap\" : 2 } google = { \"force_single_line\" : True , \"force_sort_within_sections\" : True , \"lexicographical\" : True , \"single_line_exclusions\" : ( \"typing\" ,), } open_stack = { \"force_single_line\" : True , \"force_sort_within_sections\" : True , \"lexicographical\" : True , } plone = { \"force_alphabetical_sort\" : True , \"force_single_line\" : True , \"ines_after_imports\" : 2 , \"line_length\" : 200 , } attrs = { \"atomic\" : True , \"force_grid_wrap\" : 0 , \"include_trailing_comma\" : True , \"lines_after_imports\" : 2 , \"lines_between_types\" : 1 , \"multi_line_output\" : 3 , \"not_skip\" : \"__init__.py\" , \"use_parentheses\" : True , } hug = { \"multi_line_output\" : 3 , \"include_trailing_comma\" : True , \"force_grid_wrap\" : 0 , \"use_parentheses\" : True , \"line_length\" : 100 , } profiles : Dict [ str , Dict [ str , Any ]] = { \"black\" : black , \"django\" : django , \"pycharm\" : pycharm , \"google\" : google , \"open_stack\" : open_stack , \"plone\" : plone , \"attrs\" : attrs , \"hug\" : hug , }","title":"Module isort.profiles"},{"location":"reference/isort/profiles/#variables","text":"attrs black django google hug open_stack plone profiles pycharm","title":"Variables"},{"location":"reference/isort/pylama_isort/","text":"Module isort.pylama_isort View Source import os import sys from contextlib import contextmanager from typing import Any , Dict , List from pylama.lint import Linter as BaseLinter from . import api @contextmanager def supress_stdout (): stdout = sys . stdout with open ( os . devnull , \"w\" ) as devnull : sys . stdout = devnull yield sys . stdout = stdout class Linter ( BaseLinter ): def allow ( self , path : str ) -> bool : \"\"\"Determine if this path should be linted.\"\"\" return path . endswith ( \".py\" ) def run ( self , path : str , ** meta : Any ) -> List [ Dict [ str , Any ]]: \"\"\"Lint the file. Return an array of error dicts if appropriate.\"\"\" with supress_stdout (): if not api . check_file ( path ): return [ { \"lnum\" : 0 , \"col\" : 0 , \"text\" : \"Incorrectly sorted imports.\" , \"type\" : \"ISORT\" } ] else : return [] Functions supress_stdout def supress_stdout ( ) View Source @contextmanager def supress_stdout () : stdout = sys . stdout with open ( os . devnull , \"w\" ) as devnull : sys . stdout = devnull yield sys . stdout = stdout Classes Linter class Linter ( / , * args , ** kwargs ) Abstract class for linter plugin. View Source class Linter ( BaseLinter ): def allow ( self , path: str ) -> bool: \"\"\"Determine if this path should be linted.\"\"\" return path . endswith ( \".py\" ) def run ( self , path: str , ** meta: Any ) -> List [ Dict [ str , Any ]]: \"\"\"Lint the file. Return an array of error dicts if appropriate.\"\"\" with supress_stdout (): if not api . check_file ( path ): return [ { \"lnum\" : 0 , \"col\" : 0 , \"text\" : \"Incorrectly sorted imports.\" , \"type\" : \"ISORT\" } ] else: return [] Ancestors (in MRO) pylama.lint.Linter Methods allow def allow ( self , path : str ) -> bool Determine if this path should be linted. View Source def allow ( self , path : str ) -> bool : \"\"\"Determine if this path should be linted.\"\"\" return path . endswith ( \".py\" ) run def run ( self , path : str , ** meta : Any ) -> List [ Dict [ str , Any ]] Lint the file. Return an array of error dicts if appropriate. View Source def run ( self , path : str , ** meta : Any ) -> List [ Dict [ str , Any ]]: \"\"\"Lint the file. Return an array of error dicts if appropriate.\"\"\" with supress_stdout (): if not api . check_file ( path ): return [ { \"lnum\" : 0 , \"col\" : 0 , \"text\" : \"Incorrectly sorted imports.\" , \"type\" : \"ISORT\" } ] else : return []","title":"Pylama Isort"},{"location":"reference/isort/pylama_isort/#module-isortpylama_isort","text":"View Source import os import sys from contextlib import contextmanager from typing import Any , Dict , List from pylama.lint import Linter as BaseLinter from . import api @contextmanager def supress_stdout (): stdout = sys . stdout with open ( os . devnull , \"w\" ) as devnull : sys . stdout = devnull yield sys . stdout = stdout class Linter ( BaseLinter ): def allow ( self , path : str ) -> bool : \"\"\"Determine if this path should be linted.\"\"\" return path . endswith ( \".py\" ) def run ( self , path : str , ** meta : Any ) -> List [ Dict [ str , Any ]]: \"\"\"Lint the file. Return an array of error dicts if appropriate.\"\"\" with supress_stdout (): if not api . check_file ( path ): return [ { \"lnum\" : 0 , \"col\" : 0 , \"text\" : \"Incorrectly sorted imports.\" , \"type\" : \"ISORT\" } ] else : return []","title":"Module isort.pylama_isort"},{"location":"reference/isort/pylama_isort/#functions","text":"","title":"Functions"},{"location":"reference/isort/pylama_isort/#supress_stdout","text":"def supress_stdout ( ) View Source @contextmanager def supress_stdout () : stdout = sys . stdout with open ( os . devnull , \"w\" ) as devnull : sys . stdout = devnull yield sys . stdout = stdout","title":"supress_stdout"},{"location":"reference/isort/pylama_isort/#classes","text":"","title":"Classes"},{"location":"reference/isort/pylama_isort/#linter","text":"class Linter ( / , * args , ** kwargs ) Abstract class for linter plugin. View Source class Linter ( BaseLinter ): def allow ( self , path: str ) -> bool: \"\"\"Determine if this path should be linted.\"\"\" return path . endswith ( \".py\" ) def run ( self , path: str , ** meta: Any ) -> List [ Dict [ str , Any ]]: \"\"\"Lint the file. Return an array of error dicts if appropriate.\"\"\" with supress_stdout (): if not api . check_file ( path ): return [ { \"lnum\" : 0 , \"col\" : 0 , \"text\" : \"Incorrectly sorted imports.\" , \"type\" : \"ISORT\" } ] else: return []","title":"Linter"},{"location":"reference/isort/pylama_isort/#ancestors-in-mro","text":"pylama.lint.Linter","title":"Ancestors (in MRO)"},{"location":"reference/isort/pylama_isort/#methods","text":"","title":"Methods"},{"location":"reference/isort/pylama_isort/#allow","text":"def allow ( self , path : str ) -> bool Determine if this path should be linted. View Source def allow ( self , path : str ) -> bool : \"\"\"Determine if this path should be linted.\"\"\" return path . endswith ( \".py\" )","title":"allow"},{"location":"reference/isort/pylama_isort/#run","text":"def run ( self , path : str , ** meta : Any ) -> List [ Dict [ str , Any ]] Lint the file. Return an array of error dicts if appropriate. View Source def run ( self , path : str , ** meta : Any ) -> List [ Dict [ str , Any ]]: \"\"\"Lint the file. Return an array of error dicts if appropriate.\"\"\" with supress_stdout (): if not api . check_file ( path ): return [ { \"lnum\" : 0 , \"col\" : 0 , \"text\" : \"Incorrectly sorted imports.\" , \"type\" : \"ISORT\" } ] else : return []","title":"run"},{"location":"reference/isort/sections/","text":"Module isort.sections Defines all sections isort uses by default View Source \"\"\"Defines all sections isort uses by default\"\"\" from typing import Tuple FUTURE : str = \"FUTURE\" STDLIB : str = \"STDLIB\" THIRDPARTY : str = \"THIRDPARTY\" FIRSTPARTY : str = \"FIRSTPARTY\" LOCALFOLDER : str = \"LOCALFOLDER\" DEFAULT : Tuple [ str , ... ] = ( FUTURE , STDLIB , THIRDPARTY , FIRSTPARTY , LOCALFOLDER ) Variables DEFAULT FIRSTPARTY FUTURE LOCALFOLDER STDLIB THIRDPARTY","title":"Sections"},{"location":"reference/isort/sections/#module-isortsections","text":"Defines all sections isort uses by default View Source \"\"\"Defines all sections isort uses by default\"\"\" from typing import Tuple FUTURE : str = \"FUTURE\" STDLIB : str = \"STDLIB\" THIRDPARTY : str = \"THIRDPARTY\" FIRSTPARTY : str = \"FIRSTPARTY\" LOCALFOLDER : str = \"LOCALFOLDER\" DEFAULT : Tuple [ str , ... ] = ( FUTURE , STDLIB , THIRDPARTY , FIRSTPARTY , LOCALFOLDER )","title":"Module isort.sections"},{"location":"reference/isort/sections/#variables","text":"DEFAULT FIRSTPARTY FUTURE LOCALFOLDER STDLIB THIRDPARTY","title":"Variables"},{"location":"reference/isort/settings/","text":"Module isort.settings isort/settings.py. Defines how the default settings for isort should be loaded View Source \"\"\"isort/settings.py. Defines how the default settings for isort should be loaded \"\"\" import configparser import fnmatch import os import posixpath import re import sys from distutils.util import strtobool as _as_bool from functools import lru_cache from pathlib import Path from typing import Any , Callable , Dict , FrozenSet , Iterable , List , Optional , Pattern , Set , Tuple from warnings import warn from . import stdlibs from ._future import dataclass , field from ._vendored import toml from .exceptions import ProfileDoesNotExist from .profiles import profiles from .sections import DEFAULT as SECTION_DEFAULTS from .sections import FIRSTPARTY , FUTURE , STDLIB , THIRDPARTY from .wrap_modes import WrapModes from .wrap_modes import from_string as wrap_mode_from_string SUPPORTED_EXTENSIONS = ( \".py\" , \".pyi\" , \".pyx\" ) FILE_SKIP_COMMENTS : Tuple [ str , ... ] = ( \"isort:\" + \"skip_file\" , \"isort: \" + \"skip_file\" , ) # Concatenated to avoid this file being skipped MAX_CONFIG_SEARCH_DEPTH : int = 25 # The number of parent directories to for a config file within STOP_CONFIG_SEARCH_ON_DIRS : Tuple [ str , ... ] = ( \".git\" , \".hg\" ) VALID_PY_TARGETS : Tuple [ str , ... ] = tuple ( target . replace ( \"py\" , \"\" ) for target in dir ( stdlibs ) if not target . startswith ( \"_\" ) ) CONFIG_SOURCES : Tuple [ str , ... ] = ( \".isort.cfg\" , \"pyproject.toml\" , \"setup.cfg\" , \"tox.ini\" , \".editorconfig\" , ) CONFIG_SECTIONS : Dict [ str , Tuple [ str , ... ]] = { \".isort.cfg\" : ( \"settings\" , \"isort\" ), \"pyproject.toml\" : ( \"tool.isort\" ,), \"setup.cfg\" : ( \"isort\" , \"tool:isort\" ), \"tox.ini\" : ( \"isort\" , \"tool:isort\" ), \".editorconfig\" : ( \"*\" , \"*.py\" , \"**.py\" , \"*.{py}\" ), } FALLBACK_CONFIG_SECTIONS : Tuple [ str , ... ] = ( \"isort\" , \"tool:isort\" , \"tool.isort\" ) IMPORT_HEADING_PREFIX = \"import_heading_\" KNOWN_PREFIX = \"known_\" KNOWN_SECTION_MAPPING : Dict [ str , str ] = { STDLIB : \"STANDARD_LIBRARY\" , FUTURE : \"FUTURE_LIBRARY\" , FIRSTPARTY : \"FIRST_PARTY\" , THIRDPARTY : \"THIRD_PARTY\" , } RUNTIME_SOURCE = \"runtime\" @dataclass ( frozen = True ) class _Config : \"\"\"Defines the data schema and defaults used for isort configuration. NOTE: known lists, such as known_standard_library, are intentionally not complete as they are dynamically determined later on. \"\"\" py_version : str = \"3\" force_to_top : FrozenSet [ str ] = frozenset () skip : FrozenSet [ str ] = frozenset ( { \".venv\" , \"venv\" , \".tox\" , \".eggs\" , \".git\" , \".hg\" , \".mypy_cache\" , \".nox\" , \"_build\" , \"buck-out\" , \"build\" , \"dist\" , \".pants.d\" , \"node_modules\" , } ) skip_glob : FrozenSet [ str ] = frozenset () line_length : int = 79 wrap_length : int = 0 line_ending : str = \"\" sections : Tuple [ str , ... ] = SECTION_DEFAULTS no_sections : bool = False known_future_library : FrozenSet [ str ] = frozenset (( \"__future__\" ,)) known_third_party : FrozenSet [ str ] = frozenset (( \"google.appengine.api\" ,)) known_first_party : FrozenSet [ str ] = frozenset () known_standard_library : FrozenSet [ str ] = frozenset () extra_standard_library : FrozenSet [ str ] = frozenset () known_other : Dict [ str , FrozenSet [ str ]] = field ( default_factory = dict ) multi_line_output : WrapModes = WrapModes . GRID # type: ignore forced_separate : Tuple [ str , ... ] = () indent : str = \" \" * 4 comment_prefix : str = \" #\" length_sort : bool = False length_sort_sections : FrozenSet [ str ] = frozenset () add_imports : FrozenSet [ str ] = frozenset () remove_imports : FrozenSet [ str ] = frozenset () reverse_relative : bool = False force_single_line : bool = False single_line_exclusions : Tuple [ str , ... ] = () default_section : str = THIRDPARTY import_headings : Dict [ str , str ] = field ( default_factory = dict ) balanced_wrapping : bool = False use_parentheses : bool = False order_by_type : bool = True atomic : bool = False lines_after_imports : int = - 1 lines_between_sections : int = 1 lines_between_types : int = 0 combine_as_imports : bool = False combine_star : bool = False keep_direct_and_as_imports : bool = True include_trailing_comma : bool = False from_first : bool = False verbose : bool = False quiet : bool = False force_adds : bool = False force_alphabetical_sort_within_sections : bool = False force_alphabetical_sort : bool = False force_grid_wrap : int = 0 force_sort_within_sections : bool = False lexicographical : bool = False ignore_whitespace : bool = False no_lines_before : FrozenSet [ str ] = frozenset () no_inline_sort : bool = False ignore_comments : bool = False case_sensitive : bool = False sources : Tuple [ Dict [ str , Any ], ... ] = () virtual_env : str = \"\" conda_env : str = \"\" ensure_newline_before_comments : bool = False directory : str = \"\" profile : str = \"\" src_paths : FrozenSet [ Path ] = frozenset () old_finders : bool = False def __post_init__ ( self ): py_version = self . py_version if py_version == \"auto\" : # pragma: no cover if sys . version_info . major == 2 and sys . version_info . minor <= 6 : py_version = \"2\" elif sys . version_info . major == 3 and ( sys . version_info . minor <= 5 or sys . version_info . minor >= 9 ): py_version = \"3\" else : py_version = f \"{sys.version_info.major}{sys.version_info.minor}\" if py_version not in VALID_PY_TARGETS : raise ValueError ( f \"The python version {py_version} is not supported. \" \"You can set a python version with the -py or --python-version flag. \" f \"The following versions are supported: {VALID_PY_TARGETS}\" ) if py_version != \"all\" : object . __setattr__ ( self , \"py_version\" , f \"py{py_version}\" ) if not self . known_standard_library : object . __setattr__ ( self , \"known_standard_library\" , frozenset ( getattr ( stdlibs , self . py_version ) . stdlib ) ) if self . force_alphabetical_sort : object . __setattr__ ( self , \"force_alphabetical_sort_within_sections\" , True ) object . __setattr__ ( self , \"no_sections\" , True ) object . __setattr__ ( self , \"lines_between_types\" , 1 ) object . __setattr__ ( self , \"from_first\" , True ) if self . wrap_length > self . line_length : raise ValueError ( \"wrap_length must be set lower than or equal to line_length: \" f \"{self.wrap_length} > {self.line_length}.\" ) def __hash__ ( self ): return id ( self ) _DEFAULT_SETTINGS = { ** vars ( _Config ()), \"source\" : \"defaults\" } class Config ( _Config ): def __init__ ( self , settings_file : str = \"\" , settings_path : str = \"\" , config : Optional [ _Config ] = None , ** config_overrides , ): if config : config_vars = vars ( config ) . copy () config_vars . update ( config_overrides ) config_vars [ \"py_version\" ] = config_vars [ \"py_version\" ] . replace ( \"py\" , \"\" ) config_vars . pop ( \"_known_patterns\" ) super () . __init__ ( ** config_vars ) # type: ignore return sources : List [ Dict [ str , Any ]] = [ _DEFAULT_SETTINGS ] config_settings : Dict [ str , Any ] project_root : str if settings_file : config_settings = _get_config_data ( settings_file , CONFIG_SECTIONS . get ( os . path . basename ( settings_file ), FALLBACK_CONFIG_SECTIONS ), ) project_root = os . path . dirname ( settings_file ) elif settings_path : project_root , config_settings = _find_config ( settings_path ) else : config_settings = {} project_root = os . getcwd () profile_name = config_overrides . get ( \"profile\" , config_settings . get ( \"profile\" , \"\" )) profile : Dict [ str , Any ] = {} if profile_name : if profile_name not in profiles : raise ProfileDoesNotExist ( profile_name ) profile = profiles [ profile_name ] . copy () profile [ \"source\" ] = f \"{profile_name} profile\" sources . append ( profile ) if config_settings : sources . append ( config_settings ) if config_overrides : config_overrides [ \"source\" ] = RUNTIME_SOURCE sources . append ( config_overrides ) combined_config = { ** profile , ** config_settings , ** config_overrides } if \"indent\" in combined_config : indent = str ( combined_config [ \"indent\" ]) if indent . isdigit (): indent = \" \" * int ( indent ) else : indent = indent . strip ( \"'\" ) . strip ( '\"' ) if indent . lower () == \"tab\" : indent = \" \\t \" combined_config [ \"indent\" ] = indent known_other = {} import_headings = {} for key , value in combined_config . items (): # Collect all known sections beyond those that have direct entries if key . startswith ( KNOWN_PREFIX ) and key not in ( \"known_standard_library\" , \"known_future_library\" , \"known_third_party\" , \"known_first_party\" , ): known_other [ key [ len ( KNOWN_PREFIX ) :] . lower ()] = frozenset ( value ) if key . startswith ( IMPORT_HEADING_PREFIX ): import_headings [ key [ len ( IMPORT_HEADING_PREFIX ) :] . lower ()] = str ( value ) # Coerce all provided config values into their correct type default_value = _DEFAULT_SETTINGS . get ( key , None ) if default_value is None : continue combined_config [ key ] = type ( default_value )( value ) if \"directory\" not in combined_config : combined_config [ \"directory\" ] = ( os . path . dirname ( config_settings [ \"source\" ]) if config_settings . get ( \"source\" , None ) else os . getcwd () ) path_root = Path ( combined_config . get ( \"directory\" , project_root )) . resolve () path_root = path_root if path_root . is_dir () else path_root . parent if \"src_paths\" not in combined_config : combined_config [ \"src_paths\" ] = frozenset (( path_root , path_root / \"src\" )) else : combined_config [ \"src_paths\" ] = frozenset ( path_root / path for path in combined_config . get ( \"src_paths\" , ()) ) # Remove any config values that are used for creating config object but # aren't defined in dataclass combined_config . pop ( \"source\" , None ) combined_config . pop ( \"sources\" , None ) combined_config . pop ( \"runtime_src_paths\" , None ) if known_other : for known_key in known_other : combined_config . pop ( f \"{KNOWN_PREFIX}{known_key}\" , None ) combined_config [ \"known_other\" ] = known_other if import_headings : for import_heading_key in import_headings : combined_config . pop ( f \"{IMPORT_HEADING_PREFIX}{import_heading_key}\" ) combined_config [ \"import_headings\" ] = import_headings self . _known_patterns : Optional [ List [ Tuple [ Pattern [ str ], str ]]] = None super () . __init__ ( sources = tuple ( sources ), ** combined_config ) # type: ignore def is_skipped ( self , file_path : Path ) -> bool : \"\"\"Returns True if the file and/or folder should be skipped based on current settings.\"\"\" if self . directory and Path ( self . directory ) in file_path . parents : file_name = os . path . relpath ( file_path , self . directory ) else : file_name = str ( file_path ) os_path = str ( file_path ) normalized_path = os_path . replace ( \" \\\\ \" , \"/\" ) if normalized_path [ 1 : 2 ] == \":\" : normalized_path = normalized_path [ 2 :] for skip_path in self . skip : if posixpath . abspath ( normalized_path ) == posixpath . abspath ( skip_path . replace ( \" \\\\ \" , \"/\" ) ): return True position = os . path . split ( file_name ) while position [ 1 ]: if position [ 1 ] in self . skip : return True position = os . path . split ( position [ 0 ]) for glob in self . skip_glob : if fnmatch . fnmatch ( file_name , glob ) or fnmatch . fnmatch ( \"/\" + file_name , glob ): return True if not ( os . path . isfile ( os_path ) or os . path . isdir ( os_path ) or os . path . islink ( os_path )): return True return False @property def known_patterns ( self ): if self . _known_patterns is not None : return self . _known_patterns self . _known_patterns = [] for placement in reversed ( self . sections ): known_placement = KNOWN_SECTION_MAPPING . get ( placement , placement ) . lower () config_key = f \"{KNOWN_PREFIX}{known_placement}\" known_modules = getattr ( self , config_key , self . known_other . get ( known_placement , ())) extra_modules = getattr ( self , f \"extra_{known_placement}\" , ()) all_modules = set ( known_modules ) . union ( extra_modules ) known_patterns = [ pattern for known_pattern in all_modules for pattern in self . _parse_known_pattern ( known_pattern ) ] for known_pattern in known_patterns : regexp = \"^\" + known_pattern . replace ( \"*\" , \".*\" ) . replace ( \"?\" , \".?\" ) + \"$\" self . _known_patterns . append (( re . compile ( regexp ), placement )) return self . _known_patterns @staticmethod def _parse_known_pattern ( pattern : str ) -> List [ str ]: \"\"\"Expand pattern if identified as a directory and return found sub packages\"\"\" if pattern . endswith ( os . path . sep ): patterns = [ filename for filename in os . listdir ( pattern ) if os . path . isdir ( os . path . join ( pattern , filename )) ] else : patterns = [ pattern ] return patterns def _get_str_to_type_converter ( setting_name : str ) -> Callable [[ str ], Any ]: type_converter : Callable [[ str ], Any ] = type ( _DEFAULT_SETTINGS . get ( setting_name , \"\" )) if type_converter == WrapModes : type_converter = wrap_mode_from_string return type_converter def _as_list ( value : str ) -> List [ str ]: if isinstance ( value , list ): return [ item . strip () for item in value ] filtered = [ item . strip () for item in value . replace ( \" \\n \" , \",\" ) . split ( \",\" ) if item . strip ()] return filtered def _abspaths ( cwd : str , values : Iterable [ str ]) -> Set [ str ]: paths = { os . path . join ( cwd , value ) if not value . startswith ( os . path . sep ) and value . endswith ( os . path . sep ) else value for value in values } return paths @lru_cache () def _find_config ( path : str ) -> Tuple [ str , Dict [ str , Any ]]: current_directory = path tries = 0 while current_directory and tries < MAX_CONFIG_SEARCH_DEPTH : for config_file_name in CONFIG_SOURCES : potential_config_file = os . path . join ( current_directory , config_file_name ) if os . path . isfile ( potential_config_file ): config_data : Dict [ str , Any ] try : config_data = _get_config_data ( potential_config_file , CONFIG_SECTIONS [ config_file_name ] ) except Exception : warn ( f \"Failed to pull configuration information from {potential_config_file}\" ) config_data = {} if config_data : return ( current_directory , config_data ) for stop_dir in STOP_CONFIG_SEARCH_ON_DIRS : if os . path . isdir ( os . path . join ( current_directory , stop_dir )): return ( current_directory , {}) new_directory = os . path . split ( current_directory )[ 0 ] if new_directory == current_directory : break current_directory = new_directory tries += 1 return ( path , {}) @lru_cache () def _get_config_data ( file_path : str , sections : Tuple [ str ]) -> Dict [ str , Any ]: settings : Dict [ str , Any ] = {} with open ( file_path ) as config_file : if file_path . endswith ( \".toml\" ): config = toml . load ( config_file ) for section in sections : config_section = config for key in section . split ( \".\" ): config_section = config_section . get ( key , {}) settings . update ( config_section ) else : if file_path . endswith ( \".editorconfig\" ): line = \" \\n \" last_position = config_file . tell () while line : line = config_file . readline () if \"[\" in line : config_file . seek ( last_position ) break last_position = config_file . tell () config = configparser . ConfigParser ( strict = False ) config . read_file ( config_file ) for section in sections : if section . startswith ( \"*.{\" ) and section . endswith ( \"}\" ): extension = section [ len ( \"*.{\" ) : - 1 ] for config_key in config . keys (): if config_key . startswith ( \"*.{\" ) and config_key . endswith ( \"}\" ): if extension in map ( lambda text : text . strip (), config_key [ len ( \"*.{\" ) : - 1 ] . split ( \",\" ) ): settings . update ( config . items ( config_key )) elif config . has_section ( section ): settings . update ( config . items ( section )) if settings : settings [ \"source\" ] = file_path if file_path . endswith ( \".editorconfig\" ): indent_style = settings . pop ( \"indent_style\" , \"\" ) . strip () indent_size = settings . pop ( \"indent_size\" , \"\" ) . strip () if indent_size == \"tab\" : indent_size = settings . pop ( \"tab_width\" , \"\" ) . strip () if indent_style == \"space\" : settings [ \"indent\" ] = \" \" * ( indent_size and int ( indent_size ) or 4 ) elif indent_style == \"tab\" : settings [ \"indent\" ] = \" \\t \" * ( indent_size and int ( indent_size ) or 1 ) max_line_length = settings . pop ( \"max_line_length\" , \"\" ) . strip () if max_line_length : settings [ \"line_length\" ] = ( float ( \"inf\" ) if max_line_length == \"off\" else int ( max_line_length ) ) settings = { key : value for key , value in settings . items () if key in _DEFAULT_SETTINGS . keys () } for key , value in settings . items (): existing_value_type = _get_str_to_type_converter ( key ) if existing_value_type == tuple : settings [ key ] = tuple ( _as_list ( value )) elif existing_value_type == frozenset : settings [ key ] = frozenset ( _as_list ( settings . get ( key ))) # type: ignore elif existing_value_type == bool : # Only some configuration formats support native boolean values. if not isinstance ( value , bool ): value = bool ( _as_bool ( value )) settings [ key ] = value elif key . startswith ( KNOWN_PREFIX ): settings [ key ] = _abspaths ( os . path . dirname ( file_path ), _as_list ( value )) elif key == \"force_grid_wrap\" : try : result = existing_value_type ( value ) except ValueError : # backwards compatibility for true / false force grid wrap result = 0 if value . lower () . strip () == \"false\" else 2 settings [ key ] = result elif key == \"comment_prefix\" : settings [ key ] = str ( value ) . strip ( \"'\" ) . strip ( '\"' ) else : settings [ key ] = existing_value_type ( value ) return settings DEFAULT_CONFIG = Config () Variables CONFIG_SECTIONS CONFIG_SOURCES DEFAULT_CONFIG FALLBACK_CONFIG_SECTIONS FILE_SKIP_COMMENTS FIRSTPARTY FUTURE IMPORT_HEADING_PREFIX KNOWN_PREFIX KNOWN_SECTION_MAPPING MAX_CONFIG_SEARCH_DEPTH RUNTIME_SOURCE SECTION_DEFAULTS STDLIB STOP_CONFIG_SEARCH_ON_DIRS SUPPORTED_EXTENSIONS THIRDPARTY VALID_PY_TARGETS profiles Classes Config class Config ( settings_file : str = '' , settings_path : str = '' , config : Union [ isort . settings . _Config , NoneType ] = None , ** config_overrides ) Defines the data schema and defaults used for isort configuration. NOTE: known lists, such as known_standard_library, are intentionally not complete as they are dynamically determined later on. View Source class Config ( _Config ) : def __init__ ( self , settings_file : str = \"\" , settings_path : str = \"\" , config : Optional [ _Config ] = None , ** config_overrides , ) : if config : config_vars = vars ( config ). copy () config_vars . update ( config_overrides ) config_vars [ \"py_version\" ] = config_vars [ \"py_version\" ] . replace ( \"py\" , \"\" ) config_vars . pop ( \"_known_patterns\" ) super (). __init__ ( ** config_vars ) # type : ignore return sources : List [ Dict[str, Any ] ] = [ _DEFAULT_SETTINGS ] config_settings : Dict [ str, Any ] project_root : str if settings_file : config_settings = _get_config_data ( settings_file , CONFIG_SECTIONS . get ( os . path . basename ( settings_file ), FALLBACK_CONFIG_SECTIONS ), ) project_root = os . path . dirname ( settings_file ) elif settings_path : project_root , config_settings = _find_config ( settings_path ) else : config_settings = {} project_root = os . getcwd () profile_name = config_overrides . get ( \"profile\" , config_settings . get ( \"profile\" , \"\" )) profile : Dict [ str, Any ] = {} if profile_name : if profile_name not in profiles : raise ProfileDoesNotExist ( profile_name ) profile = profiles [ profile_name ] . copy () profile [ \"source\" ] = f \"{profile_name} profile\" sources . append ( profile ) if config_settings : sources . append ( config_settings ) if config_overrides : config_overrides [ \"source\" ] = RUNTIME_SOURCE sources . append ( config_overrides ) combined_config = { ** profile , ** config_settings , ** config_overrides } if \"indent\" in combined_config : indent = str ( combined_config [ \"indent\" ] ) if indent . isdigit () : indent = \" \" * int ( indent ) else : indent = indent . strip ( \"'\" ). strip ( '\"' ) if indent . lower () == \"tab\" : indent = \"\\t\" combined_config [ \"indent\" ] = indent known_other = {} import_headings = {} for key , value in combined_config . items () : # Collect all known sections beyond those that have direct entries if key . startswith ( KNOWN_PREFIX ) and key not in ( \"known_standard_library\" , \"known_future_library\" , \"known_third_party\" , \"known_first_party\" , ) : known_other [ key[len(KNOWN_PREFIX) : ] . lower () ] = frozenset ( value ) if key . startswith ( IMPORT_HEADING_PREFIX ) : import_headings [ key[len(IMPORT_HEADING_PREFIX) : ] . lower () ] = str ( value ) # Coerce all provided config values into their correct type default_value = _DEFAULT_SETTINGS . get ( key , None ) if default_value is None : continue combined_config [ key ] = type ( default_value )( value ) if \"directory\" not in combined_config : combined_config [ \"directory\" ] = ( os . path . dirname ( config_settings [ \"source\" ] ) if config_settings . get ( \"source\" , None ) else os . getcwd () ) path_root = Path ( combined_config . get ( \"directory\" , project_root )). resolve () path_root = path_root if path_root . is_dir () else path_root . parent if \"src_paths\" not in combined_config : combined_config [ \"src_paths\" ] = frozenset (( path_root , path_root / \"src\" )) else : combined_config [ \"src_paths\" ] = frozenset ( path_root / path for path in combined_config . get ( \"src_paths\" , ()) ) # Remove any config values that are used for creating config object but # aren ' t defined in dataclass combined_config . pop ( \"source\" , None ) combined_config . pop ( \"sources\" , None ) combined_config . pop ( \"runtime_src_paths\" , None ) if known_other : for known_key in known_other : combined_config . pop ( f \"{KNOWN_PREFIX}{known_key}\" , None ) combined_config [ \"known_other\" ] = known_other if import_headings : for import_heading_key in import_headings : combined_config . pop ( f \"{IMPORT_HEADING_PREFIX}{import_heading_key}\" ) combined_config [ \"import_headings\" ] = import_headings self . _known_patterns : Optional [ List[Tuple[Pattern[str ] , str ]]] = None super (). __init__ ( sources = tuple ( sources ), ** combined_config ) # type : ignore def is_skipped ( self , file_path : Path ) -> bool : \"\"\"Returns True if the file and/or folder should be skipped based on current settings.\"\"\" if self . directory and Path ( self . directory ) in file_path . parents : file_name = os . path . relpath ( file_path , self . directory ) else : file_name = str ( file_path ) os_path = str ( file_path ) normalized_path = os_path . replace ( \"\\\\\" , \"/\" ) if normalized_path [ 1:2 ] == \":\" : normalized_path = normalized_path [ 2: ] for skip_path in self . skip : if posixpath . abspath ( normalized_path ) == posixpath . abspath ( skip_path . replace ( \"\\\\\" , \"/\" ) ) : return True position = os . path . split ( file_name ) while position [ 1 ] : if position [ 1 ] in self . skip : return True position = os . path . split ( position [ 0 ] ) for glob in self . skip_glob : if fnmatch . fnmatch ( file_name , glob ) or fnmatch . fnmatch ( \"/\" + file_name , glob ) : return True if not ( os . path . isfile ( os_path ) or os . path . isdir ( os_path ) or os . path . islink ( os_path )) : return True return False @property def known_patterns ( self ) : if self . _known_patterns is not None : return self . _known_patterns self . _known_patterns = [] for placement in reversed ( self . sections ) : known_placement = KNOWN_SECTION_MAPPING . get ( placement , placement ). lower () config_key = f \"{KNOWN_PREFIX}{known_placement}\" known_modules = getattr ( self , config_key , self . known_other . get ( known_placement , ())) extra_modules = getattr ( self , f \"extra_{known_placement}\" , ()) all_modules = set ( known_modules ). union ( extra_modules ) known_patterns = [ pattern for known_pattern in all_modules for pattern in self._parse_known_pattern(known_pattern) ] for known_pattern in known_patterns : regexp = \"^\" + known_pattern . replace ( \"*\" , \".*\" ). replace ( \"?\" , \".?\" ) + \"$\" self . _known_patterns . append (( re . compile ( regexp ), placement )) return self . _known_patterns @staticmethod def _parse_known_pattern ( pattern : str ) -> List [ str ] : \"\"\"Expand pattern if identified as a directory and return found sub packages\"\"\" if pattern . endswith ( os . path . sep ) : patterns = [ filename for filename in os.listdir(pattern) if os.path.isdir(os.path.join(pattern, filename)) ] else : patterns = [ pattern ] return patterns Ancestors (in MRO) isort.settings._Config Class variables add_imports atomic balanced_wrapping case_sensitive combine_as_imports combine_star comment_prefix conda_env default_section directory ensure_newline_before_comments extra_standard_library force_adds force_alphabetical_sort force_alphabetical_sort_within_sections force_grid_wrap force_single_line force_sort_within_sections force_to_top forced_separate from_first ignore_comments ignore_whitespace include_trailing_comma indent keep_direct_and_as_imports known_first_party known_future_library known_standard_library known_third_party length_sort length_sort_sections lexicographical line_ending line_length lines_after_imports lines_between_sections lines_between_types multi_line_output no_inline_sort no_lines_before no_sections old_finders order_by_type profile py_version quiet remove_imports reverse_relative sections single_line_exclusions skip skip_glob sources src_paths use_parentheses verbose virtual_env wrap_length Instance variables known_patterns Methods is_skipped def is_skipped ( self , file_path : pathlib . Path ) -> bool Returns True if the file and/or folder should be skipped based on current settings. View Source def is_skipped ( self , file_path : Path ) -> bool : \"\"\"Returns True if the file and/or folder should be skipped based on current settings.\"\"\" if self . directory and Path ( self . directory ) in file_path . parents : file_name = os . path . relpath ( file_path , self . directory ) else : file_name = str ( file_path ) os_path = str ( file_path ) normalized_path = os_path . replace ( \"\\\\\" , \"/\" ) if normalized_path [ 1 : 2 ] == \":\" : normalized_path = normalized_path [ 2 :] for skip_path in self . skip : if posixpath . abspath ( normalized_path ) == posixpath . abspath ( skip_path . replace ( \"\\\\\" , \"/\" ) ): return True position = os . path . split ( file_name ) while position [ 1 ]: if position [ 1 ] in self . skip : return True position = os . path . split ( position [ 0 ]) for glob in self . skip_glob : if fnmatch . fnmatch ( file_name , glob ) or fnmatch . fnmatch ( \"/\" + file_name , glob ): return True if not ( os . path . isfile ( os_path ) or os . path . isdir ( os_path ) or os . path . islink ( os_path )): return True return False","title":"Settings"},{"location":"reference/isort/settings/#module-isortsettings","text":"isort/settings.py. Defines how the default settings for isort should be loaded View Source \"\"\"isort/settings.py. Defines how the default settings for isort should be loaded \"\"\" import configparser import fnmatch import os import posixpath import re import sys from distutils.util import strtobool as _as_bool from functools import lru_cache from pathlib import Path from typing import Any , Callable , Dict , FrozenSet , Iterable , List , Optional , Pattern , Set , Tuple from warnings import warn from . import stdlibs from ._future import dataclass , field from ._vendored import toml from .exceptions import ProfileDoesNotExist from .profiles import profiles from .sections import DEFAULT as SECTION_DEFAULTS from .sections import FIRSTPARTY , FUTURE , STDLIB , THIRDPARTY from .wrap_modes import WrapModes from .wrap_modes import from_string as wrap_mode_from_string SUPPORTED_EXTENSIONS = ( \".py\" , \".pyi\" , \".pyx\" ) FILE_SKIP_COMMENTS : Tuple [ str , ... ] = ( \"isort:\" + \"skip_file\" , \"isort: \" + \"skip_file\" , ) # Concatenated to avoid this file being skipped MAX_CONFIG_SEARCH_DEPTH : int = 25 # The number of parent directories to for a config file within STOP_CONFIG_SEARCH_ON_DIRS : Tuple [ str , ... ] = ( \".git\" , \".hg\" ) VALID_PY_TARGETS : Tuple [ str , ... ] = tuple ( target . replace ( \"py\" , \"\" ) for target in dir ( stdlibs ) if not target . startswith ( \"_\" ) ) CONFIG_SOURCES : Tuple [ str , ... ] = ( \".isort.cfg\" , \"pyproject.toml\" , \"setup.cfg\" , \"tox.ini\" , \".editorconfig\" , ) CONFIG_SECTIONS : Dict [ str , Tuple [ str , ... ]] = { \".isort.cfg\" : ( \"settings\" , \"isort\" ), \"pyproject.toml\" : ( \"tool.isort\" ,), \"setup.cfg\" : ( \"isort\" , \"tool:isort\" ), \"tox.ini\" : ( \"isort\" , \"tool:isort\" ), \".editorconfig\" : ( \"*\" , \"*.py\" , \"**.py\" , \"*.{py}\" ), } FALLBACK_CONFIG_SECTIONS : Tuple [ str , ... ] = ( \"isort\" , \"tool:isort\" , \"tool.isort\" ) IMPORT_HEADING_PREFIX = \"import_heading_\" KNOWN_PREFIX = \"known_\" KNOWN_SECTION_MAPPING : Dict [ str , str ] = { STDLIB : \"STANDARD_LIBRARY\" , FUTURE : \"FUTURE_LIBRARY\" , FIRSTPARTY : \"FIRST_PARTY\" , THIRDPARTY : \"THIRD_PARTY\" , } RUNTIME_SOURCE = \"runtime\" @dataclass ( frozen = True ) class _Config : \"\"\"Defines the data schema and defaults used for isort configuration. NOTE: known lists, such as known_standard_library, are intentionally not complete as they are dynamically determined later on. \"\"\" py_version : str = \"3\" force_to_top : FrozenSet [ str ] = frozenset () skip : FrozenSet [ str ] = frozenset ( { \".venv\" , \"venv\" , \".tox\" , \".eggs\" , \".git\" , \".hg\" , \".mypy_cache\" , \".nox\" , \"_build\" , \"buck-out\" , \"build\" , \"dist\" , \".pants.d\" , \"node_modules\" , } ) skip_glob : FrozenSet [ str ] = frozenset () line_length : int = 79 wrap_length : int = 0 line_ending : str = \"\" sections : Tuple [ str , ... ] = SECTION_DEFAULTS no_sections : bool = False known_future_library : FrozenSet [ str ] = frozenset (( \"__future__\" ,)) known_third_party : FrozenSet [ str ] = frozenset (( \"google.appengine.api\" ,)) known_first_party : FrozenSet [ str ] = frozenset () known_standard_library : FrozenSet [ str ] = frozenset () extra_standard_library : FrozenSet [ str ] = frozenset () known_other : Dict [ str , FrozenSet [ str ]] = field ( default_factory = dict ) multi_line_output : WrapModes = WrapModes . GRID # type: ignore forced_separate : Tuple [ str , ... ] = () indent : str = \" \" * 4 comment_prefix : str = \" #\" length_sort : bool = False length_sort_sections : FrozenSet [ str ] = frozenset () add_imports : FrozenSet [ str ] = frozenset () remove_imports : FrozenSet [ str ] = frozenset () reverse_relative : bool = False force_single_line : bool = False single_line_exclusions : Tuple [ str , ... ] = () default_section : str = THIRDPARTY import_headings : Dict [ str , str ] = field ( default_factory = dict ) balanced_wrapping : bool = False use_parentheses : bool = False order_by_type : bool = True atomic : bool = False lines_after_imports : int = - 1 lines_between_sections : int = 1 lines_between_types : int = 0 combine_as_imports : bool = False combine_star : bool = False keep_direct_and_as_imports : bool = True include_trailing_comma : bool = False from_first : bool = False verbose : bool = False quiet : bool = False force_adds : bool = False force_alphabetical_sort_within_sections : bool = False force_alphabetical_sort : bool = False force_grid_wrap : int = 0 force_sort_within_sections : bool = False lexicographical : bool = False ignore_whitespace : bool = False no_lines_before : FrozenSet [ str ] = frozenset () no_inline_sort : bool = False ignore_comments : bool = False case_sensitive : bool = False sources : Tuple [ Dict [ str , Any ], ... ] = () virtual_env : str = \"\" conda_env : str = \"\" ensure_newline_before_comments : bool = False directory : str = \"\" profile : str = \"\" src_paths : FrozenSet [ Path ] = frozenset () old_finders : bool = False def __post_init__ ( self ): py_version = self . py_version if py_version == \"auto\" : # pragma: no cover if sys . version_info . major == 2 and sys . version_info . minor <= 6 : py_version = \"2\" elif sys . version_info . major == 3 and ( sys . version_info . minor <= 5 or sys . version_info . minor >= 9 ): py_version = \"3\" else : py_version = f \"{sys.version_info.major}{sys.version_info.minor}\" if py_version not in VALID_PY_TARGETS : raise ValueError ( f \"The python version {py_version} is not supported. \" \"You can set a python version with the -py or --python-version flag. \" f \"The following versions are supported: {VALID_PY_TARGETS}\" ) if py_version != \"all\" : object . __setattr__ ( self , \"py_version\" , f \"py{py_version}\" ) if not self . known_standard_library : object . __setattr__ ( self , \"known_standard_library\" , frozenset ( getattr ( stdlibs , self . py_version ) . stdlib ) ) if self . force_alphabetical_sort : object . __setattr__ ( self , \"force_alphabetical_sort_within_sections\" , True ) object . __setattr__ ( self , \"no_sections\" , True ) object . __setattr__ ( self , \"lines_between_types\" , 1 ) object . __setattr__ ( self , \"from_first\" , True ) if self . wrap_length > self . line_length : raise ValueError ( \"wrap_length must be set lower than or equal to line_length: \" f \"{self.wrap_length} > {self.line_length}.\" ) def __hash__ ( self ): return id ( self ) _DEFAULT_SETTINGS = { ** vars ( _Config ()), \"source\" : \"defaults\" } class Config ( _Config ): def __init__ ( self , settings_file : str = \"\" , settings_path : str = \"\" , config : Optional [ _Config ] = None , ** config_overrides , ): if config : config_vars = vars ( config ) . copy () config_vars . update ( config_overrides ) config_vars [ \"py_version\" ] = config_vars [ \"py_version\" ] . replace ( \"py\" , \"\" ) config_vars . pop ( \"_known_patterns\" ) super () . __init__ ( ** config_vars ) # type: ignore return sources : List [ Dict [ str , Any ]] = [ _DEFAULT_SETTINGS ] config_settings : Dict [ str , Any ] project_root : str if settings_file : config_settings = _get_config_data ( settings_file , CONFIG_SECTIONS . get ( os . path . basename ( settings_file ), FALLBACK_CONFIG_SECTIONS ), ) project_root = os . path . dirname ( settings_file ) elif settings_path : project_root , config_settings = _find_config ( settings_path ) else : config_settings = {} project_root = os . getcwd () profile_name = config_overrides . get ( \"profile\" , config_settings . get ( \"profile\" , \"\" )) profile : Dict [ str , Any ] = {} if profile_name : if profile_name not in profiles : raise ProfileDoesNotExist ( profile_name ) profile = profiles [ profile_name ] . copy () profile [ \"source\" ] = f \"{profile_name} profile\" sources . append ( profile ) if config_settings : sources . append ( config_settings ) if config_overrides : config_overrides [ \"source\" ] = RUNTIME_SOURCE sources . append ( config_overrides ) combined_config = { ** profile , ** config_settings , ** config_overrides } if \"indent\" in combined_config : indent = str ( combined_config [ \"indent\" ]) if indent . isdigit (): indent = \" \" * int ( indent ) else : indent = indent . strip ( \"'\" ) . strip ( '\"' ) if indent . lower () == \"tab\" : indent = \" \\t \" combined_config [ \"indent\" ] = indent known_other = {} import_headings = {} for key , value in combined_config . items (): # Collect all known sections beyond those that have direct entries if key . startswith ( KNOWN_PREFIX ) and key not in ( \"known_standard_library\" , \"known_future_library\" , \"known_third_party\" , \"known_first_party\" , ): known_other [ key [ len ( KNOWN_PREFIX ) :] . lower ()] = frozenset ( value ) if key . startswith ( IMPORT_HEADING_PREFIX ): import_headings [ key [ len ( IMPORT_HEADING_PREFIX ) :] . lower ()] = str ( value ) # Coerce all provided config values into their correct type default_value = _DEFAULT_SETTINGS . get ( key , None ) if default_value is None : continue combined_config [ key ] = type ( default_value )( value ) if \"directory\" not in combined_config : combined_config [ \"directory\" ] = ( os . path . dirname ( config_settings [ \"source\" ]) if config_settings . get ( \"source\" , None ) else os . getcwd () ) path_root = Path ( combined_config . get ( \"directory\" , project_root )) . resolve () path_root = path_root if path_root . is_dir () else path_root . parent if \"src_paths\" not in combined_config : combined_config [ \"src_paths\" ] = frozenset (( path_root , path_root / \"src\" )) else : combined_config [ \"src_paths\" ] = frozenset ( path_root / path for path in combined_config . get ( \"src_paths\" , ()) ) # Remove any config values that are used for creating config object but # aren't defined in dataclass combined_config . pop ( \"source\" , None ) combined_config . pop ( \"sources\" , None ) combined_config . pop ( \"runtime_src_paths\" , None ) if known_other : for known_key in known_other : combined_config . pop ( f \"{KNOWN_PREFIX}{known_key}\" , None ) combined_config [ \"known_other\" ] = known_other if import_headings : for import_heading_key in import_headings : combined_config . pop ( f \"{IMPORT_HEADING_PREFIX}{import_heading_key}\" ) combined_config [ \"import_headings\" ] = import_headings self . _known_patterns : Optional [ List [ Tuple [ Pattern [ str ], str ]]] = None super () . __init__ ( sources = tuple ( sources ), ** combined_config ) # type: ignore def is_skipped ( self , file_path : Path ) -> bool : \"\"\"Returns True if the file and/or folder should be skipped based on current settings.\"\"\" if self . directory and Path ( self . directory ) in file_path . parents : file_name = os . path . relpath ( file_path , self . directory ) else : file_name = str ( file_path ) os_path = str ( file_path ) normalized_path = os_path . replace ( \" \\\\ \" , \"/\" ) if normalized_path [ 1 : 2 ] == \":\" : normalized_path = normalized_path [ 2 :] for skip_path in self . skip : if posixpath . abspath ( normalized_path ) == posixpath . abspath ( skip_path . replace ( \" \\\\ \" , \"/\" ) ): return True position = os . path . split ( file_name ) while position [ 1 ]: if position [ 1 ] in self . skip : return True position = os . path . split ( position [ 0 ]) for glob in self . skip_glob : if fnmatch . fnmatch ( file_name , glob ) or fnmatch . fnmatch ( \"/\" + file_name , glob ): return True if not ( os . path . isfile ( os_path ) or os . path . isdir ( os_path ) or os . path . islink ( os_path )): return True return False @property def known_patterns ( self ): if self . _known_patterns is not None : return self . _known_patterns self . _known_patterns = [] for placement in reversed ( self . sections ): known_placement = KNOWN_SECTION_MAPPING . get ( placement , placement ) . lower () config_key = f \"{KNOWN_PREFIX}{known_placement}\" known_modules = getattr ( self , config_key , self . known_other . get ( known_placement , ())) extra_modules = getattr ( self , f \"extra_{known_placement}\" , ()) all_modules = set ( known_modules ) . union ( extra_modules ) known_patterns = [ pattern for known_pattern in all_modules for pattern in self . _parse_known_pattern ( known_pattern ) ] for known_pattern in known_patterns : regexp = \"^\" + known_pattern . replace ( \"*\" , \".*\" ) . replace ( \"?\" , \".?\" ) + \"$\" self . _known_patterns . append (( re . compile ( regexp ), placement )) return self . _known_patterns @staticmethod def _parse_known_pattern ( pattern : str ) -> List [ str ]: \"\"\"Expand pattern if identified as a directory and return found sub packages\"\"\" if pattern . endswith ( os . path . sep ): patterns = [ filename for filename in os . listdir ( pattern ) if os . path . isdir ( os . path . join ( pattern , filename )) ] else : patterns = [ pattern ] return patterns def _get_str_to_type_converter ( setting_name : str ) -> Callable [[ str ], Any ]: type_converter : Callable [[ str ], Any ] = type ( _DEFAULT_SETTINGS . get ( setting_name , \"\" )) if type_converter == WrapModes : type_converter = wrap_mode_from_string return type_converter def _as_list ( value : str ) -> List [ str ]: if isinstance ( value , list ): return [ item . strip () for item in value ] filtered = [ item . strip () for item in value . replace ( \" \\n \" , \",\" ) . split ( \",\" ) if item . strip ()] return filtered def _abspaths ( cwd : str , values : Iterable [ str ]) -> Set [ str ]: paths = { os . path . join ( cwd , value ) if not value . startswith ( os . path . sep ) and value . endswith ( os . path . sep ) else value for value in values } return paths @lru_cache () def _find_config ( path : str ) -> Tuple [ str , Dict [ str , Any ]]: current_directory = path tries = 0 while current_directory and tries < MAX_CONFIG_SEARCH_DEPTH : for config_file_name in CONFIG_SOURCES : potential_config_file = os . path . join ( current_directory , config_file_name ) if os . path . isfile ( potential_config_file ): config_data : Dict [ str , Any ] try : config_data = _get_config_data ( potential_config_file , CONFIG_SECTIONS [ config_file_name ] ) except Exception : warn ( f \"Failed to pull configuration information from {potential_config_file}\" ) config_data = {} if config_data : return ( current_directory , config_data ) for stop_dir in STOP_CONFIG_SEARCH_ON_DIRS : if os . path . isdir ( os . path . join ( current_directory , stop_dir )): return ( current_directory , {}) new_directory = os . path . split ( current_directory )[ 0 ] if new_directory == current_directory : break current_directory = new_directory tries += 1 return ( path , {}) @lru_cache () def _get_config_data ( file_path : str , sections : Tuple [ str ]) -> Dict [ str , Any ]: settings : Dict [ str , Any ] = {} with open ( file_path ) as config_file : if file_path . endswith ( \".toml\" ): config = toml . load ( config_file ) for section in sections : config_section = config for key in section . split ( \".\" ): config_section = config_section . get ( key , {}) settings . update ( config_section ) else : if file_path . endswith ( \".editorconfig\" ): line = \" \\n \" last_position = config_file . tell () while line : line = config_file . readline () if \"[\" in line : config_file . seek ( last_position ) break last_position = config_file . tell () config = configparser . ConfigParser ( strict = False ) config . read_file ( config_file ) for section in sections : if section . startswith ( \"*.{\" ) and section . endswith ( \"}\" ): extension = section [ len ( \"*.{\" ) : - 1 ] for config_key in config . keys (): if config_key . startswith ( \"*.{\" ) and config_key . endswith ( \"}\" ): if extension in map ( lambda text : text . strip (), config_key [ len ( \"*.{\" ) : - 1 ] . split ( \",\" ) ): settings . update ( config . items ( config_key )) elif config . has_section ( section ): settings . update ( config . items ( section )) if settings : settings [ \"source\" ] = file_path if file_path . endswith ( \".editorconfig\" ): indent_style = settings . pop ( \"indent_style\" , \"\" ) . strip () indent_size = settings . pop ( \"indent_size\" , \"\" ) . strip () if indent_size == \"tab\" : indent_size = settings . pop ( \"tab_width\" , \"\" ) . strip () if indent_style == \"space\" : settings [ \"indent\" ] = \" \" * ( indent_size and int ( indent_size ) or 4 ) elif indent_style == \"tab\" : settings [ \"indent\" ] = \" \\t \" * ( indent_size and int ( indent_size ) or 1 ) max_line_length = settings . pop ( \"max_line_length\" , \"\" ) . strip () if max_line_length : settings [ \"line_length\" ] = ( float ( \"inf\" ) if max_line_length == \"off\" else int ( max_line_length ) ) settings = { key : value for key , value in settings . items () if key in _DEFAULT_SETTINGS . keys () } for key , value in settings . items (): existing_value_type = _get_str_to_type_converter ( key ) if existing_value_type == tuple : settings [ key ] = tuple ( _as_list ( value )) elif existing_value_type == frozenset : settings [ key ] = frozenset ( _as_list ( settings . get ( key ))) # type: ignore elif existing_value_type == bool : # Only some configuration formats support native boolean values. if not isinstance ( value , bool ): value = bool ( _as_bool ( value )) settings [ key ] = value elif key . startswith ( KNOWN_PREFIX ): settings [ key ] = _abspaths ( os . path . dirname ( file_path ), _as_list ( value )) elif key == \"force_grid_wrap\" : try : result = existing_value_type ( value ) except ValueError : # backwards compatibility for true / false force grid wrap result = 0 if value . lower () . strip () == \"false\" else 2 settings [ key ] = result elif key == \"comment_prefix\" : settings [ key ] = str ( value ) . strip ( \"'\" ) . strip ( '\"' ) else : settings [ key ] = existing_value_type ( value ) return settings DEFAULT_CONFIG = Config ()","title":"Module isort.settings"},{"location":"reference/isort/settings/#variables","text":"CONFIG_SECTIONS CONFIG_SOURCES DEFAULT_CONFIG FALLBACK_CONFIG_SECTIONS FILE_SKIP_COMMENTS FIRSTPARTY FUTURE IMPORT_HEADING_PREFIX KNOWN_PREFIX KNOWN_SECTION_MAPPING MAX_CONFIG_SEARCH_DEPTH RUNTIME_SOURCE SECTION_DEFAULTS STDLIB STOP_CONFIG_SEARCH_ON_DIRS SUPPORTED_EXTENSIONS THIRDPARTY VALID_PY_TARGETS profiles","title":"Variables"},{"location":"reference/isort/settings/#classes","text":"","title":"Classes"},{"location":"reference/isort/settings/#config","text":"class Config ( settings_file : str = '' , settings_path : str = '' , config : Union [ isort . settings . _Config , NoneType ] = None , ** config_overrides ) Defines the data schema and defaults used for isort configuration. NOTE: known lists, such as known_standard_library, are intentionally not complete as they are dynamically determined later on. View Source class Config ( _Config ) : def __init__ ( self , settings_file : str = \"\" , settings_path : str = \"\" , config : Optional [ _Config ] = None , ** config_overrides , ) : if config : config_vars = vars ( config ). copy () config_vars . update ( config_overrides ) config_vars [ \"py_version\" ] = config_vars [ \"py_version\" ] . replace ( \"py\" , \"\" ) config_vars . pop ( \"_known_patterns\" ) super (). __init__ ( ** config_vars ) # type : ignore return sources : List [ Dict[str, Any ] ] = [ _DEFAULT_SETTINGS ] config_settings : Dict [ str, Any ] project_root : str if settings_file : config_settings = _get_config_data ( settings_file , CONFIG_SECTIONS . get ( os . path . basename ( settings_file ), FALLBACK_CONFIG_SECTIONS ), ) project_root = os . path . dirname ( settings_file ) elif settings_path : project_root , config_settings = _find_config ( settings_path ) else : config_settings = {} project_root = os . getcwd () profile_name = config_overrides . get ( \"profile\" , config_settings . get ( \"profile\" , \"\" )) profile : Dict [ str, Any ] = {} if profile_name : if profile_name not in profiles : raise ProfileDoesNotExist ( profile_name ) profile = profiles [ profile_name ] . copy () profile [ \"source\" ] = f \"{profile_name} profile\" sources . append ( profile ) if config_settings : sources . append ( config_settings ) if config_overrides : config_overrides [ \"source\" ] = RUNTIME_SOURCE sources . append ( config_overrides ) combined_config = { ** profile , ** config_settings , ** config_overrides } if \"indent\" in combined_config : indent = str ( combined_config [ \"indent\" ] ) if indent . isdigit () : indent = \" \" * int ( indent ) else : indent = indent . strip ( \"'\" ). strip ( '\"' ) if indent . lower () == \"tab\" : indent = \"\\t\" combined_config [ \"indent\" ] = indent known_other = {} import_headings = {} for key , value in combined_config . items () : # Collect all known sections beyond those that have direct entries if key . startswith ( KNOWN_PREFIX ) and key not in ( \"known_standard_library\" , \"known_future_library\" , \"known_third_party\" , \"known_first_party\" , ) : known_other [ key[len(KNOWN_PREFIX) : ] . lower () ] = frozenset ( value ) if key . startswith ( IMPORT_HEADING_PREFIX ) : import_headings [ key[len(IMPORT_HEADING_PREFIX) : ] . lower () ] = str ( value ) # Coerce all provided config values into their correct type default_value = _DEFAULT_SETTINGS . get ( key , None ) if default_value is None : continue combined_config [ key ] = type ( default_value )( value ) if \"directory\" not in combined_config : combined_config [ \"directory\" ] = ( os . path . dirname ( config_settings [ \"source\" ] ) if config_settings . get ( \"source\" , None ) else os . getcwd () ) path_root = Path ( combined_config . get ( \"directory\" , project_root )). resolve () path_root = path_root if path_root . is_dir () else path_root . parent if \"src_paths\" not in combined_config : combined_config [ \"src_paths\" ] = frozenset (( path_root , path_root / \"src\" )) else : combined_config [ \"src_paths\" ] = frozenset ( path_root / path for path in combined_config . get ( \"src_paths\" , ()) ) # Remove any config values that are used for creating config object but # aren ' t defined in dataclass combined_config . pop ( \"source\" , None ) combined_config . pop ( \"sources\" , None ) combined_config . pop ( \"runtime_src_paths\" , None ) if known_other : for known_key in known_other : combined_config . pop ( f \"{KNOWN_PREFIX}{known_key}\" , None ) combined_config [ \"known_other\" ] = known_other if import_headings : for import_heading_key in import_headings : combined_config . pop ( f \"{IMPORT_HEADING_PREFIX}{import_heading_key}\" ) combined_config [ \"import_headings\" ] = import_headings self . _known_patterns : Optional [ List[Tuple[Pattern[str ] , str ]]] = None super (). __init__ ( sources = tuple ( sources ), ** combined_config ) # type : ignore def is_skipped ( self , file_path : Path ) -> bool : \"\"\"Returns True if the file and/or folder should be skipped based on current settings.\"\"\" if self . directory and Path ( self . directory ) in file_path . parents : file_name = os . path . relpath ( file_path , self . directory ) else : file_name = str ( file_path ) os_path = str ( file_path ) normalized_path = os_path . replace ( \"\\\\\" , \"/\" ) if normalized_path [ 1:2 ] == \":\" : normalized_path = normalized_path [ 2: ] for skip_path in self . skip : if posixpath . abspath ( normalized_path ) == posixpath . abspath ( skip_path . replace ( \"\\\\\" , \"/\" ) ) : return True position = os . path . split ( file_name ) while position [ 1 ] : if position [ 1 ] in self . skip : return True position = os . path . split ( position [ 0 ] ) for glob in self . skip_glob : if fnmatch . fnmatch ( file_name , glob ) or fnmatch . fnmatch ( \"/\" + file_name , glob ) : return True if not ( os . path . isfile ( os_path ) or os . path . isdir ( os_path ) or os . path . islink ( os_path )) : return True return False @property def known_patterns ( self ) : if self . _known_patterns is not None : return self . _known_patterns self . _known_patterns = [] for placement in reversed ( self . sections ) : known_placement = KNOWN_SECTION_MAPPING . get ( placement , placement ). lower () config_key = f \"{KNOWN_PREFIX}{known_placement}\" known_modules = getattr ( self , config_key , self . known_other . get ( known_placement , ())) extra_modules = getattr ( self , f \"extra_{known_placement}\" , ()) all_modules = set ( known_modules ). union ( extra_modules ) known_patterns = [ pattern for known_pattern in all_modules for pattern in self._parse_known_pattern(known_pattern) ] for known_pattern in known_patterns : regexp = \"^\" + known_pattern . replace ( \"*\" , \".*\" ). replace ( \"?\" , \".?\" ) + \"$\" self . _known_patterns . append (( re . compile ( regexp ), placement )) return self . _known_patterns @staticmethod def _parse_known_pattern ( pattern : str ) -> List [ str ] : \"\"\"Expand pattern if identified as a directory and return found sub packages\"\"\" if pattern . endswith ( os . path . sep ) : patterns = [ filename for filename in os.listdir(pattern) if os.path.isdir(os.path.join(pattern, filename)) ] else : patterns = [ pattern ] return patterns","title":"Config"},{"location":"reference/isort/settings/#ancestors-in-mro","text":"isort.settings._Config","title":"Ancestors (in MRO)"},{"location":"reference/isort/settings/#class-variables","text":"add_imports atomic balanced_wrapping case_sensitive combine_as_imports combine_star comment_prefix conda_env default_section directory ensure_newline_before_comments extra_standard_library force_adds force_alphabetical_sort force_alphabetical_sort_within_sections force_grid_wrap force_single_line force_sort_within_sections force_to_top forced_separate from_first ignore_comments ignore_whitespace include_trailing_comma indent keep_direct_and_as_imports known_first_party known_future_library known_standard_library known_third_party length_sort length_sort_sections lexicographical line_ending line_length lines_after_imports lines_between_sections lines_between_types multi_line_output no_inline_sort no_lines_before no_sections old_finders order_by_type profile py_version quiet remove_imports reverse_relative sections single_line_exclusions skip skip_glob sources src_paths use_parentheses verbose virtual_env wrap_length","title":"Class variables"},{"location":"reference/isort/settings/#instance-variables","text":"known_patterns","title":"Instance variables"},{"location":"reference/isort/settings/#methods","text":"","title":"Methods"},{"location":"reference/isort/settings/#is_skipped","text":"def is_skipped ( self , file_path : pathlib . Path ) -> bool Returns True if the file and/or folder should be skipped based on current settings. View Source def is_skipped ( self , file_path : Path ) -> bool : \"\"\"Returns True if the file and/or folder should be skipped based on current settings.\"\"\" if self . directory and Path ( self . directory ) in file_path . parents : file_name = os . path . relpath ( file_path , self . directory ) else : file_name = str ( file_path ) os_path = str ( file_path ) normalized_path = os_path . replace ( \"\\\\\" , \"/\" ) if normalized_path [ 1 : 2 ] == \":\" : normalized_path = normalized_path [ 2 :] for skip_path in self . skip : if posixpath . abspath ( normalized_path ) == posixpath . abspath ( skip_path . replace ( \"\\\\\" , \"/\" ) ): return True position = os . path . split ( file_name ) while position [ 1 ]: if position [ 1 ] in self . skip : return True position = os . path . split ( position [ 0 ]) for glob in self . skip_glob : if fnmatch . fnmatch ( file_name , glob ) or fnmatch . fnmatch ( \"/\" + file_name , glob ): return True if not ( os . path . isfile ( os_path ) or os . path . isdir ( os_path ) or os . path . islink ( os_path )): return True return False","title":"is_skipped"},{"location":"reference/isort/setuptools_commands/","text":"Module isort.setuptools_commands View Source import glob import os import sys from typing import Any , Dict , Iterator , List from warnings import warn import setuptools from . import api from .settings import DEFAULT_CONFIG class ISortCommand ( setuptools . Command ): \"\"\"The :class:`ISortCommand` class is used by setuptools to perform imports checks on registered modules. \"\"\" description = \"Run isort on modules registered in setuptools\" user_options : List [ Any ] = [] def initialize_options ( self ) -> None : default_settings = vars ( DEFAULT_CONFIG ) . copy () for key , value in default_settings . items (): setattr ( self , key , value ) def finalize_options ( self ) -> None : \"Get options from config files.\" self . arguments : Dict [ str , Any ] = {} # skipcq: PYL-W0201 self . arguments [ \"settings_path\" ] = os . getcwd () def distribution_files ( self ) -> Iterator [ str ]: \"\"\"Find distribution packages.\"\"\" # This is verbatim from flake8 if self . distribution . packages : package_dirs = self . distribution . package_dir or {} for package in self . distribution . packages : pkg_dir = package if package in package_dirs : pkg_dir = package_dirs [ package ] elif \"\" in package_dirs : pkg_dir = package_dirs [ \"\" ] + os . path . sep + pkg_dir yield pkg_dir . replace ( \".\" , os . path . sep ) if self . distribution . py_modules : for filename in self . distribution . py_modules : yield \" %s .py\" % filename # Don't miss the setup.py file itself yield \"setup.py\" def run ( self ) -> None : arguments = self . arguments wrong_sorted_files = False arguments [ \"check\" ] = True for path in self . distribution_files (): for python_file in glob . iglob ( os . path . join ( path , \"*.py\" )): try : if not api . check_file ( python_file , ** arguments ): wrong_sorted_files = True # pragma: no cover except OSError as error : # pragma: no cover warn ( f \"Unable to parse file {python_file} due to {error}\" ) if wrong_sorted_files : sys . exit ( 1 ) # pragma: no cover Classes ISortCommand class ISortCommand ( dist , ** kw ) The :class: ISortCommand class is used by setuptools to perform imports checks on registered modules. View Source class ISortCommand ( setuptools . Command ) : \"\"\"The :class:`ISortCommand` class is used by setuptools to perform imports checks on registered modules. \"\"\" description = \"Run isort on modules registered in setuptools\" user_options : List [ Any ] = [] def initialize_options ( self ) -> None : default_settings = vars ( DEFAULT_CONFIG ). copy () for key , value in default_settings . items () : setattr ( self , key , value ) def finalize_options ( self ) -> None : \"Get options from config files.\" self . arguments : Dict [ str, Any ] = {} # skipcq : PYL - W0201 self . arguments [ \"settings_path\" ] = os . getcwd () def distribution_files ( self ) -> Iterator [ str ] : \"\"\"Find distribution packages.\"\"\" # This is verbatim from flake8 if self . distribution . packages : package_dirs = self . distribution . package_dir or {} for package in self . distribution . packages : pkg_dir = package if package in package_dirs : pkg_dir = package_dirs [ package ] elif \"\" in package_dirs : pkg_dir = package_dirs [ \"\" ] + os . path . sep + pkg_dir yield pkg_dir . replace ( \".\" , os . path . sep ) if self . distribution . py_modules : for filename in self . distribution . py_modules : yield \"%s.py\" % filename # Don ' t miss the setup . py file itself yield \"setup.py\" def run ( self ) -> None : arguments = self . arguments wrong_sorted_files = False arguments [ \"check\" ] = True for path in self . distribution_files () : for python_file in glob . iglob ( os . path . join ( path , \"*.py\" )) : try : if not api . check_file ( python_file , ** arguments ) : wrong_sorted_files = True # pragma : no cover except OSError as error : # pragma : no cover warn ( f \"Unable to parse file {python_file} due to {error}\" ) if wrong_sorted_files : sys . exit ( 1 ) # pragma : no cover Ancestors (in MRO) setuptools.Command distutils.cmd.Command Class variables command_consumes_arguments description sub_commands user_options Methods announce def announce ( self , msg , level = 1 ) If the current verbosity level is of greater than or equal to 'level' print 'msg' to stdout. View Source def announce ( self , msg , level = 1 ): \"\"\"If the current verbosity level is of greater than or equal to 'level' print 'msg' to stdout. \"\"\" log . log ( level , msg ) copy_file def copy_file ( self , infile , outfile , preserve_mode = 1 , preserve_times = 1 , link = None , level = 1 ) Copy a file respecting verbose, dry-run and force flags. (The former two default to whatever is in the Distribution object, and the latter defaults to false for commands that don't define it.) View Source def copy_file ( self , infile , outfile , preserve_mode = 1 , preserve_times = 1 , link = None , level = 1 ): \"\"\"Copy a file respecting verbose, dry-run and force flags. (The former two default to whatever is in the Distribution object, and the latter defaults to false for commands that don't define it.)\"\"\" return file_util . copy_file ( infile , outfile , preserve_mode , preserve_times , not self . force , link , dry_run = self . dry_run ) copy_tree def copy_tree ( self , infile , outfile , preserve_mode = 1 , preserve_times = 1 , preserve_symlinks = 0 , level = 1 ) Copy an entire directory tree respecting verbose, dry-run, and force flags. View Source def copy_tree ( self , infile , outfile , preserve_mode = 1 , preserve_times = 1 , preserve_symlinks = 0 , level = 1 ): \"\"\"Copy an entire directory tree respecting verbose, dry-run, and force flags. \"\"\" return dir_util . copy_tree ( infile , outfile , preserve_mode , preserve_times , preserve_symlinks , not self . force , dry_run = self . dry_run ) debug_print def debug_print ( self , msg ) Print 'msg' to stdout if the global DEBUG (taken from the DISTUTILS_DEBUG environment variable) flag is true. View Source def debug_print ( self , msg ): \"\"\"Print 'msg' to stdout if the global DEBUG (taken from the DISTUTILS_DEBUG environment variable) flag is true. \"\"\" from distutils.debug import DEBUG if DEBUG : print ( msg ) sys . stdout . flush () distribution_files def distribution_files ( self ) -> Iterator [ str ] Find distribution packages. View Source def distribution_files ( self ) -> Iterator [ str ] : \"\"\"Find distribution packages.\"\"\" # This is verbatim from flake8 if self . distribution . packages : package_dirs = self . distribution . package_dir or {} for package in self . distribution . packages : pkg_dir = package if package in package_dirs : pkg_dir = package_dirs [ package ] elif \"\" in package_dirs : pkg_dir = package_dirs [ \"\" ] + os . path . sep + pkg_dir yield pkg_dir . replace ( \".\" , os . path . sep ) if self . distribution . py_modules : for filename in self . distribution . py_modules : yield \"%s.py\" % filename # Don ' t miss the setup . py file itself yield \"setup.py\" dump_options def dump_options ( self , header = None , indent = '' ) View Source def dump_options ( self , header = None , indent= \"\" ) : from distutils . fancy_getopt import longopt_xlate if header is None : header = \"command options for '%s':\" % self.get_command_name() self . announce ( indent + header , level = log . INFO ) indent = indent + \" \" for ( option , _ , _ ) in self . user_options: option = option . translate ( longopt_xlate ) if option [ - 1 ] == \"=\" : option = option [:- 1 ] value = getattr ( self , option ) self . announce ( indent + \"%s = %s\" % (option, value), level = log . INFO ) ensure_dirname def ensure_dirname ( self , option ) View Source def ensure_dirname ( self , option ): self . _ensure_tested_string ( option , os . path . isdir , \"directory name\" , \"'%s' does not exist or is not a directory\" ) ensure_filename def ensure_filename ( self , option ) Ensure that 'option' is the name of an existing file. View Source def ensure_filename ( self , option ): \"\"\"Ensure that 'option' is the name of an existing file.\"\"\" self . _ensure_tested_string ( option , os . path . isfile , \"filename\" , \"'%s' does not exist or is not a file\" ) ensure_finalized def ensure_finalized ( self ) View Source def ensure_finalized ( self ): if not self . finalized : self . finalize_options () self . finalized = 1 ensure_string def ensure_string ( self , option , default = None ) Ensure that 'option' is a string; if not defined, set it to 'default'. View Source def ensure_string ( self , option , default = None ): \"\"\"Ensure that 'option' is a string; if not defined, set it to 'default'. \"\"\" self . _ensure_stringlike ( option , \"string\" , default ) ensure_string_list def ensure_string_list ( self , option ) Ensure that 'option' is a list of strings. If 'option' is currently a string, we split it either on /,\\s*/ or /\\s+/, so \"foo bar baz\", \"foo,bar,baz\", and \"foo, bar baz\" all become [\"foo\", \"bar\", \"baz\"]. View Source def ensure_string_list(self, option): r \"\"\"Ensure that 'option' is a list of strings. If 'option' is currently a string, we split it either on /,\\s*/ or /\\s+/, so \" foo bar baz \", \" foo , bar , baz \", and \" foo , bar baz \" all become [\" foo \", \" bar \", \" baz \"]. \"\"\" val = getattr ( self , option ) if val is None: return elif isinstance(val, string_types): setattr ( self , option , re . split ( r ' , \\ s *|\\ s + ', val)) else: if isinstance(val, list): ok = all(isinstance(v, string_types) for v in val) else: ok = False if not ok: raise DistutilsOptionError( \"' %s' must be a list of strings (got %r)\" % (option, val)) execute def execute ( self , func , args , msg = None , level = 1 ) View Source def execute ( self , func , args , msg = None , level = 1 ): util . execute ( func , args , msg , dry_run = self . dry_run ) finalize_options def finalize_options ( self ) -> None Get options from config files. View Source def finalize_options ( self ) -> None : \"Get options from config files.\" self . arguments : Dict [ str , Any ] = {} # skipcq : PYL - W0201 self . arguments [ \"settings_path\" ] = os . getcwd () get_command_name def get_command_name ( self ) View Source def get_command_name ( self ): if hasattr ( self , 'command_name' ): return self . command_name else : return self . __class__ . __name__ get_finalized_command def get_finalized_command ( self , command , create = 1 ) Wrapper around Distribution's 'get_command_obj()' method: find (create if necessary and 'create' is true) the command object for 'command', call its 'ensure_finalized()' method, and return the finalized command object. View Source def get_finalized_command ( self , command , create = 1 ): \"\"\"Wrapper around Distribution's 'get_command_obj()' method: find (create if necessary and 'create' is true) the command object for 'command', call its 'ensure_finalized()' method, and return the finalized command object. \"\"\" cmd_obj = self . distribution . get_command_obj ( command , create ) cmd_obj . ensure_finalized () return cmd_obj get_sub_commands def get_sub_commands ( self ) Determine the sub-commands that are relevant in the current distribution (ie., that need to be run). This is based on the 'sub_commands' class attribute: each tuple in that list may include a method that we call to determine if the subcommand needs to be run for the current distribution. Return a list of command names. View Source def get_sub_commands ( self ): \"\"\"Determine the sub-commands that are relevant in the current distribution (ie., that need to be run). This is based on the 'sub_commands' class attribute: each tuple in that list may include a method that we call to determine if the subcommand needs to be run for the current distribution. Return a list of command names. \"\"\" commands = [] for ( cmd_name , method ) in self . sub_commands : if method is None or method ( self ): commands . append ( cmd_name ) return commands initialize_options def initialize_options ( self ) -> None Set default values for all the options that this command supports. Note that these defaults may be overridden by other commands, by the setup script, by config files, or by the command-line. Thus, this is not the place to code dependencies between options; generally, 'initialize_options()' implementations are just a bunch of \"self.foo = None\" assignments. This method must be implemented by all command classes. View Source def initialize_options ( self ) -> None : default_settings = vars ( DEFAULT_CONFIG ). copy () for key , value in default_settings . items (): setattr ( self , key , value ) make_archive def make_archive ( self , base_name , format , root_dir = None , base_dir = None , owner = None , group = None ) View Source def make_archive ( self , base_name , format , root_dir = None , base_dir = None , owner = None , group = None ): return archive_util . make_archive ( base_name , format , root_dir , base_dir , dry_run = self . dry_run , owner = owner , group = group ) make_file def make_file ( self , infiles , outfile , func , args , exec_msg = None , skip_msg = None , level = 1 ) Special case of 'execute()' for operations that process one or more input files and generate one output file. Works just like 'execute()', except the operation is skipped and a different message printed if 'outfile' already exists and is newer than all files listed in 'infiles'. If the command defined 'self.force', and it is true, then the command is unconditionally run -- does no timestamp checks. View Source def make_file ( self , infiles , outfile , func , args , exec_msg = None , skip_msg = None , level = 1 ): \"\"\"Special case of 'execute()' for operations that process one or more input files and generate one output file. Works just like 'execute()', except the operation is skipped and a different message printed if 'outfile' already exists and is newer than all files listed in 'infiles'. If the command defined 'self.force', and it is true, then the command is unconditionally run -- does no timestamp checks. \"\"\" if skip_msg is None : skip_msg = \"skipping %s (inputs unchanged)\" % outfile # Allow 'infiles' to be a single string if isinstance ( infiles , str ): infiles = ( infiles ,) elif not isinstance ( infiles , ( list , tuple )): raise TypeError ( \"'infiles' must be a string, or a list or tuple of strings\" ) if exec_msg is None : exec_msg = \"generating %s from %s\" % ( outfile , ', ' . join ( infiles )) # If 'outfile' must be regenerated ( either because it doesn 't # exist, is out-of-date, or the ' force ' flag is true ) then # perform the action that presumably regenerates it if self . force or dep_util . newer_group ( infiles , outfile ): self . execute ( func , args , exec_msg , level ) # Otherwise , print the \"skip\" message else : log . debug ( skip_msg ) mkpath def mkpath ( self , name , mode = 511 ) View Source def mkpath ( self , name , mode = 0 o777 ): dir_util . mkpath ( name , mode , dry_run = self . dry_run ) move_file def move_file ( self , src , dst , level = 1 ) Move a file respecting dry-run flag. View Source def move_file ( self , src , dst , level = 1 ): \"\"\"Move a file respecting dry-run flag.\"\"\" return file_util . move_file ( src , dst , dry_run = self . dry_run ) reinitialize_command def reinitialize_command ( self , command , reinit_subcommands = 0 , ** kw ) View Source def reinitialize_command ( self , command , reinit_subcommands = 0 , ** kw ): cmd = _Command . reinitialize_command ( self , command , reinit_subcommands ) vars ( cmd ). update ( kw ) return cmd run def run ( self ) -> None A command's raison d'etre: carry out the action it exists to perform, controlled by the options initialized in 'initialize_options()', customized by other commands, the setup script, the command-line, and config files, and finalized in 'finalize_options()'. All terminal output and filesystem interaction should be done by 'run()'. This method must be implemented by all command classes. View Source def run ( self ) -> None : arguments = self . arguments wrong_sorted_files = False arguments [ \"check\" ] = True for path in self . distribution_files (): for python_file in glob . iglob ( os . path . join ( path , \"*.py\" )): try : if not api . check_file ( python_file , ** arguments ): wrong_sorted_files = True # pragma : no cover except OSError as error : # pragma : no cover warn ( f \"Unable to parse file {python_file} due to {error}\" ) if wrong_sorted_files : sys . exit ( 1 ) # pragma : no cover run_command def run_command ( self , command ) Run some other command: uses the 'run_command()' method of Distribution, which creates and finalizes the command object if necessary and then invokes its 'run()' method. View Source def run_command ( self , command ): \"\"\"Run some other command: uses the 'run_command()' method of Distribution, which creates and finalizes the command object if necessary and then invokes its 'run()' method. \"\"\" self . distribution . run_command ( command ) set_undefined_options def set_undefined_options ( self , src_cmd , * option_pairs ) Set the values of any \"undefined\" options from corresponding option values in some other command object. \"Undefined\" here means \"is None\", which is the convention used to indicate that an option has not been changed between 'initialize_options()' and 'finalize_options()'. Usually called from 'finalize_options()' for options that depend on some other command rather than another option of the same command. 'src_cmd' is the other command from which option values will be taken (a command object will be created for it if necessary); the remaining arguments are '(src_option,dst_option)' tuples which mean \"take the value of 'src_option' in the 'src_cmd' command object, and copy it to 'dst_option' in the current command object\". View Source def set_undefined_options ( self , src_cmd , * option_pairs ): \"\"\"Set the values of any \" undefined \" options from corresponding option values in some other command object. \" Undefined \" here means \" is None \", which is the convention used to indicate that an option has not been changed between 'initialize_options()' and 'finalize_options()'. Usually called from 'finalize_options()' for options that depend on some other command rather than another option of the same command. 'src_cmd' is the other command from which option values will be taken (a command object will be created for it if necessary); the remaining arguments are '(src_option,dst_option)' tuples which mean \" take the value of 'src_option' in the 'src_cmd' command object , and copy it to 'dst_option' in the current command object \". \"\"\" # Option_pairs : list of ( src_option , dst_option ) tuples src_cmd_obj = self . distribution . get_command_obj ( src_cmd ) src_cmd_obj . ensure_finalized () for ( src_option , dst_option ) in option_pairs : if getattr ( self , dst_option ) is None : setattr ( self , dst_option , getattr ( src_cmd_obj , src_option )) spawn def spawn ( self , cmd , search_path = 1 , level = 1 ) Spawn an external command respecting dry-run flag. View Source def spawn ( self , cmd , search_path = 1 , level = 1 ): \"\"\"Spawn an external command respecting dry-run flag.\"\"\" from distutils.spawn import spawn spawn ( cmd , search_path , dry_run = self . dry_run ) warn def warn ( self , msg ) View Source def warn ( self , msg ): log . warn ( \"warning: %s: %s\\n\" , self . get_command_name (), msg )","title":"Setuptools Commands"},{"location":"reference/isort/setuptools_commands/#module-isortsetuptools_commands","text":"View Source import glob import os import sys from typing import Any , Dict , Iterator , List from warnings import warn import setuptools from . import api from .settings import DEFAULT_CONFIG class ISortCommand ( setuptools . Command ): \"\"\"The :class:`ISortCommand` class is used by setuptools to perform imports checks on registered modules. \"\"\" description = \"Run isort on modules registered in setuptools\" user_options : List [ Any ] = [] def initialize_options ( self ) -> None : default_settings = vars ( DEFAULT_CONFIG ) . copy () for key , value in default_settings . items (): setattr ( self , key , value ) def finalize_options ( self ) -> None : \"Get options from config files.\" self . arguments : Dict [ str , Any ] = {} # skipcq: PYL-W0201 self . arguments [ \"settings_path\" ] = os . getcwd () def distribution_files ( self ) -> Iterator [ str ]: \"\"\"Find distribution packages.\"\"\" # This is verbatim from flake8 if self . distribution . packages : package_dirs = self . distribution . package_dir or {} for package in self . distribution . packages : pkg_dir = package if package in package_dirs : pkg_dir = package_dirs [ package ] elif \"\" in package_dirs : pkg_dir = package_dirs [ \"\" ] + os . path . sep + pkg_dir yield pkg_dir . replace ( \".\" , os . path . sep ) if self . distribution . py_modules : for filename in self . distribution . py_modules : yield \" %s .py\" % filename # Don't miss the setup.py file itself yield \"setup.py\" def run ( self ) -> None : arguments = self . arguments wrong_sorted_files = False arguments [ \"check\" ] = True for path in self . distribution_files (): for python_file in glob . iglob ( os . path . join ( path , \"*.py\" )): try : if not api . check_file ( python_file , ** arguments ): wrong_sorted_files = True # pragma: no cover except OSError as error : # pragma: no cover warn ( f \"Unable to parse file {python_file} due to {error}\" ) if wrong_sorted_files : sys . exit ( 1 ) # pragma: no cover","title":"Module isort.setuptools_commands"},{"location":"reference/isort/setuptools_commands/#classes","text":"","title":"Classes"},{"location":"reference/isort/setuptools_commands/#isortcommand","text":"class ISortCommand ( dist , ** kw ) The :class: ISortCommand class is used by setuptools to perform imports checks on registered modules. View Source class ISortCommand ( setuptools . Command ) : \"\"\"The :class:`ISortCommand` class is used by setuptools to perform imports checks on registered modules. \"\"\" description = \"Run isort on modules registered in setuptools\" user_options : List [ Any ] = [] def initialize_options ( self ) -> None : default_settings = vars ( DEFAULT_CONFIG ). copy () for key , value in default_settings . items () : setattr ( self , key , value ) def finalize_options ( self ) -> None : \"Get options from config files.\" self . arguments : Dict [ str, Any ] = {} # skipcq : PYL - W0201 self . arguments [ \"settings_path\" ] = os . getcwd () def distribution_files ( self ) -> Iterator [ str ] : \"\"\"Find distribution packages.\"\"\" # This is verbatim from flake8 if self . distribution . packages : package_dirs = self . distribution . package_dir or {} for package in self . distribution . packages : pkg_dir = package if package in package_dirs : pkg_dir = package_dirs [ package ] elif \"\" in package_dirs : pkg_dir = package_dirs [ \"\" ] + os . path . sep + pkg_dir yield pkg_dir . replace ( \".\" , os . path . sep ) if self . distribution . py_modules : for filename in self . distribution . py_modules : yield \"%s.py\" % filename # Don ' t miss the setup . py file itself yield \"setup.py\" def run ( self ) -> None : arguments = self . arguments wrong_sorted_files = False arguments [ \"check\" ] = True for path in self . distribution_files () : for python_file in glob . iglob ( os . path . join ( path , \"*.py\" )) : try : if not api . check_file ( python_file , ** arguments ) : wrong_sorted_files = True # pragma : no cover except OSError as error : # pragma : no cover warn ( f \"Unable to parse file {python_file} due to {error}\" ) if wrong_sorted_files : sys . exit ( 1 ) # pragma : no cover","title":"ISortCommand"},{"location":"reference/isort/setuptools_commands/#ancestors-in-mro","text":"setuptools.Command distutils.cmd.Command","title":"Ancestors (in MRO)"},{"location":"reference/isort/setuptools_commands/#class-variables","text":"command_consumes_arguments description sub_commands user_options","title":"Class variables"},{"location":"reference/isort/setuptools_commands/#methods","text":"","title":"Methods"},{"location":"reference/isort/setuptools_commands/#announce","text":"def announce ( self , msg , level = 1 ) If the current verbosity level is of greater than or equal to 'level' print 'msg' to stdout. View Source def announce ( self , msg , level = 1 ): \"\"\"If the current verbosity level is of greater than or equal to 'level' print 'msg' to stdout. \"\"\" log . log ( level , msg )","title":"announce"},{"location":"reference/isort/setuptools_commands/#copy_file","text":"def copy_file ( self , infile , outfile , preserve_mode = 1 , preserve_times = 1 , link = None , level = 1 ) Copy a file respecting verbose, dry-run and force flags. (The former two default to whatever is in the Distribution object, and the latter defaults to false for commands that don't define it.) View Source def copy_file ( self , infile , outfile , preserve_mode = 1 , preserve_times = 1 , link = None , level = 1 ): \"\"\"Copy a file respecting verbose, dry-run and force flags. (The former two default to whatever is in the Distribution object, and the latter defaults to false for commands that don't define it.)\"\"\" return file_util . copy_file ( infile , outfile , preserve_mode , preserve_times , not self . force , link , dry_run = self . dry_run )","title":"copy_file"},{"location":"reference/isort/setuptools_commands/#copy_tree","text":"def copy_tree ( self , infile , outfile , preserve_mode = 1 , preserve_times = 1 , preserve_symlinks = 0 , level = 1 ) Copy an entire directory tree respecting verbose, dry-run, and force flags. View Source def copy_tree ( self , infile , outfile , preserve_mode = 1 , preserve_times = 1 , preserve_symlinks = 0 , level = 1 ): \"\"\"Copy an entire directory tree respecting verbose, dry-run, and force flags. \"\"\" return dir_util . copy_tree ( infile , outfile , preserve_mode , preserve_times , preserve_symlinks , not self . force , dry_run = self . dry_run )","title":"copy_tree"},{"location":"reference/isort/setuptools_commands/#debug_print","text":"def debug_print ( self , msg ) Print 'msg' to stdout if the global DEBUG (taken from the DISTUTILS_DEBUG environment variable) flag is true. View Source def debug_print ( self , msg ): \"\"\"Print 'msg' to stdout if the global DEBUG (taken from the DISTUTILS_DEBUG environment variable) flag is true. \"\"\" from distutils.debug import DEBUG if DEBUG : print ( msg ) sys . stdout . flush ()","title":"debug_print"},{"location":"reference/isort/setuptools_commands/#distribution_files","text":"def distribution_files ( self ) -> Iterator [ str ] Find distribution packages. View Source def distribution_files ( self ) -> Iterator [ str ] : \"\"\"Find distribution packages.\"\"\" # This is verbatim from flake8 if self . distribution . packages : package_dirs = self . distribution . package_dir or {} for package in self . distribution . packages : pkg_dir = package if package in package_dirs : pkg_dir = package_dirs [ package ] elif \"\" in package_dirs : pkg_dir = package_dirs [ \"\" ] + os . path . sep + pkg_dir yield pkg_dir . replace ( \".\" , os . path . sep ) if self . distribution . py_modules : for filename in self . distribution . py_modules : yield \"%s.py\" % filename # Don ' t miss the setup . py file itself yield \"setup.py\"","title":"distribution_files"},{"location":"reference/isort/setuptools_commands/#dump_options","text":"def dump_options ( self , header = None , indent = '' ) View Source def dump_options ( self , header = None , indent= \"\" ) : from distutils . fancy_getopt import longopt_xlate if header is None : header = \"command options for '%s':\" % self.get_command_name() self . announce ( indent + header , level = log . INFO ) indent = indent + \" \" for ( option , _ , _ ) in self . user_options: option = option . translate ( longopt_xlate ) if option [ - 1 ] == \"=\" : option = option [:- 1 ] value = getattr ( self , option ) self . announce ( indent + \"%s = %s\" % (option, value), level = log . INFO )","title":"dump_options"},{"location":"reference/isort/setuptools_commands/#ensure_dirname","text":"def ensure_dirname ( self , option ) View Source def ensure_dirname ( self , option ): self . _ensure_tested_string ( option , os . path . isdir , \"directory name\" , \"'%s' does not exist or is not a directory\" )","title":"ensure_dirname"},{"location":"reference/isort/setuptools_commands/#ensure_filename","text":"def ensure_filename ( self , option ) Ensure that 'option' is the name of an existing file. View Source def ensure_filename ( self , option ): \"\"\"Ensure that 'option' is the name of an existing file.\"\"\" self . _ensure_tested_string ( option , os . path . isfile , \"filename\" , \"'%s' does not exist or is not a file\" )","title":"ensure_filename"},{"location":"reference/isort/setuptools_commands/#ensure_finalized","text":"def ensure_finalized ( self ) View Source def ensure_finalized ( self ): if not self . finalized : self . finalize_options () self . finalized = 1","title":"ensure_finalized"},{"location":"reference/isort/setuptools_commands/#ensure_string","text":"def ensure_string ( self , option , default = None ) Ensure that 'option' is a string; if not defined, set it to 'default'. View Source def ensure_string ( self , option , default = None ): \"\"\"Ensure that 'option' is a string; if not defined, set it to 'default'. \"\"\" self . _ensure_stringlike ( option , \"string\" , default )","title":"ensure_string"},{"location":"reference/isort/setuptools_commands/#ensure_string_list","text":"def ensure_string_list ( self , option ) Ensure that 'option' is a list of strings. If 'option' is currently a string, we split it either on /,\\s*/ or /\\s+/, so \"foo bar baz\", \"foo,bar,baz\", and \"foo, bar baz\" all become [\"foo\", \"bar\", \"baz\"]. View Source def ensure_string_list(self, option): r \"\"\"Ensure that 'option' is a list of strings. If 'option' is currently a string, we split it either on /,\\s*/ or /\\s+/, so \" foo bar baz \", \" foo , bar , baz \", and \" foo , bar baz \" all become [\" foo \", \" bar \", \" baz \"]. \"\"\" val = getattr ( self , option ) if val is None: return elif isinstance(val, string_types): setattr ( self , option , re . split ( r ' , \\ s *|\\ s + ', val)) else: if isinstance(val, list): ok = all(isinstance(v, string_types) for v in val) else: ok = False if not ok: raise DistutilsOptionError( \"' %s' must be a list of strings (got %r)\" % (option, val))","title":"ensure_string_list"},{"location":"reference/isort/setuptools_commands/#execute","text":"def execute ( self , func , args , msg = None , level = 1 ) View Source def execute ( self , func , args , msg = None , level = 1 ): util . execute ( func , args , msg , dry_run = self . dry_run )","title":"execute"},{"location":"reference/isort/setuptools_commands/#finalize_options","text":"def finalize_options ( self ) -> None Get options from config files. View Source def finalize_options ( self ) -> None : \"Get options from config files.\" self . arguments : Dict [ str , Any ] = {} # skipcq : PYL - W0201 self . arguments [ \"settings_path\" ] = os . getcwd ()","title":"finalize_options"},{"location":"reference/isort/setuptools_commands/#get_command_name","text":"def get_command_name ( self ) View Source def get_command_name ( self ): if hasattr ( self , 'command_name' ): return self . command_name else : return self . __class__ . __name__","title":"get_command_name"},{"location":"reference/isort/setuptools_commands/#get_finalized_command","text":"def get_finalized_command ( self , command , create = 1 ) Wrapper around Distribution's 'get_command_obj()' method: find (create if necessary and 'create' is true) the command object for 'command', call its 'ensure_finalized()' method, and return the finalized command object. View Source def get_finalized_command ( self , command , create = 1 ): \"\"\"Wrapper around Distribution's 'get_command_obj()' method: find (create if necessary and 'create' is true) the command object for 'command', call its 'ensure_finalized()' method, and return the finalized command object. \"\"\" cmd_obj = self . distribution . get_command_obj ( command , create ) cmd_obj . ensure_finalized () return cmd_obj","title":"get_finalized_command"},{"location":"reference/isort/setuptools_commands/#get_sub_commands","text":"def get_sub_commands ( self ) Determine the sub-commands that are relevant in the current distribution (ie., that need to be run). This is based on the 'sub_commands' class attribute: each tuple in that list may include a method that we call to determine if the subcommand needs to be run for the current distribution. Return a list of command names. View Source def get_sub_commands ( self ): \"\"\"Determine the sub-commands that are relevant in the current distribution (ie., that need to be run). This is based on the 'sub_commands' class attribute: each tuple in that list may include a method that we call to determine if the subcommand needs to be run for the current distribution. Return a list of command names. \"\"\" commands = [] for ( cmd_name , method ) in self . sub_commands : if method is None or method ( self ): commands . append ( cmd_name ) return commands","title":"get_sub_commands"},{"location":"reference/isort/setuptools_commands/#initialize_options","text":"def initialize_options ( self ) -> None Set default values for all the options that this command supports. Note that these defaults may be overridden by other commands, by the setup script, by config files, or by the command-line. Thus, this is not the place to code dependencies between options; generally, 'initialize_options()' implementations are just a bunch of \"self.foo = None\" assignments. This method must be implemented by all command classes. View Source def initialize_options ( self ) -> None : default_settings = vars ( DEFAULT_CONFIG ). copy () for key , value in default_settings . items (): setattr ( self , key , value )","title":"initialize_options"},{"location":"reference/isort/setuptools_commands/#make_archive","text":"def make_archive ( self , base_name , format , root_dir = None , base_dir = None , owner = None , group = None ) View Source def make_archive ( self , base_name , format , root_dir = None , base_dir = None , owner = None , group = None ): return archive_util . make_archive ( base_name , format , root_dir , base_dir , dry_run = self . dry_run , owner = owner , group = group )","title":"make_archive"},{"location":"reference/isort/setuptools_commands/#make_file","text":"def make_file ( self , infiles , outfile , func , args , exec_msg = None , skip_msg = None , level = 1 ) Special case of 'execute()' for operations that process one or more input files and generate one output file. Works just like 'execute()', except the operation is skipped and a different message printed if 'outfile' already exists and is newer than all files listed in 'infiles'. If the command defined 'self.force', and it is true, then the command is unconditionally run -- does no timestamp checks. View Source def make_file ( self , infiles , outfile , func , args , exec_msg = None , skip_msg = None , level = 1 ): \"\"\"Special case of 'execute()' for operations that process one or more input files and generate one output file. Works just like 'execute()', except the operation is skipped and a different message printed if 'outfile' already exists and is newer than all files listed in 'infiles'. If the command defined 'self.force', and it is true, then the command is unconditionally run -- does no timestamp checks. \"\"\" if skip_msg is None : skip_msg = \"skipping %s (inputs unchanged)\" % outfile # Allow 'infiles' to be a single string if isinstance ( infiles , str ): infiles = ( infiles ,) elif not isinstance ( infiles , ( list , tuple )): raise TypeError ( \"'infiles' must be a string, or a list or tuple of strings\" ) if exec_msg is None : exec_msg = \"generating %s from %s\" % ( outfile , ', ' . join ( infiles )) # If 'outfile' must be regenerated ( either because it doesn 't # exist, is out-of-date, or the ' force ' flag is true ) then # perform the action that presumably regenerates it if self . force or dep_util . newer_group ( infiles , outfile ): self . execute ( func , args , exec_msg , level ) # Otherwise , print the \"skip\" message else : log . debug ( skip_msg )","title":"make_file"},{"location":"reference/isort/setuptools_commands/#mkpath","text":"def mkpath ( self , name , mode = 511 ) View Source def mkpath ( self , name , mode = 0 o777 ): dir_util . mkpath ( name , mode , dry_run = self . dry_run )","title":"mkpath"},{"location":"reference/isort/setuptools_commands/#move_file","text":"def move_file ( self , src , dst , level = 1 ) Move a file respecting dry-run flag. View Source def move_file ( self , src , dst , level = 1 ): \"\"\"Move a file respecting dry-run flag.\"\"\" return file_util . move_file ( src , dst , dry_run = self . dry_run )","title":"move_file"},{"location":"reference/isort/setuptools_commands/#reinitialize_command","text":"def reinitialize_command ( self , command , reinit_subcommands = 0 , ** kw ) View Source def reinitialize_command ( self , command , reinit_subcommands = 0 , ** kw ): cmd = _Command . reinitialize_command ( self , command , reinit_subcommands ) vars ( cmd ). update ( kw ) return cmd","title":"reinitialize_command"},{"location":"reference/isort/setuptools_commands/#run","text":"def run ( self ) -> None A command's raison d'etre: carry out the action it exists to perform, controlled by the options initialized in 'initialize_options()', customized by other commands, the setup script, the command-line, and config files, and finalized in 'finalize_options()'. All terminal output and filesystem interaction should be done by 'run()'. This method must be implemented by all command classes. View Source def run ( self ) -> None : arguments = self . arguments wrong_sorted_files = False arguments [ \"check\" ] = True for path in self . distribution_files (): for python_file in glob . iglob ( os . path . join ( path , \"*.py\" )): try : if not api . check_file ( python_file , ** arguments ): wrong_sorted_files = True # pragma : no cover except OSError as error : # pragma : no cover warn ( f \"Unable to parse file {python_file} due to {error}\" ) if wrong_sorted_files : sys . exit ( 1 ) # pragma : no cover","title":"run"},{"location":"reference/isort/setuptools_commands/#run_command","text":"def run_command ( self , command ) Run some other command: uses the 'run_command()' method of Distribution, which creates and finalizes the command object if necessary and then invokes its 'run()' method. View Source def run_command ( self , command ): \"\"\"Run some other command: uses the 'run_command()' method of Distribution, which creates and finalizes the command object if necessary and then invokes its 'run()' method. \"\"\" self . distribution . run_command ( command )","title":"run_command"},{"location":"reference/isort/setuptools_commands/#set_undefined_options","text":"def set_undefined_options ( self , src_cmd , * option_pairs ) Set the values of any \"undefined\" options from corresponding option values in some other command object. \"Undefined\" here means \"is None\", which is the convention used to indicate that an option has not been changed between 'initialize_options()' and 'finalize_options()'. Usually called from 'finalize_options()' for options that depend on some other command rather than another option of the same command. 'src_cmd' is the other command from which option values will be taken (a command object will be created for it if necessary); the remaining arguments are '(src_option,dst_option)' tuples which mean \"take the value of 'src_option' in the 'src_cmd' command object, and copy it to 'dst_option' in the current command object\". View Source def set_undefined_options ( self , src_cmd , * option_pairs ): \"\"\"Set the values of any \" undefined \" options from corresponding option values in some other command object. \" Undefined \" here means \" is None \", which is the convention used to indicate that an option has not been changed between 'initialize_options()' and 'finalize_options()'. Usually called from 'finalize_options()' for options that depend on some other command rather than another option of the same command. 'src_cmd' is the other command from which option values will be taken (a command object will be created for it if necessary); the remaining arguments are '(src_option,dst_option)' tuples which mean \" take the value of 'src_option' in the 'src_cmd' command object , and copy it to 'dst_option' in the current command object \". \"\"\" # Option_pairs : list of ( src_option , dst_option ) tuples src_cmd_obj = self . distribution . get_command_obj ( src_cmd ) src_cmd_obj . ensure_finalized () for ( src_option , dst_option ) in option_pairs : if getattr ( self , dst_option ) is None : setattr ( self , dst_option , getattr ( src_cmd_obj , src_option ))","title":"set_undefined_options"},{"location":"reference/isort/setuptools_commands/#spawn","text":"def spawn ( self , cmd , search_path = 1 , level = 1 ) Spawn an external command respecting dry-run flag. View Source def spawn ( self , cmd , search_path = 1 , level = 1 ): \"\"\"Spawn an external command respecting dry-run flag.\"\"\" from distutils.spawn import spawn spawn ( cmd , search_path , dry_run = self . dry_run )","title":"spawn"},{"location":"reference/isort/setuptools_commands/#warn","text":"def warn ( self , msg ) View Source def warn ( self , msg ): log . warn ( \"warning: %s: %s\\n\" , self . get_command_name (), msg )","title":"warn"},{"location":"reference/isort/sorting/","text":"Module isort.sorting View Source import re from typing import Any , Callable , Iterable , List , Optional from .settings import Config _import_line_intro_re = re . compile ( \"^(?:from|import) \" ) _import_line_midline_import_re = re . compile ( \" import \" ) def module_key ( module_name : str , config : Config , sub_imports : bool = False , ignore_case : bool = False , section_name : Optional [ Any ] = None , ) -> str : match = re . match ( r \"^(\\.+)\\s*(.*)\" , module_name ) if match : sep = \" \" if config . reverse_relative else \"_\" module_name = sep . join ( match . groups ()) prefix = \"\" if ignore_case : module_name = str ( module_name ) . lower () else : module_name = str ( module_name ) if sub_imports and config . order_by_type : if module_name . isupper () and len ( module_name ) > 1 : # see issue #376 prefix = \"A\" elif module_name [ 0 : 1 ] . isupper (): prefix = \"B\" else : prefix = \"C\" if not config . case_sensitive : module_name = module_name . lower () length_sort = config . length_sort or str ( section_name ) . lower () in config . length_sort_sections _length_sort_maybe = length_sort and ( str ( len ( module_name )) + \":\" + module_name ) or module_name return f \"{module_name in config.force_to_top and 'A' or 'B'}{prefix}{_length_sort_maybe}\" def section_key ( line : str , order_by_type : bool , force_to_top : List [ str ], lexicographical : bool = False , length_sort : bool = False , ) -> str : section = \"B\" if lexicographical : line = _import_line_intro_re . sub ( \"\" , _import_line_midline_import_re . sub ( \".\" , line )) else : line = re . sub ( \"^from \" , \"\" , line ) line = re . sub ( \"^import \" , \"\" , line ) if line . split ( \" \" )[ 0 ] in force_to_top : section = \"A\" if not order_by_type : line = line . lower () return f \"{section}{len(line) if length_sort else ''}{line}\" def naturally ( to_sort : Iterable [ str ], key : Optional [ Callable [[ str ], Any ]] = None ) -> List [ str ]: \"\"\"Returns a naturally sorted list\"\"\" if key is None : key_callback = _natural_keys else : def key_callback ( text : str ) -> List [ Any ]: return _natural_keys ( key ( text )) # type: ignore return sorted ( to_sort , key = key_callback ) def _atoi ( text : str ) -> Any : return int ( text ) if text . isdigit () else text def _natural_keys ( text : str ) -> List [ Any ]: return [ _atoi ( c ) for c in re . split ( r \"(\\d+)\" , text )] Functions module_key def module_key ( module_name : str , config : isort . settings . Config , sub_imports : bool = False , ignore_case : bool = False , section_name : Union [ Any , NoneType ] = None ) -> str View Source def module_key ( module_name : str , config : Config , sub_imports : bool = False , ignore_case : bool = False , section_name : Optional [ Any ] = None , ) -> str : match = re . match ( r \"^(\\.+)\\s*(.*)\" , module_name ) if match : sep = \" \" if config . reverse_relative else \"_\" module_name = sep . join ( match . groups ()) prefix = \"\" if ignore_case : module_name = str ( module_name ). lower () else : module_name = str ( module_name ) if sub_imports and config . order_by_type : if module_name . isupper () and len ( module_name ) > 1 : # see issue #376 prefix = \"A\" elif module_name [ 0:1 ] . isupper () : prefix = \"B\" else : prefix = \"C\" if not config . case_sensitive : module_name = module_name . lower () length_sort = config . length_sort or str ( section_name ). lower () in config . length_sort_sections _length_sort_maybe = length_sort and ( str ( len ( module_name )) + \":\" + module_name ) or module_name return f \"{module_name in config.force_to_top and 'A' or 'B'}{prefix}{_length_sort_maybe}\" naturally def naturally ( to_sort : Iterable [ str ], key : Union [ Callable [[ str ], Any ], NoneType ] = None ) -> List [ str ] Returns a naturally sorted list View Source def naturally ( to_sort : Iterable [ str ] , key : Optional [ Callable[[str ] , Any ]] = None ) -> List [ str ] : \"\"\"Returns a naturally sorted list\"\"\" if key is None : key_callback = _natural_keys else : def key_callback ( text : str ) -> List [ Any ] : return _natural_keys ( key ( text )) # type : ignore return sorted ( to_sort , key = key_callback ) section_key def section_key ( line : str , order_by_type : bool , force_to_top : List [ str ], lexicographical : bool = False , length_sort : bool = False ) -> str View Source def section_key ( line : str , order_by_type : bool , force_to_top : List [ str ], lexicographical : bool = False , length_sort : bool = False , ) -> str : section = \"B\" if lexicographical : line = _import_line_intro_re . sub ( \"\" , _import_line_midline_import_re . sub ( \".\" , line )) else : line = re . sub ( \"^from \" , \"\" , line ) line = re . sub ( \"^import \" , \"\" , line ) if line . split ( \" \" )[ 0 ] in force_to_top : section = \"A\" if not order_by_type : line = line . lower () return f \"{section}{len(line) if length_sort else ''}{line}\"","title":"Sorting"},{"location":"reference/isort/sorting/#module-isortsorting","text":"View Source import re from typing import Any , Callable , Iterable , List , Optional from .settings import Config _import_line_intro_re = re . compile ( \"^(?:from|import) \" ) _import_line_midline_import_re = re . compile ( \" import \" ) def module_key ( module_name : str , config : Config , sub_imports : bool = False , ignore_case : bool = False , section_name : Optional [ Any ] = None , ) -> str : match = re . match ( r \"^(\\.+)\\s*(.*)\" , module_name ) if match : sep = \" \" if config . reverse_relative else \"_\" module_name = sep . join ( match . groups ()) prefix = \"\" if ignore_case : module_name = str ( module_name ) . lower () else : module_name = str ( module_name ) if sub_imports and config . order_by_type : if module_name . isupper () and len ( module_name ) > 1 : # see issue #376 prefix = \"A\" elif module_name [ 0 : 1 ] . isupper (): prefix = \"B\" else : prefix = \"C\" if not config . case_sensitive : module_name = module_name . lower () length_sort = config . length_sort or str ( section_name ) . lower () in config . length_sort_sections _length_sort_maybe = length_sort and ( str ( len ( module_name )) + \":\" + module_name ) or module_name return f \"{module_name in config.force_to_top and 'A' or 'B'}{prefix}{_length_sort_maybe}\" def section_key ( line : str , order_by_type : bool , force_to_top : List [ str ], lexicographical : bool = False , length_sort : bool = False , ) -> str : section = \"B\" if lexicographical : line = _import_line_intro_re . sub ( \"\" , _import_line_midline_import_re . sub ( \".\" , line )) else : line = re . sub ( \"^from \" , \"\" , line ) line = re . sub ( \"^import \" , \"\" , line ) if line . split ( \" \" )[ 0 ] in force_to_top : section = \"A\" if not order_by_type : line = line . lower () return f \"{section}{len(line) if length_sort else ''}{line}\" def naturally ( to_sort : Iterable [ str ], key : Optional [ Callable [[ str ], Any ]] = None ) -> List [ str ]: \"\"\"Returns a naturally sorted list\"\"\" if key is None : key_callback = _natural_keys else : def key_callback ( text : str ) -> List [ Any ]: return _natural_keys ( key ( text )) # type: ignore return sorted ( to_sort , key = key_callback ) def _atoi ( text : str ) -> Any : return int ( text ) if text . isdigit () else text def _natural_keys ( text : str ) -> List [ Any ]: return [ _atoi ( c ) for c in re . split ( r \"(\\d+)\" , text )]","title":"Module isort.sorting"},{"location":"reference/isort/sorting/#functions","text":"","title":"Functions"},{"location":"reference/isort/sorting/#module_key","text":"def module_key ( module_name : str , config : isort . settings . Config , sub_imports : bool = False , ignore_case : bool = False , section_name : Union [ Any , NoneType ] = None ) -> str View Source def module_key ( module_name : str , config : Config , sub_imports : bool = False , ignore_case : bool = False , section_name : Optional [ Any ] = None , ) -> str : match = re . match ( r \"^(\\.+)\\s*(.*)\" , module_name ) if match : sep = \" \" if config . reverse_relative else \"_\" module_name = sep . join ( match . groups ()) prefix = \"\" if ignore_case : module_name = str ( module_name ). lower () else : module_name = str ( module_name ) if sub_imports and config . order_by_type : if module_name . isupper () and len ( module_name ) > 1 : # see issue #376 prefix = \"A\" elif module_name [ 0:1 ] . isupper () : prefix = \"B\" else : prefix = \"C\" if not config . case_sensitive : module_name = module_name . lower () length_sort = config . length_sort or str ( section_name ). lower () in config . length_sort_sections _length_sort_maybe = length_sort and ( str ( len ( module_name )) + \":\" + module_name ) or module_name return f \"{module_name in config.force_to_top and 'A' or 'B'}{prefix}{_length_sort_maybe}\"","title":"module_key"},{"location":"reference/isort/sorting/#naturally","text":"def naturally ( to_sort : Iterable [ str ], key : Union [ Callable [[ str ], Any ], NoneType ] = None ) -> List [ str ] Returns a naturally sorted list View Source def naturally ( to_sort : Iterable [ str ] , key : Optional [ Callable[[str ] , Any ]] = None ) -> List [ str ] : \"\"\"Returns a naturally sorted list\"\"\" if key is None : key_callback = _natural_keys else : def key_callback ( text : str ) -> List [ Any ] : return _natural_keys ( key ( text )) # type : ignore return sorted ( to_sort , key = key_callback )","title":"naturally"},{"location":"reference/isort/sorting/#section_key","text":"def section_key ( line : str , order_by_type : bool , force_to_top : List [ str ], lexicographical : bool = False , length_sort : bool = False ) -> str View Source def section_key ( line : str , order_by_type : bool , force_to_top : List [ str ], lexicographical : bool = False , length_sort : bool = False , ) -> str : section = \"B\" if lexicographical : line = _import_line_intro_re . sub ( \"\" , _import_line_midline_import_re . sub ( \".\" , line )) else : line = re . sub ( \"^from \" , \"\" , line ) line = re . sub ( \"^import \" , \"\" , line ) if line . split ( \" \" )[ 0 ] in force_to_top : section = \"A\" if not order_by_type : line = line . lower () return f \"{section}{len(line) if length_sort else ''}{line}\"","title":"section_key"},{"location":"reference/isort/utils/","text":"Module isort.utils View Source import os import sys from contextlib import contextmanager from typing import Iterator def exists_case_sensitive ( path : str ) -> bool : \"\"\"Returns if the given path exists and also matches the case on Windows. When finding files that can be imported, it is important for the cases to match because while file os.path.exists(\"module.py\") and os.path.exists(\"MODULE.py\") both return True on Windows, Python can only import using the case of the real file. \"\"\" result = os . path . exists ( path ) if ( sys . platform . startswith ( \"win\" ) or sys . platform == \"darwin\" ) and result : # pragma: no cover directory , basename = os . path . split ( path ) result = basename in os . listdir ( directory ) return result @contextmanager def chdir ( path : str ) -> Iterator [ None ]: \"\"\"Context manager for changing dir and restoring previous workdir after exit.\"\"\" curdir = os . getcwd () os . chdir ( path ) try : yield finally : os . chdir ( curdir ) Functions chdir def chdir ( path : str ) -> Iterator [ NoneType ] Context manager for changing dir and restoring previous workdir after exit. View Source @contextmanager def chdir ( path : str ) -> Iterator [ None ] : \"\"\"Context manager for changing dir and restoring previous workdir after exit.\"\"\" curdir = os . getcwd () os . chdir ( path ) try : yield finally : os . chdir ( curdir ) exists_case_sensitive def exists_case_sensitive ( path : str ) -> bool Returns if the given path exists and also matches the case on Windows. When finding files that can be imported, it is important for the cases to match because while file os.path.exists(\"module.py\") and os.path.exists(\"MODULE.py\") both return True on Windows, Python can only import using the case of the real file. View Source def exists_case_sensitive ( path : str ) -> bool : \"\"\"Returns if the given path exists and also matches the case on Windows. When finding files that can be imported, it is important for the cases to match because while file os.path.exists(\"module.py\") and os.path.exists(\"MODULE.py\") both return True on Windows, Python can only import using the case of the real file. \"\"\" result = os . path . exists ( path ) if ( sys . platform . startswith ( \"win\" ) or sys . platform == \"darwin\" ) and result : # pragma: no cover directory , basename = os . path . split ( path ) result = basename in os . listdir ( directory ) return result","title":"Utils"},{"location":"reference/isort/utils/#module-isortutils","text":"View Source import os import sys from contextlib import contextmanager from typing import Iterator def exists_case_sensitive ( path : str ) -> bool : \"\"\"Returns if the given path exists and also matches the case on Windows. When finding files that can be imported, it is important for the cases to match because while file os.path.exists(\"module.py\") and os.path.exists(\"MODULE.py\") both return True on Windows, Python can only import using the case of the real file. \"\"\" result = os . path . exists ( path ) if ( sys . platform . startswith ( \"win\" ) or sys . platform == \"darwin\" ) and result : # pragma: no cover directory , basename = os . path . split ( path ) result = basename in os . listdir ( directory ) return result @contextmanager def chdir ( path : str ) -> Iterator [ None ]: \"\"\"Context manager for changing dir and restoring previous workdir after exit.\"\"\" curdir = os . getcwd () os . chdir ( path ) try : yield finally : os . chdir ( curdir )","title":"Module isort.utils"},{"location":"reference/isort/utils/#functions","text":"","title":"Functions"},{"location":"reference/isort/utils/#chdir","text":"def chdir ( path : str ) -> Iterator [ NoneType ] Context manager for changing dir and restoring previous workdir after exit. View Source @contextmanager def chdir ( path : str ) -> Iterator [ None ] : \"\"\"Context manager for changing dir and restoring previous workdir after exit.\"\"\" curdir = os . getcwd () os . chdir ( path ) try : yield finally : os . chdir ( curdir )","title":"chdir"},{"location":"reference/isort/utils/#exists_case_sensitive","text":"def exists_case_sensitive ( path : str ) -> bool Returns if the given path exists and also matches the case on Windows. When finding files that can be imported, it is important for the cases to match because while file os.path.exists(\"module.py\") and os.path.exists(\"MODULE.py\") both return True on Windows, Python can only import using the case of the real file. View Source def exists_case_sensitive ( path : str ) -> bool : \"\"\"Returns if the given path exists and also matches the case on Windows. When finding files that can be imported, it is important for the cases to match because while file os.path.exists(\"module.py\") and os.path.exists(\"MODULE.py\") both return True on Windows, Python can only import using the case of the real file. \"\"\" result = os . path . exists ( path ) if ( sys . platform . startswith ( \"win\" ) or sys . platform == \"darwin\" ) and result : # pragma: no cover directory , basename = os . path . split ( path ) result = basename in os . listdir ( directory ) return result","title":"exists_case_sensitive"},{"location":"reference/isort/wrap/","text":"Module isort.wrap View Source import copy import re from typing import List , Optional , Sequence from . settings import DEFAULT_CONFIG , Config from . wrap_modes import WrapModes as Modes from . wrap_modes import formatter_from_string def import_statement ( import_start: str , from_imports: List [ str ], comments : Sequence [ str ] = (), line_separator: str = \"\\n\" , config : Config = DEFAULT_CONFIG , multi_line_output: Optional [ Modes ] = None , ) -> str : \"\"\"Returns a multi-line wrapped form of the provided from import statement.\"\"\" formatter = formatter_from_string (( multi_line_output or config . multi_line_output ). name ) dynamic_indent = \" \" * ( len ( import_start ) + 1 ) indent = config . indent line_length = config . wrap_length or config . line_length statement = formatter ( statement = import_start , imports = copy . copy ( from_imports ), white_space = dynamic_indent , indent = indent , line_length = line_length , comments = comments , line_separator = line_separator , comment_prefix = config . comment_prefix , include_trailing_comma = config . include_trailing_comma , remove_comments = config . ignore_comments , ) if config . balanced_wrapping: lines = statement . split ( line_separator ) line_count = len ( lines ) if len ( lines ) > 1 : minimum_length = min ( len ( line ) for line in lines [:- 1 ]) else : minimum_length = 0 new_import_statement = statement while len ( lines [ - 1 ]) < minimum_length and len ( lines ) == line_count and line_length > 10 : statement = new_import_statement line_length -= 1 new_import_statement = formatter ( statement = import_start , imports = copy . copy ( from_imports ), white_space = dynamic_indent , indent = indent , line_length = line_length , comments = comments , line_separator = line_separator , comment_prefix = config . comment_prefix , include_trailing_comma = config . include_trailing_comma , remove_comments = config . ignore_comments , ) lines = new_import_statement . split ( line_separator ) if statement . count ( line_separator ) == 0 : return _ wrap_line ( statement , line_separator , config ) return statement def line ( content : str , line_separator: str , config : Config = DEFAULT_CONFIG ) -> str : \"\"\"Returns a line wrapped to the specified line-length, if possible.\"\"\" wrap_mode = config . multi_line_output if len ( content ) > config . line_length and wrap_mode ! = Modes . NOQA : # type : ignore line_without_comment = content comment = None if \"#\" in content : line_without_comment , comment = content . split ( \"#\" , 1 ) for splitter in ( \"import \" , \".\" , \"as \" ) : exp = r \"\\b\" + re . escape ( splitter ) + r \"\\b\" if re . search ( exp , line_without_comment ) and not line_without_comment . strip (). startswith ( splitter ) : line_parts = re . split ( exp , line_without_comment ) if comment : _ comma_maybe = \",\" if config . include_trailing_comma else \"\" line_parts [ - 1 ] = f \"{line_parts[-1].strip()}{_comma_maybe} #{comment}\" next_line = [] while ( len ( content ) + 2 ) > ( config . wrap_length or config . line_length ) and line_parts: next_line . append ( line_parts . pop ()) content = splitter . join ( line_parts ) if not content : content = next_line . pop () cont_line = _ wrap_line ( config . indent + splitter . join ( next_line ). lstrip (), line_separator , config ) if config . use_parentheses: if splitter == \"as \" : output = f \"{content}{splitter}{cont_line.lstrip()}\" else : _ comma = \",\" if config . include_trailing_comma and not comment else \"\" if wrap_mode in ( Modes . VERTICAL_HANGING_INDENT , # type : ignore Modes . VERTICAL_GRID_GROUPED , # type : ignore ) : _ separator = line_separator else : _ separator = \"\" output = ( f \"{content}{splitter}({line_separator}{cont_line}{_comma}{_separator})\" ) lines = output . split ( line_separator ) if config . comment_prefix in lines [ - 1 ] and lines [ - 1 ]. endswith ( \")\" ) : content , comment = lines [ - 1 ]. split ( config . comment_prefix , 1 ) lines [ - 1 ] = content + \")\" + config . comment_prefix + comment [:- 1 ] return line_separator . join ( lines ) return f \" { content }{ splitter } \\\\ { line_separator }{ cont_line } \" elif len(content) > config.line_length and wrap_mode == Modes.NOQA: # type: ignore if \" # NOQA \" not in content: return f\" { content }{ config . comment_prefix } NOQA \" return content _ wrap_line = line Functions import_statement def import_statement ( import_start : str , from_imports : List [ str ], comments : Sequence [ str ] = (), line_separator : str = ' \\n ' , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ), multi_line_output : Union [ isort . wrap_modes . WrapModes , NoneType ] = None ) -> str Returns a multi-line wrapped form of the provided from import statement. View Source def import_statement ( import_start: str , from_imports: List [ str ], comments : Sequence [ str ] = (), line_separator: str = \"\\n\" , config : Config = DEFAULT_CONFIG , multi_line_output: Optional [ Modes ] = None , ) -> str : \"\"\"Returns a multi-line wrapped form of the provided from import statement.\"\"\" formatter = formatter_from_string (( multi_line_output or config . multi_line_output ). name ) dynamic_indent = \" \" * ( len ( import_start ) + 1 ) indent = config . indent line_length = config . wrap_length or config . line_length statement = formatter ( statement = import_start , imports = copy . copy ( from_imports ), white_space = dynamic_indent , indent = indent , line_length = line_length , comments = comments , line_separator = line_separator , comment_prefix = config . comment_prefix , include_trailing_comma = config . include_trailing_comma , remove_comments = config . ignore_comments , ) if config . balanced_wrapping: lines = statement . split ( line_separator ) line_count = len ( lines ) if len ( lines ) > 1 : minimum_length = min ( len ( line ) for line in lines [:- 1 ]) else : minimum_length = 0 new_import_statement = statement while len ( lines [ - 1 ]) < minimum_length and len ( lines ) == line_count and line_length > 10 : statement = new_import_statement line_length -= 1 new_import_statement = formatter ( statement = import_start , imports = copy . copy ( from_imports ), white_space = dynamic_indent , indent = indent , line_length = line_length , comments = comments , line_separator = line_separator , comment_prefix = config . comment_prefix , include_trailing_comma = config . include_trailing_comma , remove_comments = config . ignore_comments , ) lines = new_import_statement . split ( line_separator ) if statement . count ( line_separator ) == 0 : return _ wrap_line ( statement , line_separator , config ) return statement line def line ( content : str , line_separator : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ) ) -> str Returns a line wrapped to the specified line-length, if possible. View Source def line ( content : str , line_separator: str , config : Config = DEFAULT_CONFIG ) -> str : \"\"\"Returns a line wrapped to the specified line-length, if possible.\"\"\" wrap_mode = config . multi_line_output if len ( content ) > config . line_length and wrap_mode ! = Modes . NOQA : # type : ignore line_without_comment = content comment = None if \"#\" in content : line_without_comment , comment = content . split ( \"#\" , 1 ) for splitter in ( \"import \" , \".\" , \"as \" ) : exp = r \"\\b\" + re . escape ( splitter ) + r \"\\b\" if re . search ( exp , line_without_comment ) and not line_without_comment . strip (). startswith ( splitter ) : line_parts = re . split ( exp , line_without_comment ) if comment : _ comma_maybe = \",\" if config . include_trailing_comma else \"\" line_parts [ - 1 ] = f \"{line_parts[-1].strip()}{_comma_maybe} #{comment}\" next_line = [] while ( len ( content ) + 2 ) > ( config . wrap_length or config . line_length ) and line_parts: next_line . append ( line_parts . pop ()) content = splitter . join ( line_parts ) if not content : content = next_line . pop () cont_line = _ wrap_line ( config . indent + splitter . join ( next_line ). lstrip (), line_separator , config ) if config . use_parentheses: if splitter == \"as \" : output = f \"{content}{splitter}{cont_line.lstrip()}\" else : _ comma = \",\" if config . include_trailing_comma and not comment else \"\" if wrap_mode in ( Modes . VERTICAL_HANGING_INDENT , # type : ignore Modes . VERTICAL_GRID_GROUPED , # type : ignore ) : _ separator = line_separator else : _ separator = \"\" output = ( f \"{content}{splitter}({line_separator}{cont_line}{_comma}{_separator})\" ) lines = output . split ( line_separator ) if config . comment_prefix in lines [ - 1 ] and lines [ - 1 ]. endswith ( \")\" ) : content , comment = lines [ - 1 ]. split ( config . comment_prefix , 1 ) lines [ - 1 ] = content + \")\" + config . comment_prefix + comment [:- 1 ] return line_separator . join ( lines ) return f \" { content }{ splitter } \\\\ { line_separator }{ cont_line } \" elif len(content) > config.line_length and wrap_mode == Modes.NOQA: # type: ignore if \" # NOQA \" not in content: return f\" { content }{ config . comment_prefix } NOQA \" return content","title":"Wrap"},{"location":"reference/isort/wrap/#module-isortwrap","text":"View Source import copy import re from typing import List , Optional , Sequence from . settings import DEFAULT_CONFIG , Config from . wrap_modes import WrapModes as Modes from . wrap_modes import formatter_from_string def import_statement ( import_start: str , from_imports: List [ str ], comments : Sequence [ str ] = (), line_separator: str = \"\\n\" , config : Config = DEFAULT_CONFIG , multi_line_output: Optional [ Modes ] = None , ) -> str : \"\"\"Returns a multi-line wrapped form of the provided from import statement.\"\"\" formatter = formatter_from_string (( multi_line_output or config . multi_line_output ). name ) dynamic_indent = \" \" * ( len ( import_start ) + 1 ) indent = config . indent line_length = config . wrap_length or config . line_length statement = formatter ( statement = import_start , imports = copy . copy ( from_imports ), white_space = dynamic_indent , indent = indent , line_length = line_length , comments = comments , line_separator = line_separator , comment_prefix = config . comment_prefix , include_trailing_comma = config . include_trailing_comma , remove_comments = config . ignore_comments , ) if config . balanced_wrapping: lines = statement . split ( line_separator ) line_count = len ( lines ) if len ( lines ) > 1 : minimum_length = min ( len ( line ) for line in lines [:- 1 ]) else : minimum_length = 0 new_import_statement = statement while len ( lines [ - 1 ]) < minimum_length and len ( lines ) == line_count and line_length > 10 : statement = new_import_statement line_length -= 1 new_import_statement = formatter ( statement = import_start , imports = copy . copy ( from_imports ), white_space = dynamic_indent , indent = indent , line_length = line_length , comments = comments , line_separator = line_separator , comment_prefix = config . comment_prefix , include_trailing_comma = config . include_trailing_comma , remove_comments = config . ignore_comments , ) lines = new_import_statement . split ( line_separator ) if statement . count ( line_separator ) == 0 : return _ wrap_line ( statement , line_separator , config ) return statement def line ( content : str , line_separator: str , config : Config = DEFAULT_CONFIG ) -> str : \"\"\"Returns a line wrapped to the specified line-length, if possible.\"\"\" wrap_mode = config . multi_line_output if len ( content ) > config . line_length and wrap_mode ! = Modes . NOQA : # type : ignore line_without_comment = content comment = None if \"#\" in content : line_without_comment , comment = content . split ( \"#\" , 1 ) for splitter in ( \"import \" , \".\" , \"as \" ) : exp = r \"\\b\" + re . escape ( splitter ) + r \"\\b\" if re . search ( exp , line_without_comment ) and not line_without_comment . strip (). startswith ( splitter ) : line_parts = re . split ( exp , line_without_comment ) if comment : _ comma_maybe = \",\" if config . include_trailing_comma else \"\" line_parts [ - 1 ] = f \"{line_parts[-1].strip()}{_comma_maybe} #{comment}\" next_line = [] while ( len ( content ) + 2 ) > ( config . wrap_length or config . line_length ) and line_parts: next_line . append ( line_parts . pop ()) content = splitter . join ( line_parts ) if not content : content = next_line . pop () cont_line = _ wrap_line ( config . indent + splitter . join ( next_line ). lstrip (), line_separator , config ) if config . use_parentheses: if splitter == \"as \" : output = f \"{content}{splitter}{cont_line.lstrip()}\" else : _ comma = \",\" if config . include_trailing_comma and not comment else \"\" if wrap_mode in ( Modes . VERTICAL_HANGING_INDENT , # type : ignore Modes . VERTICAL_GRID_GROUPED , # type : ignore ) : _ separator = line_separator else : _ separator = \"\" output = ( f \"{content}{splitter}({line_separator}{cont_line}{_comma}{_separator})\" ) lines = output . split ( line_separator ) if config . comment_prefix in lines [ - 1 ] and lines [ - 1 ]. endswith ( \")\" ) : content , comment = lines [ - 1 ]. split ( config . comment_prefix , 1 ) lines [ - 1 ] = content + \")\" + config . comment_prefix + comment [:- 1 ] return line_separator . join ( lines ) return f \" { content }{ splitter } \\\\ { line_separator }{ cont_line } \" elif len(content) > config.line_length and wrap_mode == Modes.NOQA: # type: ignore if \" # NOQA \" not in content: return f\" { content }{ config . comment_prefix } NOQA \" return content _ wrap_line = line","title":"Module isort.wrap"},{"location":"reference/isort/wrap/#functions","text":"","title":"Functions"},{"location":"reference/isort/wrap/#import_statement","text":"def import_statement ( import_start : str , from_imports : List [ str ], comments : Sequence [ str ] = (), line_separator : str = ' \\n ' , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ), multi_line_output : Union [ isort . wrap_modes . WrapModes , NoneType ] = None ) -> str Returns a multi-line wrapped form of the provided from import statement. View Source def import_statement ( import_start: str , from_imports: List [ str ], comments : Sequence [ str ] = (), line_separator: str = \"\\n\" , config : Config = DEFAULT_CONFIG , multi_line_output: Optional [ Modes ] = None , ) -> str : \"\"\"Returns a multi-line wrapped form of the provided from import statement.\"\"\" formatter = formatter_from_string (( multi_line_output or config . multi_line_output ). name ) dynamic_indent = \" \" * ( len ( import_start ) + 1 ) indent = config . indent line_length = config . wrap_length or config . line_length statement = formatter ( statement = import_start , imports = copy . copy ( from_imports ), white_space = dynamic_indent , indent = indent , line_length = line_length , comments = comments , line_separator = line_separator , comment_prefix = config . comment_prefix , include_trailing_comma = config . include_trailing_comma , remove_comments = config . ignore_comments , ) if config . balanced_wrapping: lines = statement . split ( line_separator ) line_count = len ( lines ) if len ( lines ) > 1 : minimum_length = min ( len ( line ) for line in lines [:- 1 ]) else : minimum_length = 0 new_import_statement = statement while len ( lines [ - 1 ]) < minimum_length and len ( lines ) == line_count and line_length > 10 : statement = new_import_statement line_length -= 1 new_import_statement = formatter ( statement = import_start , imports = copy . copy ( from_imports ), white_space = dynamic_indent , indent = indent , line_length = line_length , comments = comments , line_separator = line_separator , comment_prefix = config . comment_prefix , include_trailing_comma = config . include_trailing_comma , remove_comments = config . ignore_comments , ) lines = new_import_statement . split ( line_separator ) if statement . count ( line_separator ) == 0 : return _ wrap_line ( statement , line_separator , config ) return statement","title":"import_statement"},{"location":"reference/isort/wrap/#line","text":"def line ( content : str , line_separator : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), skip_glob = frozenset (), line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset ({ 'google.appengine.api' }), known_first_party = frozenset (), known_standard_library = frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , keep_direct_and_as_imports = True , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ 'build' , '.mypy_cache' , '.eggs' , 'buck-out' , '.pants.d' , '.tox' , 'venv' , '.nox' , '_build' , '.venv' , 'node_modules' , 'dist' , '.hg' , '.git' }), 'skip_glob' : frozenset (), 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset ({ 'google.appengine.api' }), 'known_first_party' : frozenset (), 'known_standard_library' : frozenset ({ 'wave' , 'calendar' , 'mimetypes' , 'binhex' , 'fnmatch' , 'cmath' , 'xmlrpc' , 'traceback' , 'tokenize' , 'abc' , 'asynchat' , 'time' , 'modulefinder' , 'tarfile' , '_dummy_thread' , 'crypt' , 'ntpath' , 'wsgiref' , 'reprlib' , 'threading' , 'sched' , 'distutils' , 'bdb' , 'mmap' , 'stat' , 'spwd' , 'profile' , 'mailcap' , 'unittest' , 'lzma' , 'uu' , 'pickle' , 'gc' , 'array' , 'smtpd' , 'warnings' , 'tty' , 'difflib' , 'smtplib' , 'optparse' , 'concurrent' , 'cmd' , 'ast' , 'asyncore' , 'py_compile' , 'itertools' , 'unicodedata' , 'getopt' , 'zipapp' , 'test' , 'chunk' , 'code' , 'ensurepip' , 'compileall' , 'io' , 'pipes' , 'pyclbr' , 'contextvars' , 'termios' , 'xml' , 'turtledemo' , 'functools' , 'asyncio' , 'nis' , 'collections' , 'cgitb' , 'msvcrt' , 'pickletools' , 'nntplib' , 'errno' , 'turtle' , 'msilib' , 'inspect' , 'fcntl' , 'timeit' , 'textwrap' , 'glob' , 'types' , 'argparse' , 'gettext' , 'selectors' , 'secrets' , 'audioop' , 'uuid' , 'trace' , 'email' , 'copyreg' , 'imghdr' , 'sre_constants' , 'csv' , 'pathlib' , 'copy' , 'zipfile' , 'ctypes' , 'tkinter' , 'ossaudiodev' , 'curses' , 'formatter' , 'logging' , 'dummy_threading' , 'tracemalloc' , 'datetime' , 'numbers' , 'dis' , 'linecache' , 'telnetlib' , 'urllib' , 'bz2' , 'sunau' , 'pty' , 'posix' , 'macpath' , 'syslog' , 'sysconfig' , 'configparser' , 'rlcompleter' , 'socketserver' , 'stringprep' , 'cProfile' , 'fileinput' , 'webbrowser' , 'os' , 'filecmp' , 'cgi' , 'hmac' , 'random' , 'binascii' , 'string' , 'html' , 'lib2to3' , 'posixpath' , 'colorsys' , 'queue' , 'contextlib' , 'codecs' , 'pstats' , 're' , 'quopri' , 'netrc' , 'dataclasses' , 'shelve' , 'tempfile' , 'winsound' , 'site' , 'locale' , 'ssl' , 'venv' , 'fpectl' , 'resource' , 'base64' , 'runpy' , 'dbm' , 'weakref' , 'statistics' , 'codeop' , 'marshal' , 'decimal' , 'keyword' , 'heapq' , 'ipaddress' , 'bisect' , 'readline' , 'sndhdr' , 'symbol' , '_thread' , 'operator' , 'pydoc' , 'zlib' , 'multiprocessing' , 'builtins' , 'poplib' , 'xdrlib' , 'pwd' , 'mailbox' , 'signal' , 'shutil' , 'select' , 'typing' , 'grp' , 'token' , 'pdb' , 'http' , 'symtable' , 'shlex' , 'tabnanny' , 'faulthandler' , 'imaplib' , 'socket' , 'hashlib' , 'sqlite3' , 'zipimport' , 'subprocess' , 'fractions' , 'importlib' , 'math' , 'pkgutil' , 'imp' , 'sys' , 'gzip' , 'atexit' , 'plistlib' , 'json' , 'encodings' , 'platform' , 'struct' , 'pprint' , 'winreg' , 'doctest' , 'parser' , 'enum' , 'getpass' , 'ftplib' , 'aifc' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'keep_direct_and_as_imports' : True , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'src_paths' : frozenset (), 'old_finders' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/timothy/Projects/isort' , profile = '' , src_paths = frozenset ({ PosixPath ( '/home/timothy/Projects/isort' ), PosixPath ( '/home/timothy/Projects/isort/src' )}), old_finders = False ) ) -> str Returns a line wrapped to the specified line-length, if possible. View Source def line ( content : str , line_separator: str , config : Config = DEFAULT_CONFIG ) -> str : \"\"\"Returns a line wrapped to the specified line-length, if possible.\"\"\" wrap_mode = config . multi_line_output if len ( content ) > config . line_length and wrap_mode ! = Modes . NOQA : # type : ignore line_without_comment = content comment = None if \"#\" in content : line_without_comment , comment = content . split ( \"#\" , 1 ) for splitter in ( \"import \" , \".\" , \"as \" ) : exp = r \"\\b\" + re . escape ( splitter ) + r \"\\b\" if re . search ( exp , line_without_comment ) and not line_without_comment . strip (). startswith ( splitter ) : line_parts = re . split ( exp , line_without_comment ) if comment : _ comma_maybe = \",\" if config . include_trailing_comma else \"\" line_parts [ - 1 ] = f \"{line_parts[-1].strip()}{_comma_maybe} #{comment}\" next_line = [] while ( len ( content ) + 2 ) > ( config . wrap_length or config . line_length ) and line_parts: next_line . append ( line_parts . pop ()) content = splitter . join ( line_parts ) if not content : content = next_line . pop () cont_line = _ wrap_line ( config . indent + splitter . join ( next_line ). lstrip (), line_separator , config ) if config . use_parentheses: if splitter == \"as \" : output = f \"{content}{splitter}{cont_line.lstrip()}\" else : _ comma = \",\" if config . include_trailing_comma and not comment else \"\" if wrap_mode in ( Modes . VERTICAL_HANGING_INDENT , # type : ignore Modes . VERTICAL_GRID_GROUPED , # type : ignore ) : _ separator = line_separator else : _ separator = \"\" output = ( f \"{content}{splitter}({line_separator}{cont_line}{_comma}{_separator})\" ) lines = output . split ( line_separator ) if config . comment_prefix in lines [ - 1 ] and lines [ - 1 ]. endswith ( \")\" ) : content , comment = lines [ - 1 ]. split ( config . comment_prefix , 1 ) lines [ - 1 ] = content + \")\" + config . comment_prefix + comment [:- 1 ] return line_separator . join ( lines ) return f \" { content }{ splitter } \\\\ { line_separator }{ cont_line } \" elif len(content) > config.line_length and wrap_mode == Modes.NOQA: # type: ignore if \" # NOQA \" not in content: return f\" { content }{ config . comment_prefix } NOQA \" return content","title":"line"},{"location":"reference/isort/wrap_modes/","text":"Module isort.wrap_modes Defines all wrap modes that can be used when outputting formatted imports View Source \"\"\"Defines all wrap modes that can be used when outputting formatted imports\"\"\" import enum from inspect import signature from typing import Any , Callable , Dict , List import isort . comments _ wrap_modes: Dict [ str , Callable [[ Any ], str ]] = {} def from_string ( value : str ) -> \"WrapModes\" : return getattr ( WrapModes , str ( value ), None ) or WrapModes ( int ( value )) def formatter_from_string ( name : str ) : return _ wrap_modes . get ( name . upper (), grid ) def _ wrap_mode_interface ( statement : str , imports : List [ str ], white_space: str , indent : str , line_length: int , comments : List [ str ], line_separator: str , comment_prefix: str , include_trailing_comma: bool , remove_comments: bool , ) -> str : \"\"\"Defines the common interface used by all wrap mode functions\"\"\" return \"\" def _ wrap_mode ( function ) : \"\"\"Registers an individual wrap mode. Function name and order are significant and used for creating enum. \"\"\" _ wrap_modes [ function . __ name__ . upper ()] = function function . __ signature__ = signature ( _ wrap_mode_interface ) function . __ annotations__ = _ wrap_mode_interface . __ annotations__ return function @ _ wrap_mode def grid ( **interface ) : if not interface [ \"imports\" ] : return \"\" interface [ \"statement\" ] += \"(\" + interface [ \"imports\" ]. pop ( 0 ) while interface [ \"imports\" ] : next_import = interface [ \"imports\" ]. pop ( 0 ) next_statement = isort . comments . add_to_line ( interface [ \"comments\" ], interface [ \"statement\" ] + \", \" + next_import , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) if ( len ( next_statement . split ( interface [ \"line_separator\" ])[ - 1 ]) + 1 > interface [ \"line_length\" ] ) : lines = [ f \"{interface['white_space']}{next_import.split(' ')[0]}\" ] for part in next_import . split ( \" \" )[ 1 : ] : new_line = f \"{lines[-1]} {part}\" if len ( new_line ) + 1 > interface [ \"line_length\" ] : lines . append ( f \"{interface['white_space']}{part}\" ) else : lines [ - 1 ] = new_line next_import = interface [ \"line_separator\" ]. join ( lines ) interface [ \"statement\" ] = ( isort . comments . add_to_line ( interface [ \"comments\" ], f \"{interface['statement']},\" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + f \"{interface['line_separator']}{next_import}\" ) interface [ \"comments\" ] = [] else : interface [ \"statement\" ] += \", \" + next_import return interface [ \"statement\" ] + ( \",\" if interface [ \"include_trailing_comma\" ] else \"\" ) + \")\" @ _ wrap_mode def vertical ( **interface ) : if not interface [ \"imports\" ] : return \"\" first_import = ( isort . comments . add_to_line ( interface [ \"comments\" ], interface [ \"imports\" ]. pop ( 0 ) + \",\" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + interface [ \"line_separator\" ] + interface [ \"white_space\" ] ) _ imports = ( \",\" + interface [ \"line_separator\" ] + interface [ \"white_space\" ]). join ( interface [ \"imports\" ] ) _ comma_maybe = \",\" if interface [ \"include_trailing_comma\" ] else \"\" return f \"{interface['statement']}({first_import}{_imports}{_comma_maybe})\" @ _ wrap_mode def hanging_indent ( **interface ) : if not interface [ \"imports\" ] : return \"\" next_import = interface [ \"imports\" ]. pop ( 0 ) next_statement = interface [ \"statement\" ] + next_import # Check for first import if len ( next_statement ) + 3 > interface [ \"line_length\" ] : next_statement = ( isort . comments . add_to_line ( interface [ \"comments\" ], f \" { interface [ 'statement' ]} \\\\ \", removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) + f\" { interface [ 'line_separator' ]}{ interface [ 'indent' ]}{ next_import } \" ) interface[\" comments \"] = [] interface[\" statement \"] = next_statement while interface[\" imports \"]: next_import = interface[\" imports \"].pop(0) next_statement = isort.comments.add_to_line( interface[\" comments \"], interface[\" statement \"] + \" , \" + next_import, removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) if ( len(next_statement.split(interface[\" line_separator \"])[-1]) + 3 > interface[\" line_length \"] ): next_statement = ( isort.comments.add_to_line( interface[\" comments \"], f\" { interface [ 'statement' ]}, \\\\ \", removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) + f\" { interface [ 'line_separator' ]}{ interface [ 'indent' ]}{ next_import } \" ) interface[\" comments \"] = [] interface[\" statement \"] = next_statement return interface[\" statement \"] @_wrap_mode def vertical_hanging_indent(**interface): _line_with_comments = isort.comments.add_to_line( interface[\" comments \"], \"\", removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) _imports = (\" , \" + interface[\" line_separator \"] + interface[\" indent \"]).join(interface[\" imports \"]) _comma_maybe = \" , \" if interface[\" include_trailing_comma \"] else \"\" return ( f\" { interface [ 'statement' ]}({ _ line_with_comments }{ interface [ 'line_separator' ]} \" f\" { interface [ 'indent' ]}{ _ imports }{ _ comma_maybe }{ interface [ 'line_separator' ]}) \" ) def vertical_grid_common(need_trailing_char: bool, **interface): if not interface[\" imports \"]: return \"\" interface[\" statement \"] += ( isort.comments.add_to_line( interface[\" comments \"], \" ( \", removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) + interface[\" line_separator \"] + interface[\" indent \"] + interface[\" imports \"].pop(0) ) while interface[\" imports \"]: next_import = interface[\" imports \"].pop(0) next_statement = f\" { interface [ 'statement' ]}, { next_import } \" current_line_length = len(next_statement.split(interface[\" line_separator \"])[-1]) if interface[\" imports \"] or need_trailing_char: # If we have more interface[\" imports \"] we need to account for a comma after this import # We might also need to account for a closing ) we're going to add. current_line_length += 1 if current_line_length > interface[\" line_length \"]: next_statement = ( f\" { interface [ 'statement' ]},{ interface [ 'line_separator' ]} \" f\" { interface [ 'indent' ]}{ next_import } \" ) interface[\" statement \"] = next_statement if interface[\" include_trailing_comma \"]: interface[\" statement \"] += \" , \" return interface[\" statement \"] @_wrap_mode def vertical_grid(**interface) -> str: return ( vertical_grid_common( statement=interface[\" statement \"], imports=interface[\" imports \"], white_space=interface[\" white_space \"], indent=interface[\" indent \"], line_length=interface[\" line_length \"], comments=interface[\" comments \"], line_separator=interface[\" line_separator \"], comment_prefix=interface[\" comment_prefix \"], include_trailing_comma=interface[\" include_trailing_comma \"], remove_comments=interface[\" remove_comments \"], need_trailing_char=True, ) + \" ) \" ) @_wrap_mode def vertical_grid_grouped(**interface): return ( vertical_grid_common( statement=interface[\" statement \"], imports=interface[\" imports \"], white_space=interface[\" white_space \"], indent=interface[\" indent \"], line_length=interface[\" line_length \"], comments=interface[\" comments \"], line_separator=interface[\" line_separator \"], comment_prefix=interface[\" comment_prefix \"], include_trailing_comma=interface[\" include_trailing_comma \"], remove_comments=interface[\" remove_comments \"], need_trailing_char=True, ) + interface[\" line_separator \"] + \" ) \" ) @_wrap_mode def vertical_grid_grouped_no_comma(**interface): return ( vertical_grid_common( statement=interface[\" statement \"], imports=interface[\" imports \"], white_space=interface[\" white_space \"], indent=interface[\" indent \"], line_length=interface[\" line_length \"], comments=interface[\" comments \"], line_separator=interface[\" line_separator \"], comment_prefix=interface[\" comment_prefix \"], include_trailing_comma=interface[\" include_trailing_comma \"], remove_comments=interface[\" remove_comments \"], need_trailing_char=False, ) + interface[\" line_separator \"] + \" ) \" ) @_wrap_mode def noqa(**interface): _imports = \" , \".join(interface[\" imports \"]) retval = f\" { interface [ 'statement' ]}{ _ imports } \" comment_str = \" \".join(interface[\" comments \"]) if interface[\" comments \"]: if ( len(retval) + len(interface[\" comment_prefix \"]) + 1 + len(comment_str) <= interface[\" line_length \"] ): return f\" { retval }{ interface [ 'comment_prefix' ]} { comment_str } \" elif \" NOQA \" in interface[\" comments \"]: return f\" { retval }{ interface [ 'comment_prefix' ]} { comment_str } \" else: return f\" { retval }{ interface [ 'comment_prefix' ]} NOQA { comment_str } \" else: if len(retval) <= interface[\" line_length \"]: return retval else: return f\" { retval }{ interface [ 'comment_prefix' ]} NOQA \" @_wrap_mode def vertical_hanging_indent_bracket(**interface): if not interface[\" imports \"]: return \"\" statement = vertical_hanging_indent(**interface) return f'{statement[:-1]}{interface[\" indent \"]})' @_wrap_mode def vertical_prefix_from_module_import(**interface): if not interface[\" imports \"]: return \"\" prefix_statement = interface[\" statement \"] interface[\" statement \"] += interface[\" imports \"].pop(0) while interface[\" imports \"]: next_import = interface[\" imports \"].pop(0) next_statement = isort.comments.add_to_line( interface[\" comments \"], interface[\" statement \"] + \" , \" + next_import, removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) if ( len(next_statement.split(interface[\" line_separator \"])[-1]) + 1 > interface[\" line_length \"] ): next_statement = ( isort.comments.add_to_line( interface[\" comments \"], f\" { interface [ 'statement' ]} \", removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) + f\" { interface [ 'line_separator' ]}{ prefix_statement }{ next_import } \" ) interface[\" comments \"] = [] interface[\" statement \"] = next_statement return interface[\" statement \"] WrapModes = enum.Enum( # type: ignore \" WrapModes \" , { wrap_mode: index for index , wrap_mode in enumerate ( _ wrap_modes . keys ())} ) Functions formatter_from_string def formatter_from_string ( name : str ) View Source def formatter_from_string ( name : str ): return _wrap_modes . get ( name . upper (), grid ) from_string def from_string ( value : str ) -> 'WrapModes' View Source def from_string ( value : str ) -> \"WrapModes\" : return getattr ( WrapModes , str ( value ), None ) or WrapModes ( int ( value )) grid def grid ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def grid ( ** interface ): if not interface [ \"imports\" ]: return \"\" interface [ \"statement\" ] += \"(\" + interface [ \"imports\" ] . pop ( 0 ) while interface [ \"imports\" ]: next_import = interface [ \"imports\" ] . pop ( 0 ) next_statement = isort . comments . add_to_line ( interface [ \"comments\" ], interface [ \"statement\" ] + \", \" + next_import , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) if ( len ( next_statement . split ( interface [ \"line_separator\" ])[ - 1 ]) + 1 > interface [ \"line_length\" ] ): lines = [ f \"{interface['white_space']}{next_import.split(' ')[0]}\" ] for part in next_import . split ( \" \" )[ 1 :]: new_line = f \"{lines[-1]} {part}\" if len ( new_line ) + 1 > interface [ \"line_length\" ]: lines . append ( f \"{interface['white_space']}{part}\" ) else : lines [ - 1 ] = new_line next_import = interface [ \"line_separator\" ] . join ( lines ) interface [ \"statement\" ] = ( isort . comments . add_to_line ( interface [ \"comments\" ], f \"{interface['statement']},\" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + f \"{interface['line_separator']}{next_import}\" ) interface [ \"comments\" ] = [] else : interface [ \"statement\" ] += \", \" + next_import return interface [ \"statement\" ] + ( \",\" if interface [ \"include_trailing_comma\" ] else \"\" ) + \")\" hanging_indent def hanging_indent ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def hanging_indent ( ** interface ): if not interface [ \"imports\" ]: return \"\" next_import = interface [ \"imports\" ] . pop ( 0 ) next_statement = interface [ \"statement\" ] + next_import # Check for first import if len ( next_statement ) + 3 > interface [ \"line_length\" ]: next_statement = ( isort . comments . add_to_line ( interface [ \"comments\" ], f \"{interface['statement']} \\\\ \" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + f \"{interface['line_separator']}{interface['indent']}{next_import}\" ) interface [ \"comments\" ] = [] interface [ \"statement\" ] = next_statement while interface [ \"imports\" ]: next_import = interface [ \"imports\" ] . pop ( 0 ) next_statement = isort . comments . add_to_line ( interface [ \"comments\" ], interface [ \"statement\" ] + \", \" + next_import , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) if ( len ( next_statement . split ( interface [ \"line_separator\" ])[ - 1 ]) + 3 > interface [ \"line_length\" ] ): next_statement = ( isort . comments . add_to_line ( interface [ \"comments\" ], f \"{interface['statement']}, \\\\ \" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + f \"{interface['line_separator']}{interface['indent']}{next_import}\" ) interface [ \"comments\" ] = [] interface [ \"statement\" ] = next_statement return interface [ \"statement\" ] noqa def noqa ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def noqa ( ** interface ) : _imports = \", \" . join ( interface [ \"imports\" ] ) retval = f \"{interface['statement']}{_imports}\" comment_str = \" \" . join ( interface [ \"comments\" ] ) if interface [ \"comments\" ] : if ( len ( retval ) + len ( interface [ \"comment_prefix\" ] ) + 1 + len ( comment_str ) <= interface [ \"line_length\" ] ) : return f \"{retval}{interface['comment_prefix']} {comment_str}\" elif \"NOQA\" in interface [ \"comments\" ] : return f \"{retval}{interface['comment_prefix']} {comment_str}\" else : return f \"{retval}{interface['comment_prefix']} NOQA {comment_str}\" else : if len ( retval ) <= interface [ \"line_length\" ] : return retval else : return f \"{retval}{interface['comment_prefix']} NOQA\" vertical def vertical ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical ( ** interface ): if not interface [ \"imports\" ]: return \"\" first_import = ( isort . comments . add_to_line ( interface [ \"comments\" ], interface [ \"imports\" ] . pop ( 0 ) + \",\" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + interface [ \"line_separator\" ] + interface [ \"white_space\" ] ) _imports = ( \",\" + interface [ \"line_separator\" ] + interface [ \"white_space\" ]) . join ( interface [ \"imports\" ] ) _comma_maybe = \",\" if interface [ \"include_trailing_comma\" ] else \"\" return f \"{interface['statement']}({first_import}{_imports}{_comma_maybe})\" vertical_grid def vertical_grid ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical_grid ( ** interface ) -> str : return ( vertical_grid_common ( statement = interface [ \"statement\" ] , imports = interface [ \"imports\" ] , white_space = interface [ \"white_space\" ] , indent = interface [ \"indent\" ] , line_length = interface [ \"line_length\" ] , comments = interface [ \"comments\" ] , line_separator = interface [ \"line_separator\" ] , comment_prefix = interface [ \"comment_prefix\" ] , include_trailing_comma = interface [ \"include_trailing_comma\" ] , remove_comments = interface [ \"remove_comments\" ] , need_trailing_char = True , ) + \")\" ) vertical_grid_common def vertical_grid_common ( need_trailing_char : bool , ** interface ) View Source def vertical_grid_common ( need_trailing_char : bool , ** interface ): if not interface [ \"imports\" ]: return \"\" interface [ \"statement\" ] += ( isort . comments . add_to_line ( interface [ \"comments\" ], \"(\" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + interface [ \"line_separator\" ] + interface [ \"indent\" ] + interface [ \"imports\" ] . pop ( 0 ) ) while interface [ \"imports\" ]: next_import = interface [ \"imports\" ] . pop ( 0 ) next_statement = f \"{interface['statement']}, {next_import}\" current_line_length = len ( next_statement . split ( interface [ \"line_separator\" ])[ - 1 ]) if interface [ \"imports\" ] or need_trailing_char : # If we have more interface[\"imports\"] we need to account for a comma after this import # We might also need to account for a closing ) we're going to add. current_line_length += 1 if current_line_length > interface [ \"line_length\" ]: next_statement = ( f \"{interface['statement']},{interface['line_separator']}\" f \"{interface['indent']}{next_import}\" ) interface [ \"statement\" ] = next_statement if interface [ \"include_trailing_comma\" ]: interface [ \"statement\" ] += \",\" return interface [ \"statement\" ] vertical_grid_grouped def vertical_grid_grouped ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical_grid_grouped ( ** interface ) : return ( vertical_grid_common ( statement = interface [ \"statement\" ] , imports = interface [ \"imports\" ] , white_space = interface [ \"white_space\" ] , indent = interface [ \"indent\" ] , line_length = interface [ \"line_length\" ] , comments = interface [ \"comments\" ] , line_separator = interface [ \"line_separator\" ] , comment_prefix = interface [ \"comment_prefix\" ] , include_trailing_comma = interface [ \"include_trailing_comma\" ] , remove_comments = interface [ \"remove_comments\" ] , need_trailing_char = True , ) + interface [ \"line_separator\" ] + \")\" ) vertical_grid_grouped_no_comma def vertical_grid_grouped_no_comma ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical_grid_grouped_no_comma ( ** interface ) : return ( vertical_grid_common ( statement = interface [ \"statement\" ] , imports = interface [ \"imports\" ] , white_space = interface [ \"white_space\" ] , indent = interface [ \"indent\" ] , line_length = interface [ \"line_length\" ] , comments = interface [ \"comments\" ] , line_separator = interface [ \"line_separator\" ] , comment_prefix = interface [ \"comment_prefix\" ] , include_trailing_comma = interface [ \"include_trailing_comma\" ] , remove_comments = interface [ \"remove_comments\" ] , need_trailing_char = False , ) + interface [ \"line_separator\" ] + \")\" ) vertical_hanging_indent def vertical_hanging_indent ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical_hanging_indent ( ** interface ) : _line_with_comments = isort . comments . add_to_line ( interface [ \"comments\" ] , \"\" , removed = interface [ \"remove_comments\" ] , comment_prefix = interface [ \"comment_prefix\" ] , ) _imports = ( \",\" + interface [ \"line_separator\" ] + interface [ \"indent\" ] ). join ( interface [ \"imports\" ] ) _comma_maybe = \",\" if interface [ \"include_trailing_comma\" ] else \"\" return ( f \"{interface['statement']}({_line_with_comments}{interface['line_separator']}\" f \"{interface['indent']}{_imports}{_comma_maybe}{interface['line_separator']})\" ) vertical_hanging_indent_bracket def vertical_hanging_indent_bracket ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @ _ wrap_mode def vertical_hanging_indent_bracket ( **interface ) : if not interface [ \"imports\" ] : return \"\" statement = vertical_hanging_indent ( **interface ) return f'{statement[:-1]}{interface[\"indent\"]})' vertical_prefix_from_module_import def vertical_prefix_from_module_import ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical_prefix_from_module_import ( ** interface ): if not interface [ \"imports\" ]: return \"\" prefix_statement = interface [ \"statement\" ] interface [ \"statement\" ] += interface [ \"imports\" ] . pop ( 0 ) while interface [ \"imports\" ]: next_import = interface [ \"imports\" ] . pop ( 0 ) next_statement = isort . comments . add_to_line ( interface [ \"comments\" ], interface [ \"statement\" ] + \", \" + next_import , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) if ( len ( next_statement . split ( interface [ \"line_separator\" ])[ - 1 ]) + 1 > interface [ \"line_length\" ] ): next_statement = ( isort . comments . add_to_line ( interface [ \"comments\" ], f \"{interface['statement']}\" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + f \"{interface['line_separator']}{prefix_statement}{next_import}\" ) interface [ \"comments\" ] = [] interface [ \"statement\" ] = next_statement return interface [ \"statement\" ] Classes WrapModes class WrapModes ( / , * args , ** kwargs ) An enumeration. Ancestors (in MRO) enum.Enum Class variables GRID HANGING_INDENT NOQA VERTICAL VERTICAL_GRID VERTICAL_GRID_GROUPED VERTICAL_GRID_GROUPED_NO_COMMA VERTICAL_HANGING_INDENT VERTICAL_HANGING_INDENT_BRACKET VERTICAL_PREFIX_FROM_MODULE_IMPORT name value","title":"Wrap Modes"},{"location":"reference/isort/wrap_modes/#module-isortwrap_modes","text":"Defines all wrap modes that can be used when outputting formatted imports View Source \"\"\"Defines all wrap modes that can be used when outputting formatted imports\"\"\" import enum from inspect import signature from typing import Any , Callable , Dict , List import isort . comments _ wrap_modes: Dict [ str , Callable [[ Any ], str ]] = {} def from_string ( value : str ) -> \"WrapModes\" : return getattr ( WrapModes , str ( value ), None ) or WrapModes ( int ( value )) def formatter_from_string ( name : str ) : return _ wrap_modes . get ( name . upper (), grid ) def _ wrap_mode_interface ( statement : str , imports : List [ str ], white_space: str , indent : str , line_length: int , comments : List [ str ], line_separator: str , comment_prefix: str , include_trailing_comma: bool , remove_comments: bool , ) -> str : \"\"\"Defines the common interface used by all wrap mode functions\"\"\" return \"\" def _ wrap_mode ( function ) : \"\"\"Registers an individual wrap mode. Function name and order are significant and used for creating enum. \"\"\" _ wrap_modes [ function . __ name__ . upper ()] = function function . __ signature__ = signature ( _ wrap_mode_interface ) function . __ annotations__ = _ wrap_mode_interface . __ annotations__ return function @ _ wrap_mode def grid ( **interface ) : if not interface [ \"imports\" ] : return \"\" interface [ \"statement\" ] += \"(\" + interface [ \"imports\" ]. pop ( 0 ) while interface [ \"imports\" ] : next_import = interface [ \"imports\" ]. pop ( 0 ) next_statement = isort . comments . add_to_line ( interface [ \"comments\" ], interface [ \"statement\" ] + \", \" + next_import , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) if ( len ( next_statement . split ( interface [ \"line_separator\" ])[ - 1 ]) + 1 > interface [ \"line_length\" ] ) : lines = [ f \"{interface['white_space']}{next_import.split(' ')[0]}\" ] for part in next_import . split ( \" \" )[ 1 : ] : new_line = f \"{lines[-1]} {part}\" if len ( new_line ) + 1 > interface [ \"line_length\" ] : lines . append ( f \"{interface['white_space']}{part}\" ) else : lines [ - 1 ] = new_line next_import = interface [ \"line_separator\" ]. join ( lines ) interface [ \"statement\" ] = ( isort . comments . add_to_line ( interface [ \"comments\" ], f \"{interface['statement']},\" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + f \"{interface['line_separator']}{next_import}\" ) interface [ \"comments\" ] = [] else : interface [ \"statement\" ] += \", \" + next_import return interface [ \"statement\" ] + ( \",\" if interface [ \"include_trailing_comma\" ] else \"\" ) + \")\" @ _ wrap_mode def vertical ( **interface ) : if not interface [ \"imports\" ] : return \"\" first_import = ( isort . comments . add_to_line ( interface [ \"comments\" ], interface [ \"imports\" ]. pop ( 0 ) + \",\" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + interface [ \"line_separator\" ] + interface [ \"white_space\" ] ) _ imports = ( \",\" + interface [ \"line_separator\" ] + interface [ \"white_space\" ]). join ( interface [ \"imports\" ] ) _ comma_maybe = \",\" if interface [ \"include_trailing_comma\" ] else \"\" return f \"{interface['statement']}({first_import}{_imports}{_comma_maybe})\" @ _ wrap_mode def hanging_indent ( **interface ) : if not interface [ \"imports\" ] : return \"\" next_import = interface [ \"imports\" ]. pop ( 0 ) next_statement = interface [ \"statement\" ] + next_import # Check for first import if len ( next_statement ) + 3 > interface [ \"line_length\" ] : next_statement = ( isort . comments . add_to_line ( interface [ \"comments\" ], f \" { interface [ 'statement' ]} \\\\ \", removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) + f\" { interface [ 'line_separator' ]}{ interface [ 'indent' ]}{ next_import } \" ) interface[\" comments \"] = [] interface[\" statement \"] = next_statement while interface[\" imports \"]: next_import = interface[\" imports \"].pop(0) next_statement = isort.comments.add_to_line( interface[\" comments \"], interface[\" statement \"] + \" , \" + next_import, removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) if ( len(next_statement.split(interface[\" line_separator \"])[-1]) + 3 > interface[\" line_length \"] ): next_statement = ( isort.comments.add_to_line( interface[\" comments \"], f\" { interface [ 'statement' ]}, \\\\ \", removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) + f\" { interface [ 'line_separator' ]}{ interface [ 'indent' ]}{ next_import } \" ) interface[\" comments \"] = [] interface[\" statement \"] = next_statement return interface[\" statement \"] @_wrap_mode def vertical_hanging_indent(**interface): _line_with_comments = isort.comments.add_to_line( interface[\" comments \"], \"\", removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) _imports = (\" , \" + interface[\" line_separator \"] + interface[\" indent \"]).join(interface[\" imports \"]) _comma_maybe = \" , \" if interface[\" include_trailing_comma \"] else \"\" return ( f\" { interface [ 'statement' ]}({ _ line_with_comments }{ interface [ 'line_separator' ]} \" f\" { interface [ 'indent' ]}{ _ imports }{ _ comma_maybe }{ interface [ 'line_separator' ]}) \" ) def vertical_grid_common(need_trailing_char: bool, **interface): if not interface[\" imports \"]: return \"\" interface[\" statement \"] += ( isort.comments.add_to_line( interface[\" comments \"], \" ( \", removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) + interface[\" line_separator \"] + interface[\" indent \"] + interface[\" imports \"].pop(0) ) while interface[\" imports \"]: next_import = interface[\" imports \"].pop(0) next_statement = f\" { interface [ 'statement' ]}, { next_import } \" current_line_length = len(next_statement.split(interface[\" line_separator \"])[-1]) if interface[\" imports \"] or need_trailing_char: # If we have more interface[\" imports \"] we need to account for a comma after this import # We might also need to account for a closing ) we're going to add. current_line_length += 1 if current_line_length > interface[\" line_length \"]: next_statement = ( f\" { interface [ 'statement' ]},{ interface [ 'line_separator' ]} \" f\" { interface [ 'indent' ]}{ next_import } \" ) interface[\" statement \"] = next_statement if interface[\" include_trailing_comma \"]: interface[\" statement \"] += \" , \" return interface[\" statement \"] @_wrap_mode def vertical_grid(**interface) -> str: return ( vertical_grid_common( statement=interface[\" statement \"], imports=interface[\" imports \"], white_space=interface[\" white_space \"], indent=interface[\" indent \"], line_length=interface[\" line_length \"], comments=interface[\" comments \"], line_separator=interface[\" line_separator \"], comment_prefix=interface[\" comment_prefix \"], include_trailing_comma=interface[\" include_trailing_comma \"], remove_comments=interface[\" remove_comments \"], need_trailing_char=True, ) + \" ) \" ) @_wrap_mode def vertical_grid_grouped(**interface): return ( vertical_grid_common( statement=interface[\" statement \"], imports=interface[\" imports \"], white_space=interface[\" white_space \"], indent=interface[\" indent \"], line_length=interface[\" line_length \"], comments=interface[\" comments \"], line_separator=interface[\" line_separator \"], comment_prefix=interface[\" comment_prefix \"], include_trailing_comma=interface[\" include_trailing_comma \"], remove_comments=interface[\" remove_comments \"], need_trailing_char=True, ) + interface[\" line_separator \"] + \" ) \" ) @_wrap_mode def vertical_grid_grouped_no_comma(**interface): return ( vertical_grid_common( statement=interface[\" statement \"], imports=interface[\" imports \"], white_space=interface[\" white_space \"], indent=interface[\" indent \"], line_length=interface[\" line_length \"], comments=interface[\" comments \"], line_separator=interface[\" line_separator \"], comment_prefix=interface[\" comment_prefix \"], include_trailing_comma=interface[\" include_trailing_comma \"], remove_comments=interface[\" remove_comments \"], need_trailing_char=False, ) + interface[\" line_separator \"] + \" ) \" ) @_wrap_mode def noqa(**interface): _imports = \" , \".join(interface[\" imports \"]) retval = f\" { interface [ 'statement' ]}{ _ imports } \" comment_str = \" \".join(interface[\" comments \"]) if interface[\" comments \"]: if ( len(retval) + len(interface[\" comment_prefix \"]) + 1 + len(comment_str) <= interface[\" line_length \"] ): return f\" { retval }{ interface [ 'comment_prefix' ]} { comment_str } \" elif \" NOQA \" in interface[\" comments \"]: return f\" { retval }{ interface [ 'comment_prefix' ]} { comment_str } \" else: return f\" { retval }{ interface [ 'comment_prefix' ]} NOQA { comment_str } \" else: if len(retval) <= interface[\" line_length \"]: return retval else: return f\" { retval }{ interface [ 'comment_prefix' ]} NOQA \" @_wrap_mode def vertical_hanging_indent_bracket(**interface): if not interface[\" imports \"]: return \"\" statement = vertical_hanging_indent(**interface) return f'{statement[:-1]}{interface[\" indent \"]})' @_wrap_mode def vertical_prefix_from_module_import(**interface): if not interface[\" imports \"]: return \"\" prefix_statement = interface[\" statement \"] interface[\" statement \"] += interface[\" imports \"].pop(0) while interface[\" imports \"]: next_import = interface[\" imports \"].pop(0) next_statement = isort.comments.add_to_line( interface[\" comments \"], interface[\" statement \"] + \" , \" + next_import, removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) if ( len(next_statement.split(interface[\" line_separator \"])[-1]) + 1 > interface[\" line_length \"] ): next_statement = ( isort.comments.add_to_line( interface[\" comments \"], f\" { interface [ 'statement' ]} \", removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) + f\" { interface [ 'line_separator' ]}{ prefix_statement }{ next_import } \" ) interface[\" comments \"] = [] interface[\" statement \"] = next_statement return interface[\" statement \"] WrapModes = enum.Enum( # type: ignore \" WrapModes \" , { wrap_mode: index for index , wrap_mode in enumerate ( _ wrap_modes . keys ())} )","title":"Module isort.wrap_modes"},{"location":"reference/isort/wrap_modes/#functions","text":"","title":"Functions"},{"location":"reference/isort/wrap_modes/#formatter_from_string","text":"def formatter_from_string ( name : str ) View Source def formatter_from_string ( name : str ): return _wrap_modes . get ( name . upper (), grid )","title":"formatter_from_string"},{"location":"reference/isort/wrap_modes/#from_string","text":"def from_string ( value : str ) -> 'WrapModes' View Source def from_string ( value : str ) -> \"WrapModes\" : return getattr ( WrapModes , str ( value ), None ) or WrapModes ( int ( value ))","title":"from_string"},{"location":"reference/isort/wrap_modes/#grid","text":"def grid ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def grid ( ** interface ): if not interface [ \"imports\" ]: return \"\" interface [ \"statement\" ] += \"(\" + interface [ \"imports\" ] . pop ( 0 ) while interface [ \"imports\" ]: next_import = interface [ \"imports\" ] . pop ( 0 ) next_statement = isort . comments . add_to_line ( interface [ \"comments\" ], interface [ \"statement\" ] + \", \" + next_import , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) if ( len ( next_statement . split ( interface [ \"line_separator\" ])[ - 1 ]) + 1 > interface [ \"line_length\" ] ): lines = [ f \"{interface['white_space']}{next_import.split(' ')[0]}\" ] for part in next_import . split ( \" \" )[ 1 :]: new_line = f \"{lines[-1]} {part}\" if len ( new_line ) + 1 > interface [ \"line_length\" ]: lines . append ( f \"{interface['white_space']}{part}\" ) else : lines [ - 1 ] = new_line next_import = interface [ \"line_separator\" ] . join ( lines ) interface [ \"statement\" ] = ( isort . comments . add_to_line ( interface [ \"comments\" ], f \"{interface['statement']},\" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + f \"{interface['line_separator']}{next_import}\" ) interface [ \"comments\" ] = [] else : interface [ \"statement\" ] += \", \" + next_import return interface [ \"statement\" ] + ( \",\" if interface [ \"include_trailing_comma\" ] else \"\" ) + \")\"","title":"grid"},{"location":"reference/isort/wrap_modes/#hanging_indent","text":"def hanging_indent ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def hanging_indent ( ** interface ): if not interface [ \"imports\" ]: return \"\" next_import = interface [ \"imports\" ] . pop ( 0 ) next_statement = interface [ \"statement\" ] + next_import # Check for first import if len ( next_statement ) + 3 > interface [ \"line_length\" ]: next_statement = ( isort . comments . add_to_line ( interface [ \"comments\" ], f \"{interface['statement']} \\\\ \" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + f \"{interface['line_separator']}{interface['indent']}{next_import}\" ) interface [ \"comments\" ] = [] interface [ \"statement\" ] = next_statement while interface [ \"imports\" ]: next_import = interface [ \"imports\" ] . pop ( 0 ) next_statement = isort . comments . add_to_line ( interface [ \"comments\" ], interface [ \"statement\" ] + \", \" + next_import , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) if ( len ( next_statement . split ( interface [ \"line_separator\" ])[ - 1 ]) + 3 > interface [ \"line_length\" ] ): next_statement = ( isort . comments . add_to_line ( interface [ \"comments\" ], f \"{interface['statement']}, \\\\ \" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + f \"{interface['line_separator']}{interface['indent']}{next_import}\" ) interface [ \"comments\" ] = [] interface [ \"statement\" ] = next_statement return interface [ \"statement\" ]","title":"hanging_indent"},{"location":"reference/isort/wrap_modes/#noqa","text":"def noqa ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def noqa ( ** interface ) : _imports = \", \" . join ( interface [ \"imports\" ] ) retval = f \"{interface['statement']}{_imports}\" comment_str = \" \" . join ( interface [ \"comments\" ] ) if interface [ \"comments\" ] : if ( len ( retval ) + len ( interface [ \"comment_prefix\" ] ) + 1 + len ( comment_str ) <= interface [ \"line_length\" ] ) : return f \"{retval}{interface['comment_prefix']} {comment_str}\" elif \"NOQA\" in interface [ \"comments\" ] : return f \"{retval}{interface['comment_prefix']} {comment_str}\" else : return f \"{retval}{interface['comment_prefix']} NOQA {comment_str}\" else : if len ( retval ) <= interface [ \"line_length\" ] : return retval else : return f \"{retval}{interface['comment_prefix']} NOQA\"","title":"noqa"},{"location":"reference/isort/wrap_modes/#vertical","text":"def vertical ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical ( ** interface ): if not interface [ \"imports\" ]: return \"\" first_import = ( isort . comments . add_to_line ( interface [ \"comments\" ], interface [ \"imports\" ] . pop ( 0 ) + \",\" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + interface [ \"line_separator\" ] + interface [ \"white_space\" ] ) _imports = ( \",\" + interface [ \"line_separator\" ] + interface [ \"white_space\" ]) . join ( interface [ \"imports\" ] ) _comma_maybe = \",\" if interface [ \"include_trailing_comma\" ] else \"\" return f \"{interface['statement']}({first_import}{_imports}{_comma_maybe})\"","title":"vertical"},{"location":"reference/isort/wrap_modes/#vertical_grid","text":"def vertical_grid ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical_grid ( ** interface ) -> str : return ( vertical_grid_common ( statement = interface [ \"statement\" ] , imports = interface [ \"imports\" ] , white_space = interface [ \"white_space\" ] , indent = interface [ \"indent\" ] , line_length = interface [ \"line_length\" ] , comments = interface [ \"comments\" ] , line_separator = interface [ \"line_separator\" ] , comment_prefix = interface [ \"comment_prefix\" ] , include_trailing_comma = interface [ \"include_trailing_comma\" ] , remove_comments = interface [ \"remove_comments\" ] , need_trailing_char = True , ) + \")\" )","title":"vertical_grid"},{"location":"reference/isort/wrap_modes/#vertical_grid_common","text":"def vertical_grid_common ( need_trailing_char : bool , ** interface ) View Source def vertical_grid_common ( need_trailing_char : bool , ** interface ): if not interface [ \"imports\" ]: return \"\" interface [ \"statement\" ] += ( isort . comments . add_to_line ( interface [ \"comments\" ], \"(\" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + interface [ \"line_separator\" ] + interface [ \"indent\" ] + interface [ \"imports\" ] . pop ( 0 ) ) while interface [ \"imports\" ]: next_import = interface [ \"imports\" ] . pop ( 0 ) next_statement = f \"{interface['statement']}, {next_import}\" current_line_length = len ( next_statement . split ( interface [ \"line_separator\" ])[ - 1 ]) if interface [ \"imports\" ] or need_trailing_char : # If we have more interface[\"imports\"] we need to account for a comma after this import # We might also need to account for a closing ) we're going to add. current_line_length += 1 if current_line_length > interface [ \"line_length\" ]: next_statement = ( f \"{interface['statement']},{interface['line_separator']}\" f \"{interface['indent']}{next_import}\" ) interface [ \"statement\" ] = next_statement if interface [ \"include_trailing_comma\" ]: interface [ \"statement\" ] += \",\" return interface [ \"statement\" ]","title":"vertical_grid_common"},{"location":"reference/isort/wrap_modes/#vertical_grid_grouped","text":"def vertical_grid_grouped ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical_grid_grouped ( ** interface ) : return ( vertical_grid_common ( statement = interface [ \"statement\" ] , imports = interface [ \"imports\" ] , white_space = interface [ \"white_space\" ] , indent = interface [ \"indent\" ] , line_length = interface [ \"line_length\" ] , comments = interface [ \"comments\" ] , line_separator = interface [ \"line_separator\" ] , comment_prefix = interface [ \"comment_prefix\" ] , include_trailing_comma = interface [ \"include_trailing_comma\" ] , remove_comments = interface [ \"remove_comments\" ] , need_trailing_char = True , ) + interface [ \"line_separator\" ] + \")\" )","title":"vertical_grid_grouped"},{"location":"reference/isort/wrap_modes/#vertical_grid_grouped_no_comma","text":"def vertical_grid_grouped_no_comma ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical_grid_grouped_no_comma ( ** interface ) : return ( vertical_grid_common ( statement = interface [ \"statement\" ] , imports = interface [ \"imports\" ] , white_space = interface [ \"white_space\" ] , indent = interface [ \"indent\" ] , line_length = interface [ \"line_length\" ] , comments = interface [ \"comments\" ] , line_separator = interface [ \"line_separator\" ] , comment_prefix = interface [ \"comment_prefix\" ] , include_trailing_comma = interface [ \"include_trailing_comma\" ] , remove_comments = interface [ \"remove_comments\" ] , need_trailing_char = False , ) + interface [ \"line_separator\" ] + \")\" )","title":"vertical_grid_grouped_no_comma"},{"location":"reference/isort/wrap_modes/#vertical_hanging_indent","text":"def vertical_hanging_indent ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical_hanging_indent ( ** interface ) : _line_with_comments = isort . comments . add_to_line ( interface [ \"comments\" ] , \"\" , removed = interface [ \"remove_comments\" ] , comment_prefix = interface [ \"comment_prefix\" ] , ) _imports = ( \",\" + interface [ \"line_separator\" ] + interface [ \"indent\" ] ). join ( interface [ \"imports\" ] ) _comma_maybe = \",\" if interface [ \"include_trailing_comma\" ] else \"\" return ( f \"{interface['statement']}({_line_with_comments}{interface['line_separator']}\" f \"{interface['indent']}{_imports}{_comma_maybe}{interface['line_separator']})\" )","title":"vertical_hanging_indent"},{"location":"reference/isort/wrap_modes/#vertical_hanging_indent_bracket","text":"def vertical_hanging_indent_bracket ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @ _ wrap_mode def vertical_hanging_indent_bracket ( **interface ) : if not interface [ \"imports\" ] : return \"\" statement = vertical_hanging_indent ( **interface ) return f'{statement[:-1]}{interface[\"indent\"]})'","title":"vertical_hanging_indent_bracket"},{"location":"reference/isort/wrap_modes/#vertical_prefix_from_module_import","text":"def vertical_prefix_from_module_import ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical_prefix_from_module_import ( ** interface ): if not interface [ \"imports\" ]: return \"\" prefix_statement = interface [ \"statement\" ] interface [ \"statement\" ] += interface [ \"imports\" ] . pop ( 0 ) while interface [ \"imports\" ]: next_import = interface [ \"imports\" ] . pop ( 0 ) next_statement = isort . comments . add_to_line ( interface [ \"comments\" ], interface [ \"statement\" ] + \", \" + next_import , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) if ( len ( next_statement . split ( interface [ \"line_separator\" ])[ - 1 ]) + 1 > interface [ \"line_length\" ] ): next_statement = ( isort . comments . add_to_line ( interface [ \"comments\" ], f \"{interface['statement']}\" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + f \"{interface['line_separator']}{prefix_statement}{next_import}\" ) interface [ \"comments\" ] = [] interface [ \"statement\" ] = next_statement return interface [ \"statement\" ]","title":"vertical_prefix_from_module_import"},{"location":"reference/isort/wrap_modes/#classes","text":"","title":"Classes"},{"location":"reference/isort/wrap_modes/#wrapmodes","text":"class WrapModes ( / , * args , ** kwargs ) An enumeration.","title":"WrapModes"},{"location":"reference/isort/wrap_modes/#ancestors-in-mro","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/isort/wrap_modes/#class-variables","text":"GRID HANGING_INDENT NOQA VERTICAL VERTICAL_GRID VERTICAL_GRID_GROUPED VERTICAL_GRID_GROUPED_NO_COMMA VERTICAL_HANGING_INDENT VERTICAL_HANGING_INDENT_BRACKET VERTICAL_PREFIX_FROM_MODULE_IMPORT name value","title":"Class variables"},{"location":"reference/isort/deprecated/","text":"Module isort.deprecated Sub-modules isort.deprecated.finders","title":"Index"},{"location":"reference/isort/deprecated/#module-isortdeprecated","text":"","title":"Module isort.deprecated"},{"location":"reference/isort/deprecated/#sub-modules","text":"isort.deprecated.finders","title":"Sub-modules"},{"location":"reference/isort/deprecated/finders/","text":"Module isort.deprecated.finders Finders try to find right section for passed module name View Source \"\"\"Finders try to find right section for passed module name\"\"\" import importlib . machinery import inspect import os import os . path import re import sys import sysconfig from abc import ABCMeta , abstractmethod from fnmatch import fnmatch from functools import lru_cache from glob import glob from pathlib import Path from typing import Dict , Iterable , Iterator , List , Optional , Pattern , Sequence , Tuple , Type from isort import sections from isort . settings import KNOWN_SECTION_MAPPING , Config from isort . utils import chdir , exists_case_sensitive try : from pipreqs import pipreqs except ImportError : pipreqs = None try : from pip_api import parse_requirements except ImportError : parse_requirements = None try : from requirementslib import Pipfile except ImportError : Pipfile = None class BaseFinder ( metaclass = ABCMeta ) : def __ init__ ( self , config : Config ) -> None : self . config = config @abstractmethod def find ( self , module_name: str ) -> Optional [ str ] : raise NotImplementedError class ForcedSeparateFinder ( BaseFinder ) : def find ( self , module_name: str ) -> Optional [ str ] : for forced_separate in self . config . forced_separate: # Ensure all forced_separate patterns will match to end of string path_glob = forced_separate if not forced_separate . endswith ( \"*\" ) : path_glob = \"%s*\" % forced_separate if fnmatch ( module_name , path_glob ) or fnmatch ( module_name , \".\" + path_glob ) : return forced_separate return None class LocalFinder ( BaseFinder ) : def find ( self , module_name: str ) -> Optional [ str ] : if module_name . startswith ( \".\" ) : return \"LOCALFOLDER\" return None class KnownPatternFinder ( BaseFinder ) : def __ init__ ( self , config : Config ) -> None : super (). __ init__ ( config ) self . known_patterns: List [ Tuple [ Pattern [ str ], str ]] = [] for placement in reversed ( config . sections ) : known_placement = KNOWN_SECTION_MAPPING . get ( placement , placement ). lower () config_key = f \"known_{known_placement}\" known_patterns = list ( getattr ( self . config , config_key , self . config . known_other . get ( known_placement , [])) ) known_patterns = [ pattern for known_pattern in known_patterns for pattern in self . _ parse_known_pattern ( known_pattern ) ] for known_pattern in known_patterns: regexp = \"^\" + known_pattern . replace ( \"*\" , \".*\" ). replace ( \"?\" , \".?\" ) + \"$\" self . known_patterns . append (( re . compile ( regexp ), placement )) @staticmethod def _ parse_known_pattern ( pattern : str ) -> List [ str ] : \"\"\"Expand pattern if identified as a directory and return found sub packages\"\"\" if pattern . endswith ( os . path . sep ) : patterns = [ filename for filename in os . listdir ( pattern ) if os . path . isdir ( os . path . join ( pattern , filename )) ] else : patterns = [ pattern ] return patterns def find ( self , module_name: str ) -> Optional [ str ] : # Try to find most specific placement instruction match ( if any ) parts = module_name . split ( \".\" ) module_names_to_check = ( \".\" . join ( parts [ :first_k ]) for first_k in range ( len ( parts ), 0 , - 1 )) for module_name_to_check in module_names_to_check: for pattern , placement in self . known_patterns: if pattern . match ( module_name_to_check ) : return placement return None class PathFinder ( BaseFinder ) : def __ init__ ( self , config : Config , path : str = \".\" ) -> None : super (). __ init__ ( config ) # restore the original import path ( i . e . not the path to bin / isort ) root_dir = os . path . abspath ( path ) src_dir = f \"{root_dir}/src\" self . paths = [ root_dir , src_dir ] # virtual env self . virtual_env = self . config . virtual_env or os . environ . get ( \"VIRTUAL_ENV\" ) if self . virtual_env: self . virtual_env = os . path . realpath ( self . virtual_env ) self . virtual_env_src = \"\" if self . virtual_env: self . virtual_env_src = f \"{self.virtual_env}/src/\" for venv_path in glob ( f \"{self.virtual_env}/lib/python*/site-packages\" ) : if venv_path not in self . paths : self . paths . append ( venv_path ) for nested_venv_path in glob ( f \"{self.virtual_env}/lib/python*/*/site-packages\" ) : if nested_venv_path not in self . paths : self . paths . append ( nested_venv_path ) for venv_src_path in glob ( f \"{self.virtual_env}/src/*\" ) : if os . path . isdir ( venv_src_path ) : self . paths . append ( venv_src_path ) # conda self . conda_env = self . config . conda_env or os . environ . get ( \"CONDA_PREFIX\" ) or \"\" if self . conda_env: self . conda_env = os . path . realpath ( self . conda_env ) for conda_path in glob ( f \"{self.conda_env}/lib/python*/site-packages\" ) : if conda_path not in self . paths : self . paths . append ( conda_path ) for nested_conda_path in glob ( f \"{self.conda_env}/lib/python*/*/site-packages\" ) : if nested_conda_path not in self . paths : self . paths . append ( nested_conda_path ) # handle case - insensitive paths on windows self . stdlib_lib_prefix = os . path . normcase ( sysconfig . get_paths ()[ \"stdlib\" ]) if self . stdlib_lib_prefix not in self . paths : self . paths . append ( self . stdlib_lib_prefix ) # add system paths for system_path in sys . path [ 1 : ] : if system_path not in self . paths : self . paths . append ( system_path ) def find ( self , module_name: str ) -> Optional [ str ] : for prefix in self . paths : package_path = \"/\" . join (( prefix , module_name . split ( \".\" )[ 0 ])) path_obj = Path ( package_path ). resolve () is_module = ( exists_case_sensitive ( package_path + \".py\" ) or any ( exists_case_sensitive ( package_path + ext_suffix ) for ext_suffix in importlib . machinery . EXTENSION_SUFFIXES ) or exists_case_sensitive ( package_path + \"/__init__.py\" ) ) is_package = exists_case_sensitive ( package_path ) and os . path . isdir ( package_path ) if is_module or is_package: if ( \"site-packages\" in prefix or \"dist-packages\" in prefix or ( self . virtual_env and self . virtual_env_src in prefix ) ) : return sections . THIRDPARTY elif os . path . normcase ( prefix ) == self . stdlib_lib_prefix: return sections . STDLIB elif self . conda_env and self . conda_env in prefix : return sections . THIRDPARTY for src_path in self . config . src_paths: if src_path in path_obj . parents and not self . config . is_skipped ( path_obj ) : return sections . FIRSTPARTY if os . path . normcase ( prefix ). startswith ( self . stdlib_lib_prefix ) : return sections . STDLIB # pragma : no cover - edge case for one OS . Hard to test . return self . config . default_section return None class ReqsBaseFinder ( BaseFinder ) : enabled = False def __ init__ ( self , config : Config , path : str = \".\" ) -> None : super (). __ init__ ( config ) self . path = path if self . enabled : self . mapping = self . _ load_mapping () self . names = self . _ load_names () @abstractmethod def _ get_names ( self , path : str ) -> Iterator [ str ] : raise NotImplementedError @abstractmethod def _ get_files_from_dir ( self , path : str ) -> Iterator [ str ] : raise NotImplementedError @staticmethod def _ load_mapping () -> Optional [ Dict [ str , str ]] : \"\"\"Return list of mappings `package_name -> module_name` Example: django-haystack -> haystack \"\"\" if not pipreqs : return None path = os . path . dirname ( inspect . getfile ( pipreqs )) path = os . path . join ( path , \"mapping\" ) with open ( path ) as f : mappings : Dict [ str , str ] = {} # pypi_name: import_name for line in f : import_name , _ , pypi_name = line . strip (). partition ( \":\" ) mappings [ pypi_name ] = import_name return mappings # return dict ( tuple ( line . strip (). split ( \":\" )[ ::- 1 ]) for line in f ) def _ load_names ( self ) -> List [ str ] : \"\"\"Return list of thirdparty modules from requirements\"\"\" names = [] for path in self . _ get_files () : for name in self . _ get_names ( path ) : names . append ( self . _ normalize_name ( name )) return names @staticmethod def _ get_parents ( path : str ) -> Iterator [ str ] : prev = \"\" while path ! = prev : prev = path yield path path = os . path . dirname ( path ) def _ get_files ( self ) -> Iterator [ str ] : \"\"\"Return paths to all requirements files\"\"\" path = os . path . abspath ( self . path ) if os . path . isfile ( path ) : path = os . path . dirname ( path ) for path in self . _ get_parents ( path ) : yield from self . _ get_files_from_dir ( path ) def _ normalize_name ( self , name : str ) -> str : \"\"\"Convert package name to module name Examples: Django -> django django-haystack -> django_haystack Flask-RESTFul -> flask_restful \"\"\" if self . mapping : name = self . mapping . get ( name . replace ( \"-\" , \"_\" ), name ) return name . lower (). replace ( \"-\" , \"_\" ) def find ( self , module_name: str ) -> Optional [ str ] : # required lib not installed yet if not self . enabled : return None module_name , _ sep , _ submodules = module_name . partition ( \".\" ) module_name = module_name . lower () if not module_name: return None for name in self . names : if module_name == name : return sections . THIRDPARTY return None class RequirementsFinder ( ReqsBaseFinder ) : exts = ( \".txt\" , \".in\" ) enabled = bool ( parse_requirements ) def _ get_files_from_dir ( self , path : str ) -> Iterator [ str ] : \"\"\"Return paths to requirements files from passed dir.\"\"\" yield from self . _ get_files_from_dir_cached ( path ) @classmethod @ lru_cache ( maxsize = 16 ) def _ get_files_from_dir_cached ( cls , path : str ) -> List [ str ] : results = [] for fname in os . listdir ( path ) : if \"requirements\" not in fname : continue full_path = os . path . join ( path , fname ) # * requirements*/*. { txt , in } if os . path . isdir ( full_path ) : for subfile_name in os . listdir ( full_path ) : for ext in cls . exts : if subfile_name . endswith ( ext ) : results . append ( os . path . join ( full_path , subfile_name )) continue # * requirements*. { txt , in } if os . path . isfile ( full_path ) : for ext in cls . exts : if fname . endswith ( ext ) : results . append ( full_path ) break return results def _ get_names ( self , path : str ) -> Iterator [ str ] : \"\"\"Load required packages from path to requirements file\"\"\" yield from self . _ get_names_cached ( path ) @classmethod @ lru_cache ( maxsize = 16 ) def _ get_names_cached ( cls , path : str ) -> List [ str ] : result = [] with chdir ( os . path . dirname ( path )) : requirements = parse_requirements ( path ) for req in requirements . values () : if req . name : result . append ( req . name ) return result class PipfileFinder ( ReqsBaseFinder ) : enabled = bool ( Pipfile ) def _ get_names ( self , path : str ) -> Iterator [ str ] : with chdir ( path ) : project = Pipfile . load ( path ) for req in project . packages : yield req . name def _ get_files_from_dir ( self , path : str ) -> Iterator [ str ] : if \"Pipfile\" in os . listdir ( path ) : yield path class DefaultFinder ( BaseFinder ) : def find ( self , module_name: str ) -> Optional [ str ] : return self . config . default_section class FindersManager : _ default_finders_classes: Sequence [ Type [ BaseFinder ]] = ( ForcedSeparateFinder , LocalFinder , KnownPatternFinder , PathFinder , PipfileFinder , RequirementsFinder , DefaultFinder , ) def __ init__ ( self , config : Config , finder_classes: Optional [ Iterable [ Type [ BaseFinder ]]] = None ) -> None : self . verbose : bool = config . verbose if finder_classes is None : finder_classes = self . _ default_finders_classes finders : List [ BaseFinder ] = [] for finder_cls in finder_classes: try : finders . append ( finder_cls ( config )) except Exception as exception : # if one finder fails to instantiate isort can continue using the rest if self . verbose : print ( ( f \"{finder_cls.__name__} encountered an error ({exception}) during \" \"instantiation and cannot be used\" ) ) self . finders : Tuple [ BaseFinder , ...] = tuple ( finders ) def find ( self , module_name: str ) -> Optional [ str ] : for finder in self . finders : try : section = finder . find ( module_name ) if section is not None : return section except Exception as exception : # isort has to be able to keep trying to identify the correct # import section even if one approach fails if self . verbose : print ( f \"{finder.__class__.__name__} encountered an error ({exception}) while \" f \"trying to identify the {module_name} module\" ) return None Variables KNOWN_SECTION_MAPPING Classes BaseFinder class BaseFinder ( config : isort . settings . Config ) View Source class BaseFinder ( metaclass = ABCMeta ) : def __init__ ( self , config : Config ) -> None : self . config = config @abstractmethod def find ( self , module_name : str ) -> Optional [ str ] : raise NotImplementedError Descendants isort.deprecated.finders.ForcedSeparateFinder isort.deprecated.finders.LocalFinder isort.deprecated.finders.KnownPatternFinder isort.deprecated.finders.PathFinder isort.deprecated.finders.ReqsBaseFinder isort.deprecated.finders.DefaultFinder Methods find def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source @abstractmethod def find ( self , module_name : str ) -> Optional [ str ] : raise NotImplementedError DefaultFinder class DefaultFinder ( config : isort . settings . Config ) View Source class DefaultFinder ( BaseFinder ) : def find ( self , module_name : str ) -> Optional [ str ] : return self . config . default_section Ancestors (in MRO) isort.deprecated.finders.BaseFinder Methods find def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : return self . config . default_section FindersManager class FindersManager ( config : isort . settings . Config , finder_classes : Union [ Iterable [ Type [ isort . deprecated . finders . BaseFinder ]], NoneType ] = None ) View Source class FindersManager : _default_finders_classes : Sequence [ Type[BaseFinder ] ] = ( ForcedSeparateFinder , LocalFinder , KnownPatternFinder , PathFinder , PipfileFinder , RequirementsFinder , DefaultFinder , ) def __init__ ( self , config : Config , finder_classes : Optional [ Iterable[Type[BaseFinder ] ]] = None ) -> None : self . verbose : bool = config . verbose if finder_classes is None : finder_classes = self . _default_finders_classes finders : List [ BaseFinder ] = [] for finder_cls in finder_classes : try : finders . append ( finder_cls ( config )) except Exception as exception : # if one finder fails to instantiate isort can continue using the rest if self . verbose : print ( ( f \"{finder_cls.__name__} encountered an error ({exception}) during \" \"instantiation and cannot be used\" ) ) self . finders : Tuple [ BaseFinder, ... ] = tuple ( finders ) def find ( self , module_name : str ) -> Optional [ str ] : for finder in self . finders : try : section = finder . find ( module_name ) if section is not None : return section except Exception as exception : # isort has to be able to keep trying to identify the correct # import section even if one approach fails if self . verbose : print ( f \"{finder.__class__.__name__} encountered an error ({exception}) while \" f \"trying to identify the {module_name} module\" ) return None Methods find def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ]: for finder in self . finders : try : section = finder . find ( module_name ) if section is not None : return section except Exception as exception : # isort has to be able to keep trying to identify the correct # import section even if one approach fails if self . verbose : print ( f \"{finder.__class__.__name__} encountered an error ({exception}) while \" f \"trying to identify the {module_name} module\" ) return None ForcedSeparateFinder class ForcedSeparateFinder ( config : isort . settings . Config ) View Source class ForcedSeparateFinder ( BaseFinder ) : def find ( self , module_name : str ) -> Optional [ str ] : for forced_separate in self . config . forced_separate : # Ensure all forced_separate patterns will match to end of string path_glob = forced_separate if not forced_separate . endswith ( \"*\" ) : path_glob = \"%s*\" % forced_separate if fnmatch ( module_name , path_glob ) or fnmatch ( module_name , \".\" + path_glob ) : return forced_separate return None Ancestors (in MRO) isort.deprecated.finders.BaseFinder Methods find def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : for forced_separate in self . config . forced_separate : # Ensure all forced_separate patterns will match to end of string path_glob = forced_separate if not forced_separate . endswith ( \"*\" ) : path_glob = \"%s*\" % forced_separate if fnmatch ( module_name , path_glob ) or fnmatch ( module_name , \".\" + path_glob ) : return forced_separate return None KnownPatternFinder class KnownPatternFinder ( config : isort . settings . Config ) View Source class KnownPatternFinder ( BaseFinder ) : def __init__ ( self , config : Config ) -> None : super (). __init__ ( config ) self . known_patterns : List [ Tuple[Pattern[str ] , str ]] = [] for placement in reversed ( config . sections ) : known_placement = KNOWN_SECTION_MAPPING . get ( placement , placement ). lower () config_key = f \"known_{known_placement}\" known_patterns = list ( getattr ( self . config , config_key , self . config . known_other . get ( known_placement , [] )) ) known_patterns = [ pattern for known_pattern in known_patterns for pattern in self._parse_known_pattern(known_pattern) ] for known_pattern in known_patterns : regexp = \"^\" + known_pattern . replace ( \"*\" , \".*\" ). replace ( \"?\" , \".?\" ) + \"$\" self . known_patterns . append (( re . compile ( regexp ), placement )) @staticmethod def _parse_known_pattern ( pattern : str ) -> List [ str ] : \"\"\"Expand pattern if identified as a directory and return found sub packages\"\"\" if pattern . endswith ( os . path . sep ) : patterns = [ filename for filename in os.listdir(pattern) if os.path.isdir(os.path.join(pattern, filename)) ] else : patterns = [ pattern ] return patterns def find ( self , module_name : str ) -> Optional [ str ] : # Try to find most specific placement instruction match ( if any ) parts = module_name . split ( \".\" ) module_names_to_check = ( \".\" . join ( parts [ :first_k ] ) for first_k in range ( len ( parts ), 0 , - 1 )) for module_name_to_check in module_names_to_check : for pattern , placement in self . known_patterns : if pattern . match ( module_name_to_check ) : return placement return None Ancestors (in MRO) isort.deprecated.finders.BaseFinder Methods find def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : # Try to find most specific placement instruction match ( if any ) parts = module_name . split ( \".\" ) module_names_to_check = ( \".\" . join ( parts [ :first_k ] ) for first_k in range ( len ( parts ), 0 , - 1 )) for module_name_to_check in module_names_to_check : for pattern , placement in self . known_patterns : if pattern . match ( module_name_to_check ) : return placement return None LocalFinder class LocalFinder ( config : isort . settings . Config ) View Source class LocalFinder ( BaseFinder ) : def find ( self , module_name : str ) -> Optional [ str ] : if module_name . startswith ( \".\" ) : return \"LOCALFOLDER\" return None Ancestors (in MRO) isort.deprecated.finders.BaseFinder Methods find def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : if module_name . startswith ( \".\" ) : return \"LOCALFOLDER\" return None PathFinder class PathFinder ( config : isort . settings . Config , path : str = '.' ) View Source class PathFinder ( BaseFinder ): def __init__ ( self , config : Config , path : str = \".\" ) -> None : super () . __init__ ( config ) # restore the original import path (i.e. not the path to bin/isort) root_dir = os . path . abspath ( path ) src_dir = f \"{root_dir}/src\" self . paths = [ root_dir , src_dir ] # virtual env self . virtual_env = self . config . virtual_env or os . environ . get ( \"VIRTUAL_ENV\" ) if self . virtual_env : self . virtual_env = os . path . realpath ( self . virtual_env ) self . virtual_env_src = \"\" if self . virtual_env : self . virtual_env_src = f \"{self.virtual_env}/src/\" for venv_path in glob ( f \"{self.virtual_env}/lib/python*/site-packages\" ): if venv_path not in self . paths : self . paths . append ( venv_path ) for nested_venv_path in glob ( f \"{self.virtual_env}/lib/python*/*/site-packages\" ): if nested_venv_path not in self . paths : self . paths . append ( nested_venv_path ) for venv_src_path in glob ( f \"{self.virtual_env}/src/*\" ): if os . path . isdir ( venv_src_path ): self . paths . append ( venv_src_path ) # conda self . conda_env = self . config . conda_env or os . environ . get ( \"CONDA_PREFIX\" ) or \"\" if self . conda_env : self . conda_env = os . path . realpath ( self . conda_env ) for conda_path in glob ( f \"{self.conda_env}/lib/python*/site-packages\" ): if conda_path not in self . paths : self . paths . append ( conda_path ) for nested_conda_path in glob ( f \"{self.conda_env}/lib/python*/*/site-packages\" ): if nested_conda_path not in self . paths : self . paths . append ( nested_conda_path ) # handle case-insensitive paths on windows self . stdlib_lib_prefix = os . path . normcase ( sysconfig . get_paths ()[ \"stdlib\" ]) if self . stdlib_lib_prefix not in self . paths : self . paths . append ( self . stdlib_lib_prefix ) # add system paths for system_path in sys . path [ 1 :]: if system_path not in self . paths : self . paths . append ( system_path ) def find ( self , module_name : str ) -> Optional [ str ]: for prefix in self . paths : package_path = \"/\" . join (( prefix , module_name . split ( \".\" )[ 0 ])) path_obj = Path ( package_path ) . resolve () is_module = ( exists_case_sensitive ( package_path + \".py\" ) or any ( exists_case_sensitive ( package_path + ext_suffix ) for ext_suffix in importlib . machinery . EXTENSION_SUFFIXES ) or exists_case_sensitive ( package_path + \"/__init__.py\" ) ) is_package = exists_case_sensitive ( package_path ) and os . path . isdir ( package_path ) if is_module or is_package : if ( \"site-packages\" in prefix or \"dist-packages\" in prefix or ( self . virtual_env and self . virtual_env_src in prefix ) ): return sections . THIRDPARTY elif os . path . normcase ( prefix ) == self . stdlib_lib_prefix : return sections . STDLIB elif self . conda_env and self . conda_env in prefix : return sections . THIRDPARTY for src_path in self . config . src_paths : if src_path in path_obj . parents and not self . config . is_skipped ( path_obj ): return sections . FIRSTPARTY if os . path . normcase ( prefix ) . startswith ( self . stdlib_lib_prefix ): return sections . STDLIB # pragma: no cover - edge case for one OS. Hard to test. return self . config . default_section return None Ancestors (in MRO) isort.deprecated.finders.BaseFinder Methods find def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : for prefix in self . paths : package_path = \"/\" . join (( prefix , module_name . split ( \".\" ) [ 0 ] )) path_obj = Path ( package_path ). resolve () is_module = ( exists_case_sensitive ( package_path + \".py\" ) or any ( exists_case_sensitive ( package_path + ext_suffix ) for ext_suffix in importlib . machinery . EXTENSION_SUFFIXES ) or exists_case_sensitive ( package_path + \"/__init__.py\" ) ) is_package = exists_case_sensitive ( package_path ) and os . path . isdir ( package_path ) if is_module or is_package : if ( \"site-packages\" in prefix or \"dist-packages\" in prefix or ( self . virtual_env and self . virtual_env_src in prefix ) ) : return sections . THIRDPARTY elif os . path . normcase ( prefix ) == self . stdlib_lib_prefix : return sections . STDLIB elif self . conda_env and self . conda_env in prefix : return sections . THIRDPARTY for src_path in self . config . src_paths : if src_path in path_obj . parents and not self . config . is_skipped ( path_obj ) : return sections . FIRSTPARTY if os . path . normcase ( prefix ). startswith ( self . stdlib_lib_prefix ) : return sections . STDLIB # pragma : no cover - edge case for one OS . Hard to test . return self . config . default_section return None PipfileFinder class PipfileFinder ( config : isort . settings . Config , path : str = '.' ) View Source class PipfileFinder ( ReqsBaseFinder ) : enabled = bool ( Pipfile ) def _get_names ( self , path : str ) -> Iterator [ str ] : with chdir ( path ) : project = Pipfile . load ( path ) for req in project . packages : yield req . name def _get_files_from_dir ( self , path : str ) -> Iterator [ str ] : if \"Pipfile\" in os . listdir ( path ) : yield path Ancestors (in MRO) isort.deprecated.finders.ReqsBaseFinder isort.deprecated.finders.BaseFinder Class variables enabled Methods find def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : # required lib not installed yet if not self . enabled : return None module_name , _sep , _submodules = module_name . partition ( \".\" ) module_name = module_name . lower () if not module_name : return None for name in self . names : if module_name == name : return sections . THIRDPARTY return None ReqsBaseFinder class ReqsBaseFinder ( config : isort . settings . Config , path : str = '.' ) View Source class ReqsBaseFinder ( BaseFinder ) : enabled = False def __ init__ ( self , config : Config , path : str = \".\" ) -> None : super (). __ init__ ( config ) self . path = path if self . enabled : self . mapping = self . _ load_mapping () self . names = self . _ load_names () @abstractmethod def _ get_names ( self , path : str ) -> Iterator [ str ] : raise NotImplementedError @abstractmethod def _ get_files_from_dir ( self , path : str ) -> Iterator [ str ] : raise NotImplementedError @staticmethod def _ load_mapping () -> Optional [ Dict [ str , str ]] : \"\"\"Return list of mappings `package_name -> module_name` Example: django-haystack -> haystack \"\"\" if not pipreqs : return None path = os . path . dirname ( inspect . getfile ( pipreqs )) path = os . path . join ( path , \"mapping\" ) with open ( path ) as f : mappings : Dict [ str , str ] = {} # pypi_name: import_name for line in f : import_name , _ , pypi_name = line . strip (). partition ( \":\" ) mappings [ pypi_name ] = import_name return mappings # return dict ( tuple ( line . strip (). split ( \":\" )[ ::- 1 ]) for line in f ) def _ load_names ( self ) -> List [ str ] : \"\"\"Return list of thirdparty modules from requirements\"\"\" names = [] for path in self . _ get_files () : for name in self . _ get_names ( path ) : names . append ( self . _ normalize_name ( name )) return names @staticmethod def _ get_parents ( path : str ) -> Iterator [ str ] : prev = \"\" while path ! = prev : prev = path yield path path = os . path . dirname ( path ) def _ get_files ( self ) -> Iterator [ str ] : \"\"\"Return paths to all requirements files\"\"\" path = os . path . abspath ( self . path ) if os . path . isfile ( path ) : path = os . path . dirname ( path ) for path in self . _ get_parents ( path ) : yield from self . _ get_files_from_dir ( path ) def _ normalize_name ( self , name : str ) -> str : \"\"\"Convert package name to module name Examples: Django -> django django-haystack -> django_haystack Flask-RESTFul -> flask_restful \"\"\" if self . mapping : name = self . mapping . get ( name . replace ( \"-\" , \"_\" ), name ) return name . lower (). replace ( \"-\" , \"_\" ) def find ( self , module_name: str ) -> Optional [ str ] : # required lib not installed yet if not self . enabled : return None module_name , _ sep , _ submodules = module_name . partition ( \".\" ) module_name = module_name . lower () if not module_name: return None for name in self . names : if module_name == name : return sections . THIRDPARTY return None Ancestors (in MRO) isort.deprecated.finders.BaseFinder Descendants isort.deprecated.finders.RequirementsFinder isort.deprecated.finders.PipfileFinder Class variables enabled Methods find def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : # required lib not installed yet if not self . enabled : return None module_name , _sep , _submodules = module_name . partition ( \".\" ) module_name = module_name . lower () if not module_name : return None for name in self . names : if module_name == name : return sections . THIRDPARTY return None RequirementsFinder class RequirementsFinder ( config : isort . settings . Config , path : str = '.' ) View Source class RequirementsFinder ( ReqsBaseFinder ) : exts = ( \".txt\" , \".in\" ) enabled = bool ( parse_requirements ) def _get_files_from_dir ( self , path : str ) -> Iterator [ str ] : \"\"\"Return paths to requirements files from passed dir.\"\"\" yield from self . _get_files_from_dir_cached ( path ) @classmethod @lru_cache ( maxsize = 16 ) def _get_files_from_dir_cached ( cls , path : str ) -> List [ str ] : results = [] for fname in os . listdir ( path ) : if \"requirements\" not in fname : continue full_path = os . path . join ( path , fname ) # * requirements * /*.{txt,in} if os.path.isdir(full_path): for subfile_name in os.listdir(full_path): for ext in cls.exts: if subfile_name.endswith(ext): results.append(os.path.join(full_path, subfile_name)) continue # *requirements*.{txt,in} if os.path.isfile(full_path): for ext in cls.exts: if fname.endswith(ext): results.append(full_path) break return results def _get_names(self, path: str) -> Iterator[str]: \"\"\"Load required packages from path to requirements file\"\"\" yield from self._get_names_cached(path) @classmethod @lru_cache(maxsize=16) def _get_names_cached(cls, path: str) -> List[str]: result = [] with chdir(os.path.dirname(path)): requirements = parse_requirements(path) for req in requirements.values(): if req.name: result.append(req.name) return result Ancestors (in MRO) isort.deprecated.finders.ReqsBaseFinder isort.deprecated.finders.BaseFinder Class variables enabled exts Methods find def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : # required lib not installed yet if not self . enabled : return None module_name , _sep , _submodules = module_name . partition ( \".\" ) module_name = module_name . lower () if not module_name : return None for name in self . names : if module_name == name : return sections . THIRDPARTY return None","title":"Finders"},{"location":"reference/isort/deprecated/finders/#module-isortdeprecatedfinders","text":"Finders try to find right section for passed module name View Source \"\"\"Finders try to find right section for passed module name\"\"\" import importlib . machinery import inspect import os import os . path import re import sys import sysconfig from abc import ABCMeta , abstractmethod from fnmatch import fnmatch from functools import lru_cache from glob import glob from pathlib import Path from typing import Dict , Iterable , Iterator , List , Optional , Pattern , Sequence , Tuple , Type from isort import sections from isort . settings import KNOWN_SECTION_MAPPING , Config from isort . utils import chdir , exists_case_sensitive try : from pipreqs import pipreqs except ImportError : pipreqs = None try : from pip_api import parse_requirements except ImportError : parse_requirements = None try : from requirementslib import Pipfile except ImportError : Pipfile = None class BaseFinder ( metaclass = ABCMeta ) : def __ init__ ( self , config : Config ) -> None : self . config = config @abstractmethod def find ( self , module_name: str ) -> Optional [ str ] : raise NotImplementedError class ForcedSeparateFinder ( BaseFinder ) : def find ( self , module_name: str ) -> Optional [ str ] : for forced_separate in self . config . forced_separate: # Ensure all forced_separate patterns will match to end of string path_glob = forced_separate if not forced_separate . endswith ( \"*\" ) : path_glob = \"%s*\" % forced_separate if fnmatch ( module_name , path_glob ) or fnmatch ( module_name , \".\" + path_glob ) : return forced_separate return None class LocalFinder ( BaseFinder ) : def find ( self , module_name: str ) -> Optional [ str ] : if module_name . startswith ( \".\" ) : return \"LOCALFOLDER\" return None class KnownPatternFinder ( BaseFinder ) : def __ init__ ( self , config : Config ) -> None : super (). __ init__ ( config ) self . known_patterns: List [ Tuple [ Pattern [ str ], str ]] = [] for placement in reversed ( config . sections ) : known_placement = KNOWN_SECTION_MAPPING . get ( placement , placement ). lower () config_key = f \"known_{known_placement}\" known_patterns = list ( getattr ( self . config , config_key , self . config . known_other . get ( known_placement , [])) ) known_patterns = [ pattern for known_pattern in known_patterns for pattern in self . _ parse_known_pattern ( known_pattern ) ] for known_pattern in known_patterns: regexp = \"^\" + known_pattern . replace ( \"*\" , \".*\" ). replace ( \"?\" , \".?\" ) + \"$\" self . known_patterns . append (( re . compile ( regexp ), placement )) @staticmethod def _ parse_known_pattern ( pattern : str ) -> List [ str ] : \"\"\"Expand pattern if identified as a directory and return found sub packages\"\"\" if pattern . endswith ( os . path . sep ) : patterns = [ filename for filename in os . listdir ( pattern ) if os . path . isdir ( os . path . join ( pattern , filename )) ] else : patterns = [ pattern ] return patterns def find ( self , module_name: str ) -> Optional [ str ] : # Try to find most specific placement instruction match ( if any ) parts = module_name . split ( \".\" ) module_names_to_check = ( \".\" . join ( parts [ :first_k ]) for first_k in range ( len ( parts ), 0 , - 1 )) for module_name_to_check in module_names_to_check: for pattern , placement in self . known_patterns: if pattern . match ( module_name_to_check ) : return placement return None class PathFinder ( BaseFinder ) : def __ init__ ( self , config : Config , path : str = \".\" ) -> None : super (). __ init__ ( config ) # restore the original import path ( i . e . not the path to bin / isort ) root_dir = os . path . abspath ( path ) src_dir = f \"{root_dir}/src\" self . paths = [ root_dir , src_dir ] # virtual env self . virtual_env = self . config . virtual_env or os . environ . get ( \"VIRTUAL_ENV\" ) if self . virtual_env: self . virtual_env = os . path . realpath ( self . virtual_env ) self . virtual_env_src = \"\" if self . virtual_env: self . virtual_env_src = f \"{self.virtual_env}/src/\" for venv_path in glob ( f \"{self.virtual_env}/lib/python*/site-packages\" ) : if venv_path not in self . paths : self . paths . append ( venv_path ) for nested_venv_path in glob ( f \"{self.virtual_env}/lib/python*/*/site-packages\" ) : if nested_venv_path not in self . paths : self . paths . append ( nested_venv_path ) for venv_src_path in glob ( f \"{self.virtual_env}/src/*\" ) : if os . path . isdir ( venv_src_path ) : self . paths . append ( venv_src_path ) # conda self . conda_env = self . config . conda_env or os . environ . get ( \"CONDA_PREFIX\" ) or \"\" if self . conda_env: self . conda_env = os . path . realpath ( self . conda_env ) for conda_path in glob ( f \"{self.conda_env}/lib/python*/site-packages\" ) : if conda_path not in self . paths : self . paths . append ( conda_path ) for nested_conda_path in glob ( f \"{self.conda_env}/lib/python*/*/site-packages\" ) : if nested_conda_path not in self . paths : self . paths . append ( nested_conda_path ) # handle case - insensitive paths on windows self . stdlib_lib_prefix = os . path . normcase ( sysconfig . get_paths ()[ \"stdlib\" ]) if self . stdlib_lib_prefix not in self . paths : self . paths . append ( self . stdlib_lib_prefix ) # add system paths for system_path in sys . path [ 1 : ] : if system_path not in self . paths : self . paths . append ( system_path ) def find ( self , module_name: str ) -> Optional [ str ] : for prefix in self . paths : package_path = \"/\" . join (( prefix , module_name . split ( \".\" )[ 0 ])) path_obj = Path ( package_path ). resolve () is_module = ( exists_case_sensitive ( package_path + \".py\" ) or any ( exists_case_sensitive ( package_path + ext_suffix ) for ext_suffix in importlib . machinery . EXTENSION_SUFFIXES ) or exists_case_sensitive ( package_path + \"/__init__.py\" ) ) is_package = exists_case_sensitive ( package_path ) and os . path . isdir ( package_path ) if is_module or is_package: if ( \"site-packages\" in prefix or \"dist-packages\" in prefix or ( self . virtual_env and self . virtual_env_src in prefix ) ) : return sections . THIRDPARTY elif os . path . normcase ( prefix ) == self . stdlib_lib_prefix: return sections . STDLIB elif self . conda_env and self . conda_env in prefix : return sections . THIRDPARTY for src_path in self . config . src_paths: if src_path in path_obj . parents and not self . config . is_skipped ( path_obj ) : return sections . FIRSTPARTY if os . path . normcase ( prefix ). startswith ( self . stdlib_lib_prefix ) : return sections . STDLIB # pragma : no cover - edge case for one OS . Hard to test . return self . config . default_section return None class ReqsBaseFinder ( BaseFinder ) : enabled = False def __ init__ ( self , config : Config , path : str = \".\" ) -> None : super (). __ init__ ( config ) self . path = path if self . enabled : self . mapping = self . _ load_mapping () self . names = self . _ load_names () @abstractmethod def _ get_names ( self , path : str ) -> Iterator [ str ] : raise NotImplementedError @abstractmethod def _ get_files_from_dir ( self , path : str ) -> Iterator [ str ] : raise NotImplementedError @staticmethod def _ load_mapping () -> Optional [ Dict [ str , str ]] : \"\"\"Return list of mappings `package_name -> module_name` Example: django-haystack -> haystack \"\"\" if not pipreqs : return None path = os . path . dirname ( inspect . getfile ( pipreqs )) path = os . path . join ( path , \"mapping\" ) with open ( path ) as f : mappings : Dict [ str , str ] = {} # pypi_name: import_name for line in f : import_name , _ , pypi_name = line . strip (). partition ( \":\" ) mappings [ pypi_name ] = import_name return mappings # return dict ( tuple ( line . strip (). split ( \":\" )[ ::- 1 ]) for line in f ) def _ load_names ( self ) -> List [ str ] : \"\"\"Return list of thirdparty modules from requirements\"\"\" names = [] for path in self . _ get_files () : for name in self . _ get_names ( path ) : names . append ( self . _ normalize_name ( name )) return names @staticmethod def _ get_parents ( path : str ) -> Iterator [ str ] : prev = \"\" while path ! = prev : prev = path yield path path = os . path . dirname ( path ) def _ get_files ( self ) -> Iterator [ str ] : \"\"\"Return paths to all requirements files\"\"\" path = os . path . abspath ( self . path ) if os . path . isfile ( path ) : path = os . path . dirname ( path ) for path in self . _ get_parents ( path ) : yield from self . _ get_files_from_dir ( path ) def _ normalize_name ( self , name : str ) -> str : \"\"\"Convert package name to module name Examples: Django -> django django-haystack -> django_haystack Flask-RESTFul -> flask_restful \"\"\" if self . mapping : name = self . mapping . get ( name . replace ( \"-\" , \"_\" ), name ) return name . lower (). replace ( \"-\" , \"_\" ) def find ( self , module_name: str ) -> Optional [ str ] : # required lib not installed yet if not self . enabled : return None module_name , _ sep , _ submodules = module_name . partition ( \".\" ) module_name = module_name . lower () if not module_name: return None for name in self . names : if module_name == name : return sections . THIRDPARTY return None class RequirementsFinder ( ReqsBaseFinder ) : exts = ( \".txt\" , \".in\" ) enabled = bool ( parse_requirements ) def _ get_files_from_dir ( self , path : str ) -> Iterator [ str ] : \"\"\"Return paths to requirements files from passed dir.\"\"\" yield from self . _ get_files_from_dir_cached ( path ) @classmethod @ lru_cache ( maxsize = 16 ) def _ get_files_from_dir_cached ( cls , path : str ) -> List [ str ] : results = [] for fname in os . listdir ( path ) : if \"requirements\" not in fname : continue full_path = os . path . join ( path , fname ) # * requirements*/*. { txt , in } if os . path . isdir ( full_path ) : for subfile_name in os . listdir ( full_path ) : for ext in cls . exts : if subfile_name . endswith ( ext ) : results . append ( os . path . join ( full_path , subfile_name )) continue # * requirements*. { txt , in } if os . path . isfile ( full_path ) : for ext in cls . exts : if fname . endswith ( ext ) : results . append ( full_path ) break return results def _ get_names ( self , path : str ) -> Iterator [ str ] : \"\"\"Load required packages from path to requirements file\"\"\" yield from self . _ get_names_cached ( path ) @classmethod @ lru_cache ( maxsize = 16 ) def _ get_names_cached ( cls , path : str ) -> List [ str ] : result = [] with chdir ( os . path . dirname ( path )) : requirements = parse_requirements ( path ) for req in requirements . values () : if req . name : result . append ( req . name ) return result class PipfileFinder ( ReqsBaseFinder ) : enabled = bool ( Pipfile ) def _ get_names ( self , path : str ) -> Iterator [ str ] : with chdir ( path ) : project = Pipfile . load ( path ) for req in project . packages : yield req . name def _ get_files_from_dir ( self , path : str ) -> Iterator [ str ] : if \"Pipfile\" in os . listdir ( path ) : yield path class DefaultFinder ( BaseFinder ) : def find ( self , module_name: str ) -> Optional [ str ] : return self . config . default_section class FindersManager : _ default_finders_classes: Sequence [ Type [ BaseFinder ]] = ( ForcedSeparateFinder , LocalFinder , KnownPatternFinder , PathFinder , PipfileFinder , RequirementsFinder , DefaultFinder , ) def __ init__ ( self , config : Config , finder_classes: Optional [ Iterable [ Type [ BaseFinder ]]] = None ) -> None : self . verbose : bool = config . verbose if finder_classes is None : finder_classes = self . _ default_finders_classes finders : List [ BaseFinder ] = [] for finder_cls in finder_classes: try : finders . append ( finder_cls ( config )) except Exception as exception : # if one finder fails to instantiate isort can continue using the rest if self . verbose : print ( ( f \"{finder_cls.__name__} encountered an error ({exception}) during \" \"instantiation and cannot be used\" ) ) self . finders : Tuple [ BaseFinder , ...] = tuple ( finders ) def find ( self , module_name: str ) -> Optional [ str ] : for finder in self . finders : try : section = finder . find ( module_name ) if section is not None : return section except Exception as exception : # isort has to be able to keep trying to identify the correct # import section even if one approach fails if self . verbose : print ( f \"{finder.__class__.__name__} encountered an error ({exception}) while \" f \"trying to identify the {module_name} module\" ) return None","title":"Module isort.deprecated.finders"},{"location":"reference/isort/deprecated/finders/#variables","text":"KNOWN_SECTION_MAPPING","title":"Variables"},{"location":"reference/isort/deprecated/finders/#classes","text":"","title":"Classes"},{"location":"reference/isort/deprecated/finders/#basefinder","text":"class BaseFinder ( config : isort . settings . Config ) View Source class BaseFinder ( metaclass = ABCMeta ) : def __init__ ( self , config : Config ) -> None : self . config = config @abstractmethod def find ( self , module_name : str ) -> Optional [ str ] : raise NotImplementedError","title":"BaseFinder"},{"location":"reference/isort/deprecated/finders/#descendants","text":"isort.deprecated.finders.ForcedSeparateFinder isort.deprecated.finders.LocalFinder isort.deprecated.finders.KnownPatternFinder isort.deprecated.finders.PathFinder isort.deprecated.finders.ReqsBaseFinder isort.deprecated.finders.DefaultFinder","title":"Descendants"},{"location":"reference/isort/deprecated/finders/#methods","text":"","title":"Methods"},{"location":"reference/isort/deprecated/finders/#find","text":"def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source @abstractmethod def find ( self , module_name : str ) -> Optional [ str ] : raise NotImplementedError","title":"find"},{"location":"reference/isort/deprecated/finders/#defaultfinder","text":"class DefaultFinder ( config : isort . settings . Config ) View Source class DefaultFinder ( BaseFinder ) : def find ( self , module_name : str ) -> Optional [ str ] : return self . config . default_section","title":"DefaultFinder"},{"location":"reference/isort/deprecated/finders/#ancestors-in-mro","text":"isort.deprecated.finders.BaseFinder","title":"Ancestors (in MRO)"},{"location":"reference/isort/deprecated/finders/#methods_1","text":"","title":"Methods"},{"location":"reference/isort/deprecated/finders/#find_1","text":"def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : return self . config . default_section","title":"find"},{"location":"reference/isort/deprecated/finders/#findersmanager","text":"class FindersManager ( config : isort . settings . Config , finder_classes : Union [ Iterable [ Type [ isort . deprecated . finders . BaseFinder ]], NoneType ] = None ) View Source class FindersManager : _default_finders_classes : Sequence [ Type[BaseFinder ] ] = ( ForcedSeparateFinder , LocalFinder , KnownPatternFinder , PathFinder , PipfileFinder , RequirementsFinder , DefaultFinder , ) def __init__ ( self , config : Config , finder_classes : Optional [ Iterable[Type[BaseFinder ] ]] = None ) -> None : self . verbose : bool = config . verbose if finder_classes is None : finder_classes = self . _default_finders_classes finders : List [ BaseFinder ] = [] for finder_cls in finder_classes : try : finders . append ( finder_cls ( config )) except Exception as exception : # if one finder fails to instantiate isort can continue using the rest if self . verbose : print ( ( f \"{finder_cls.__name__} encountered an error ({exception}) during \" \"instantiation and cannot be used\" ) ) self . finders : Tuple [ BaseFinder, ... ] = tuple ( finders ) def find ( self , module_name : str ) -> Optional [ str ] : for finder in self . finders : try : section = finder . find ( module_name ) if section is not None : return section except Exception as exception : # isort has to be able to keep trying to identify the correct # import section even if one approach fails if self . verbose : print ( f \"{finder.__class__.__name__} encountered an error ({exception}) while \" f \"trying to identify the {module_name} module\" ) return None","title":"FindersManager"},{"location":"reference/isort/deprecated/finders/#methods_2","text":"","title":"Methods"},{"location":"reference/isort/deprecated/finders/#find_2","text":"def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ]: for finder in self . finders : try : section = finder . find ( module_name ) if section is not None : return section except Exception as exception : # isort has to be able to keep trying to identify the correct # import section even if one approach fails if self . verbose : print ( f \"{finder.__class__.__name__} encountered an error ({exception}) while \" f \"trying to identify the {module_name} module\" ) return None","title":"find"},{"location":"reference/isort/deprecated/finders/#forcedseparatefinder","text":"class ForcedSeparateFinder ( config : isort . settings . Config ) View Source class ForcedSeparateFinder ( BaseFinder ) : def find ( self , module_name : str ) -> Optional [ str ] : for forced_separate in self . config . forced_separate : # Ensure all forced_separate patterns will match to end of string path_glob = forced_separate if not forced_separate . endswith ( \"*\" ) : path_glob = \"%s*\" % forced_separate if fnmatch ( module_name , path_glob ) or fnmatch ( module_name , \".\" + path_glob ) : return forced_separate return None","title":"ForcedSeparateFinder"},{"location":"reference/isort/deprecated/finders/#ancestors-in-mro_1","text":"isort.deprecated.finders.BaseFinder","title":"Ancestors (in MRO)"},{"location":"reference/isort/deprecated/finders/#methods_3","text":"","title":"Methods"},{"location":"reference/isort/deprecated/finders/#find_3","text":"def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : for forced_separate in self . config . forced_separate : # Ensure all forced_separate patterns will match to end of string path_glob = forced_separate if not forced_separate . endswith ( \"*\" ) : path_glob = \"%s*\" % forced_separate if fnmatch ( module_name , path_glob ) or fnmatch ( module_name , \".\" + path_glob ) : return forced_separate return None","title":"find"},{"location":"reference/isort/deprecated/finders/#knownpatternfinder","text":"class KnownPatternFinder ( config : isort . settings . Config ) View Source class KnownPatternFinder ( BaseFinder ) : def __init__ ( self , config : Config ) -> None : super (). __init__ ( config ) self . known_patterns : List [ Tuple[Pattern[str ] , str ]] = [] for placement in reversed ( config . sections ) : known_placement = KNOWN_SECTION_MAPPING . get ( placement , placement ). lower () config_key = f \"known_{known_placement}\" known_patterns = list ( getattr ( self . config , config_key , self . config . known_other . get ( known_placement , [] )) ) known_patterns = [ pattern for known_pattern in known_patterns for pattern in self._parse_known_pattern(known_pattern) ] for known_pattern in known_patterns : regexp = \"^\" + known_pattern . replace ( \"*\" , \".*\" ). replace ( \"?\" , \".?\" ) + \"$\" self . known_patterns . append (( re . compile ( regexp ), placement )) @staticmethod def _parse_known_pattern ( pattern : str ) -> List [ str ] : \"\"\"Expand pattern if identified as a directory and return found sub packages\"\"\" if pattern . endswith ( os . path . sep ) : patterns = [ filename for filename in os.listdir(pattern) if os.path.isdir(os.path.join(pattern, filename)) ] else : patterns = [ pattern ] return patterns def find ( self , module_name : str ) -> Optional [ str ] : # Try to find most specific placement instruction match ( if any ) parts = module_name . split ( \".\" ) module_names_to_check = ( \".\" . join ( parts [ :first_k ] ) for first_k in range ( len ( parts ), 0 , - 1 )) for module_name_to_check in module_names_to_check : for pattern , placement in self . known_patterns : if pattern . match ( module_name_to_check ) : return placement return None","title":"KnownPatternFinder"},{"location":"reference/isort/deprecated/finders/#ancestors-in-mro_2","text":"isort.deprecated.finders.BaseFinder","title":"Ancestors (in MRO)"},{"location":"reference/isort/deprecated/finders/#methods_4","text":"","title":"Methods"},{"location":"reference/isort/deprecated/finders/#find_4","text":"def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : # Try to find most specific placement instruction match ( if any ) parts = module_name . split ( \".\" ) module_names_to_check = ( \".\" . join ( parts [ :first_k ] ) for first_k in range ( len ( parts ), 0 , - 1 )) for module_name_to_check in module_names_to_check : for pattern , placement in self . known_patterns : if pattern . match ( module_name_to_check ) : return placement return None","title":"find"},{"location":"reference/isort/deprecated/finders/#localfinder","text":"class LocalFinder ( config : isort . settings . Config ) View Source class LocalFinder ( BaseFinder ) : def find ( self , module_name : str ) -> Optional [ str ] : if module_name . startswith ( \".\" ) : return \"LOCALFOLDER\" return None","title":"LocalFinder"},{"location":"reference/isort/deprecated/finders/#ancestors-in-mro_3","text":"isort.deprecated.finders.BaseFinder","title":"Ancestors (in MRO)"},{"location":"reference/isort/deprecated/finders/#methods_5","text":"","title":"Methods"},{"location":"reference/isort/deprecated/finders/#find_5","text":"def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : if module_name . startswith ( \".\" ) : return \"LOCALFOLDER\" return None","title":"find"},{"location":"reference/isort/deprecated/finders/#pathfinder","text":"class PathFinder ( config : isort . settings . Config , path : str = '.' ) View Source class PathFinder ( BaseFinder ): def __init__ ( self , config : Config , path : str = \".\" ) -> None : super () . __init__ ( config ) # restore the original import path (i.e. not the path to bin/isort) root_dir = os . path . abspath ( path ) src_dir = f \"{root_dir}/src\" self . paths = [ root_dir , src_dir ] # virtual env self . virtual_env = self . config . virtual_env or os . environ . get ( \"VIRTUAL_ENV\" ) if self . virtual_env : self . virtual_env = os . path . realpath ( self . virtual_env ) self . virtual_env_src = \"\" if self . virtual_env : self . virtual_env_src = f \"{self.virtual_env}/src/\" for venv_path in glob ( f \"{self.virtual_env}/lib/python*/site-packages\" ): if venv_path not in self . paths : self . paths . append ( venv_path ) for nested_venv_path in glob ( f \"{self.virtual_env}/lib/python*/*/site-packages\" ): if nested_venv_path not in self . paths : self . paths . append ( nested_venv_path ) for venv_src_path in glob ( f \"{self.virtual_env}/src/*\" ): if os . path . isdir ( venv_src_path ): self . paths . append ( venv_src_path ) # conda self . conda_env = self . config . conda_env or os . environ . get ( \"CONDA_PREFIX\" ) or \"\" if self . conda_env : self . conda_env = os . path . realpath ( self . conda_env ) for conda_path in glob ( f \"{self.conda_env}/lib/python*/site-packages\" ): if conda_path not in self . paths : self . paths . append ( conda_path ) for nested_conda_path in glob ( f \"{self.conda_env}/lib/python*/*/site-packages\" ): if nested_conda_path not in self . paths : self . paths . append ( nested_conda_path ) # handle case-insensitive paths on windows self . stdlib_lib_prefix = os . path . normcase ( sysconfig . get_paths ()[ \"stdlib\" ]) if self . stdlib_lib_prefix not in self . paths : self . paths . append ( self . stdlib_lib_prefix ) # add system paths for system_path in sys . path [ 1 :]: if system_path not in self . paths : self . paths . append ( system_path ) def find ( self , module_name : str ) -> Optional [ str ]: for prefix in self . paths : package_path = \"/\" . join (( prefix , module_name . split ( \".\" )[ 0 ])) path_obj = Path ( package_path ) . resolve () is_module = ( exists_case_sensitive ( package_path + \".py\" ) or any ( exists_case_sensitive ( package_path + ext_suffix ) for ext_suffix in importlib . machinery . EXTENSION_SUFFIXES ) or exists_case_sensitive ( package_path + \"/__init__.py\" ) ) is_package = exists_case_sensitive ( package_path ) and os . path . isdir ( package_path ) if is_module or is_package : if ( \"site-packages\" in prefix or \"dist-packages\" in prefix or ( self . virtual_env and self . virtual_env_src in prefix ) ): return sections . THIRDPARTY elif os . path . normcase ( prefix ) == self . stdlib_lib_prefix : return sections . STDLIB elif self . conda_env and self . conda_env in prefix : return sections . THIRDPARTY for src_path in self . config . src_paths : if src_path in path_obj . parents and not self . config . is_skipped ( path_obj ): return sections . FIRSTPARTY if os . path . normcase ( prefix ) . startswith ( self . stdlib_lib_prefix ): return sections . STDLIB # pragma: no cover - edge case for one OS. Hard to test. return self . config . default_section return None","title":"PathFinder"},{"location":"reference/isort/deprecated/finders/#ancestors-in-mro_4","text":"isort.deprecated.finders.BaseFinder","title":"Ancestors (in MRO)"},{"location":"reference/isort/deprecated/finders/#methods_6","text":"","title":"Methods"},{"location":"reference/isort/deprecated/finders/#find_6","text":"def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : for prefix in self . paths : package_path = \"/\" . join (( prefix , module_name . split ( \".\" ) [ 0 ] )) path_obj = Path ( package_path ). resolve () is_module = ( exists_case_sensitive ( package_path + \".py\" ) or any ( exists_case_sensitive ( package_path + ext_suffix ) for ext_suffix in importlib . machinery . EXTENSION_SUFFIXES ) or exists_case_sensitive ( package_path + \"/__init__.py\" ) ) is_package = exists_case_sensitive ( package_path ) and os . path . isdir ( package_path ) if is_module or is_package : if ( \"site-packages\" in prefix or \"dist-packages\" in prefix or ( self . virtual_env and self . virtual_env_src in prefix ) ) : return sections . THIRDPARTY elif os . path . normcase ( prefix ) == self . stdlib_lib_prefix : return sections . STDLIB elif self . conda_env and self . conda_env in prefix : return sections . THIRDPARTY for src_path in self . config . src_paths : if src_path in path_obj . parents and not self . config . is_skipped ( path_obj ) : return sections . FIRSTPARTY if os . path . normcase ( prefix ). startswith ( self . stdlib_lib_prefix ) : return sections . STDLIB # pragma : no cover - edge case for one OS . Hard to test . return self . config . default_section return None","title":"find"},{"location":"reference/isort/deprecated/finders/#pipfilefinder","text":"class PipfileFinder ( config : isort . settings . Config , path : str = '.' ) View Source class PipfileFinder ( ReqsBaseFinder ) : enabled = bool ( Pipfile ) def _get_names ( self , path : str ) -> Iterator [ str ] : with chdir ( path ) : project = Pipfile . load ( path ) for req in project . packages : yield req . name def _get_files_from_dir ( self , path : str ) -> Iterator [ str ] : if \"Pipfile\" in os . listdir ( path ) : yield path","title":"PipfileFinder"},{"location":"reference/isort/deprecated/finders/#ancestors-in-mro_5","text":"isort.deprecated.finders.ReqsBaseFinder isort.deprecated.finders.BaseFinder","title":"Ancestors (in MRO)"},{"location":"reference/isort/deprecated/finders/#class-variables","text":"enabled","title":"Class variables"},{"location":"reference/isort/deprecated/finders/#methods_7","text":"","title":"Methods"},{"location":"reference/isort/deprecated/finders/#find_7","text":"def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : # required lib not installed yet if not self . enabled : return None module_name , _sep , _submodules = module_name . partition ( \".\" ) module_name = module_name . lower () if not module_name : return None for name in self . names : if module_name == name : return sections . THIRDPARTY return None","title":"find"},{"location":"reference/isort/deprecated/finders/#reqsbasefinder","text":"class ReqsBaseFinder ( config : isort . settings . Config , path : str = '.' ) View Source class ReqsBaseFinder ( BaseFinder ) : enabled = False def __ init__ ( self , config : Config , path : str = \".\" ) -> None : super (). __ init__ ( config ) self . path = path if self . enabled : self . mapping = self . _ load_mapping () self . names = self . _ load_names () @abstractmethod def _ get_names ( self , path : str ) -> Iterator [ str ] : raise NotImplementedError @abstractmethod def _ get_files_from_dir ( self , path : str ) -> Iterator [ str ] : raise NotImplementedError @staticmethod def _ load_mapping () -> Optional [ Dict [ str , str ]] : \"\"\"Return list of mappings `package_name -> module_name` Example: django-haystack -> haystack \"\"\" if not pipreqs : return None path = os . path . dirname ( inspect . getfile ( pipreqs )) path = os . path . join ( path , \"mapping\" ) with open ( path ) as f : mappings : Dict [ str , str ] = {} # pypi_name: import_name for line in f : import_name , _ , pypi_name = line . strip (). partition ( \":\" ) mappings [ pypi_name ] = import_name return mappings # return dict ( tuple ( line . strip (). split ( \":\" )[ ::- 1 ]) for line in f ) def _ load_names ( self ) -> List [ str ] : \"\"\"Return list of thirdparty modules from requirements\"\"\" names = [] for path in self . _ get_files () : for name in self . _ get_names ( path ) : names . append ( self . _ normalize_name ( name )) return names @staticmethod def _ get_parents ( path : str ) -> Iterator [ str ] : prev = \"\" while path ! = prev : prev = path yield path path = os . path . dirname ( path ) def _ get_files ( self ) -> Iterator [ str ] : \"\"\"Return paths to all requirements files\"\"\" path = os . path . abspath ( self . path ) if os . path . isfile ( path ) : path = os . path . dirname ( path ) for path in self . _ get_parents ( path ) : yield from self . _ get_files_from_dir ( path ) def _ normalize_name ( self , name : str ) -> str : \"\"\"Convert package name to module name Examples: Django -> django django-haystack -> django_haystack Flask-RESTFul -> flask_restful \"\"\" if self . mapping : name = self . mapping . get ( name . replace ( \"-\" , \"_\" ), name ) return name . lower (). replace ( \"-\" , \"_\" ) def find ( self , module_name: str ) -> Optional [ str ] : # required lib not installed yet if not self . enabled : return None module_name , _ sep , _ submodules = module_name . partition ( \".\" ) module_name = module_name . lower () if not module_name: return None for name in self . names : if module_name == name : return sections . THIRDPARTY return None","title":"ReqsBaseFinder"},{"location":"reference/isort/deprecated/finders/#ancestors-in-mro_6","text":"isort.deprecated.finders.BaseFinder","title":"Ancestors (in MRO)"},{"location":"reference/isort/deprecated/finders/#descendants_1","text":"isort.deprecated.finders.RequirementsFinder isort.deprecated.finders.PipfileFinder","title":"Descendants"},{"location":"reference/isort/deprecated/finders/#class-variables_1","text":"enabled","title":"Class variables"},{"location":"reference/isort/deprecated/finders/#methods_8","text":"","title":"Methods"},{"location":"reference/isort/deprecated/finders/#find_8","text":"def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : # required lib not installed yet if not self . enabled : return None module_name , _sep , _submodules = module_name . partition ( \".\" ) module_name = module_name . lower () if not module_name : return None for name in self . names : if module_name == name : return sections . THIRDPARTY return None","title":"find"},{"location":"reference/isort/deprecated/finders/#requirementsfinder","text":"class RequirementsFinder ( config : isort . settings . Config , path : str = '.' ) View Source class RequirementsFinder ( ReqsBaseFinder ) : exts = ( \".txt\" , \".in\" ) enabled = bool ( parse_requirements ) def _get_files_from_dir ( self , path : str ) -> Iterator [ str ] : \"\"\"Return paths to requirements files from passed dir.\"\"\" yield from self . _get_files_from_dir_cached ( path ) @classmethod @lru_cache ( maxsize = 16 ) def _get_files_from_dir_cached ( cls , path : str ) -> List [ str ] : results = [] for fname in os . listdir ( path ) : if \"requirements\" not in fname : continue full_path = os . path . join ( path , fname ) # * requirements * /*.{txt,in} if os.path.isdir(full_path): for subfile_name in os.listdir(full_path): for ext in cls.exts: if subfile_name.endswith(ext): results.append(os.path.join(full_path, subfile_name)) continue # *requirements*.{txt,in} if os.path.isfile(full_path): for ext in cls.exts: if fname.endswith(ext): results.append(full_path) break return results def _get_names(self, path: str) -> Iterator[str]: \"\"\"Load required packages from path to requirements file\"\"\" yield from self._get_names_cached(path) @classmethod @lru_cache(maxsize=16) def _get_names_cached(cls, path: str) -> List[str]: result = [] with chdir(os.path.dirname(path)): requirements = parse_requirements(path) for req in requirements.values(): if req.name: result.append(req.name) return result","title":"RequirementsFinder"},{"location":"reference/isort/deprecated/finders/#ancestors-in-mro_7","text":"isort.deprecated.finders.ReqsBaseFinder isort.deprecated.finders.BaseFinder","title":"Ancestors (in MRO)"},{"location":"reference/isort/deprecated/finders/#class-variables_2","text":"enabled exts","title":"Class variables"},{"location":"reference/isort/deprecated/finders/#methods_9","text":"","title":"Methods"},{"location":"reference/isort/deprecated/finders/#find_9","text":"def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : # required lib not installed yet if not self . enabled : return None module_name , _sep , _submodules = module_name . partition ( \".\" ) module_name = module_name . lower () if not module_name : return None for name in self . names : if module_name == name : return sections . THIRDPARTY return None","title":"find"},{"location":"reference/isort/stdlibs/","text":"Module isort.stdlibs View Source from . import all , py2 , py3 , py27 , py35 , py36 , py37 , py38 , py39 Sub-modules isort.stdlibs.all isort.stdlibs.py2 isort.stdlibs.py27 isort.stdlibs.py3 isort.stdlibs.py35 isort.stdlibs.py36 isort.stdlibs.py37 isort.stdlibs.py38 isort.stdlibs.py39","title":"Index"},{"location":"reference/isort/stdlibs/#module-isortstdlibs","text":"View Source from . import all , py2 , py3 , py27 , py35 , py36 , py37 , py38 , py39","title":"Module isort.stdlibs"},{"location":"reference/isort/stdlibs/#sub-modules","text":"isort.stdlibs.all isort.stdlibs.py2 isort.stdlibs.py27 isort.stdlibs.py3 isort.stdlibs.py35 isort.stdlibs.py36 isort.stdlibs.py37 isort.stdlibs.py38 isort.stdlibs.py39","title":"Sub-modules"},{"location":"reference/isort/stdlibs/all/","text":"Module isort.stdlibs.all View Source from . import py2 , py3 stdlib = py2 . stdlib | py3 . stdlib Variables stdlib","title":"All"},{"location":"reference/isort/stdlibs/all/#module-isortstdlibsall","text":"View Source from . import py2 , py3 stdlib = py2 . stdlib | py3 . stdlib","title":"Module isort.stdlibs.all"},{"location":"reference/isort/stdlibs/all/#variables","text":"stdlib","title":"Variables"},{"location":"reference/isort/stdlibs/py2/","text":"Module isort.stdlibs.py2 View Source from . import py27 stdlib = py27 . stdlib Variables stdlib","title":"Py2"},{"location":"reference/isort/stdlibs/py2/#module-isortstdlibspy2","text":"View Source from . import py27 stdlib = py27 . stdlib","title":"Module isort.stdlibs.py2"},{"location":"reference/isort/stdlibs/py2/#variables","text":"stdlib","title":"Variables"},{"location":"reference/isort/stdlibs/py27/","text":"Module isort.stdlibs.py27 File contains the standard library of Python 2.7. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 2.7. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"AL\" , \"BaseHTTPServer\" , \"Bastion\" , \"CGIHTTPServer\" , \"Carbon\" , \"ColorPicker\" , \"ConfigParser\" , \"Cookie\" , \"DEVICE\" , \"DocXMLRPCServer\" , \"EasyDialogs\" , \"FL\" , \"FrameWork\" , \"GL\" , \"HTMLParser\" , \"MacOS\" , \"MimeWriter\" , \"MiniAEFrame\" , \"Nav\" , \"PixMapWrapper\" , \"Queue\" , \"SUNAUDIODEV\" , \"ScrolledText\" , \"SimpleHTTPServer\" , \"SimpleXMLRPCServer\" , \"SocketServer\" , \"StringIO\" , \"Tix\" , \"Tkinter\" , \"UserDict\" , \"UserList\" , \"UserString\" , \"W\" , \"__builtin__\" , \"_winreg\" , \"abc\" , \"aepack\" , \"aetools\" , \"aetypes\" , \"aifc\" , \"al\" , \"anydbm\" , \"applesingle\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"autoGIL\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"bsddb\" , \"buildtools\" , \"bz2\" , \"cPickle\" , \"cProfile\" , \"cStringIO\" , \"calendar\" , \"cd\" , \"cfmfile\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"commands\" , \"compileall\" , \"compiler\" , \"contextlib\" , \"cookielib\" , \"copy\" , \"copy_reg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"datetime\" , \"dbhash\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dircache\" , \"dis\" , \"distutils\" , \"dl\" , \"doctest\" , \"dumbdbm\" , \"dummy_thread\" , \"dummy_threading\" , \"email\" , \"encodings\" , \"ensurepip\" , \"errno\" , \"exceptions\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"findertools\" , \"fl\" , \"flp\" , \"fm\" , \"fnmatch\" , \"formatter\" , \"fpectl\" , \"fpformat\" , \"fractions\" , \"ftplib\" , \"functools\" , \"future_builtins\" , \"gc\" , \"gdbm\" , \"gensuitemodule\" , \"getopt\" , \"getpass\" , \"gettext\" , \"gl\" , \"glob\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"hotshot\" , \"htmlentitydefs\" , \"htmllib\" , \"httplib\" , \"ic\" , \"icopen\" , \"imageop\" , \"imaplib\" , \"imgfile\" , \"imghdr\" , \"imp\" , \"importlib\" , \"imputil\" , \"inspect\" , \"io\" , \"itertools\" , \"jpeg\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"macerrors\" , \"macostools\" , \"macpath\" , \"macresource\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"md5\" , \"mhlib\" , \"mimetools\" , \"mimetypes\" , \"mimify\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multifile\" , \"multiprocessing\" , \"mutex\" , \"netrc\" , \"new\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"popen2\" , \"poplib\" , \"posix\" , \"posixfile\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"resource\" , \"rexec\" , \"rfc822\" , \"rlcompleter\" , \"robotparser\" , \"runpy\" , \"sched\" , \"select\" , \"sets\" , \"sgmllib\" , \"sha\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"spwd\" , \"sqlite3\" , \"sre_constants\" , \"ssl\" , \"stat\" , \"statvfs\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"sunaudiodev\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"thread\" , \"threading\" , \"time\" , \"timeit\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"ttk\" , \"tty\" , \"turtle\" , \"types\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"urllib2\" , \"urlparse\" , \"user\" , \"uu\" , \"uuid\" , \"videoreader\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"whichdb\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpclib\" , \"zipfile\" , \"zipimport\" , \"zlib\" , } Variables stdlib","title":"Py27"},{"location":"reference/isort/stdlibs/py27/#module-isortstdlibspy27","text":"File contains the standard library of Python 2.7. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 2.7. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"AL\" , \"BaseHTTPServer\" , \"Bastion\" , \"CGIHTTPServer\" , \"Carbon\" , \"ColorPicker\" , \"ConfigParser\" , \"Cookie\" , \"DEVICE\" , \"DocXMLRPCServer\" , \"EasyDialogs\" , \"FL\" , \"FrameWork\" , \"GL\" , \"HTMLParser\" , \"MacOS\" , \"MimeWriter\" , \"MiniAEFrame\" , \"Nav\" , \"PixMapWrapper\" , \"Queue\" , \"SUNAUDIODEV\" , \"ScrolledText\" , \"SimpleHTTPServer\" , \"SimpleXMLRPCServer\" , \"SocketServer\" , \"StringIO\" , \"Tix\" , \"Tkinter\" , \"UserDict\" , \"UserList\" , \"UserString\" , \"W\" , \"__builtin__\" , \"_winreg\" , \"abc\" , \"aepack\" , \"aetools\" , \"aetypes\" , \"aifc\" , \"al\" , \"anydbm\" , \"applesingle\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"autoGIL\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"bsddb\" , \"buildtools\" , \"bz2\" , \"cPickle\" , \"cProfile\" , \"cStringIO\" , \"calendar\" , \"cd\" , \"cfmfile\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"commands\" , \"compileall\" , \"compiler\" , \"contextlib\" , \"cookielib\" , \"copy\" , \"copy_reg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"datetime\" , \"dbhash\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dircache\" , \"dis\" , \"distutils\" , \"dl\" , \"doctest\" , \"dumbdbm\" , \"dummy_thread\" , \"dummy_threading\" , \"email\" , \"encodings\" , \"ensurepip\" , \"errno\" , \"exceptions\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"findertools\" , \"fl\" , \"flp\" , \"fm\" , \"fnmatch\" , \"formatter\" , \"fpectl\" , \"fpformat\" , \"fractions\" , \"ftplib\" , \"functools\" , \"future_builtins\" , \"gc\" , \"gdbm\" , \"gensuitemodule\" , \"getopt\" , \"getpass\" , \"gettext\" , \"gl\" , \"glob\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"hotshot\" , \"htmlentitydefs\" , \"htmllib\" , \"httplib\" , \"ic\" , \"icopen\" , \"imageop\" , \"imaplib\" , \"imgfile\" , \"imghdr\" , \"imp\" , \"importlib\" , \"imputil\" , \"inspect\" , \"io\" , \"itertools\" , \"jpeg\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"macerrors\" , \"macostools\" , \"macpath\" , \"macresource\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"md5\" , \"mhlib\" , \"mimetools\" , \"mimetypes\" , \"mimify\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multifile\" , \"multiprocessing\" , \"mutex\" , \"netrc\" , \"new\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"popen2\" , \"poplib\" , \"posix\" , \"posixfile\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"resource\" , \"rexec\" , \"rfc822\" , \"rlcompleter\" , \"robotparser\" , \"runpy\" , \"sched\" , \"select\" , \"sets\" , \"sgmllib\" , \"sha\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"spwd\" , \"sqlite3\" , \"sre_constants\" , \"ssl\" , \"stat\" , \"statvfs\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"sunaudiodev\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"thread\" , \"threading\" , \"time\" , \"timeit\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"ttk\" , \"tty\" , \"turtle\" , \"types\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"urllib2\" , \"urlparse\" , \"user\" , \"uu\" , \"uuid\" , \"videoreader\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"whichdb\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpclib\" , \"zipfile\" , \"zipimport\" , \"zlib\" , }","title":"Module isort.stdlibs.py27"},{"location":"reference/isort/stdlibs/py27/#variables","text":"stdlib","title":"Variables"},{"location":"reference/isort/stdlibs/py3/","text":"Module isort.stdlibs.py3 View Source from . import py35 , py36 , py37 , py38 stdlib = py35 . stdlib | py36 . stdlib | py37 . stdlib | py38 . stdlib Variables stdlib","title":"Py3"},{"location":"reference/isort/stdlibs/py3/#module-isortstdlibspy3","text":"View Source from . import py35 , py36 , py37 , py38 stdlib = py35 . stdlib | py36 . stdlib | py37 . stdlib | py38 . stdlib","title":"Module isort.stdlibs.py3"},{"location":"reference/isort/stdlibs/py3/#variables","text":"stdlib","title":"Variables"},{"location":"reference/isort/stdlibs/py35/","text":"Module isort.stdlibs.py35 File contains the standard library of Python 3.5. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 3.5. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"_dummy_thread\" , \"_thread\" , \"abc\" , \"aifc\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncio\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"builtins\" , \"bz2\" , \"cProfile\" , \"calendar\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"compileall\" , \"concurrent\" , \"configparser\" , \"contextlib\" , \"copy\" , \"copyreg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"datetime\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dis\" , \"distutils\" , \"doctest\" , \"dummy_threading\" , \"email\" , \"encodings\" , \"ensurepip\" , \"enum\" , \"errno\" , \"faulthandler\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"fnmatch\" , \"formatter\" , \"fpectl\" , \"fractions\" , \"ftplib\" , \"functools\" , \"gc\" , \"getopt\" , \"getpass\" , \"gettext\" , \"glob\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"html\" , \"http\" , \"imaplib\" , \"imghdr\" , \"imp\" , \"importlib\" , \"inspect\" , \"io\" , \"ipaddress\" , \"itertools\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"lzma\" , \"macpath\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"mimetypes\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multiprocessing\" , \"netrc\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pathlib\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"poplib\" , \"posix\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"queue\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"reprlib\" , \"resource\" , \"rlcompleter\" , \"runpy\" , \"sched\" , \"select\" , \"selectors\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"socketserver\" , \"spwd\" , \"sqlite3\" , \"sre_constants\" , \"ssl\" , \"stat\" , \"statistics\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"threading\" , \"time\" , \"timeit\" , \"tkinter\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"tracemalloc\" , \"tty\" , \"turtle\" , \"turtledemo\" , \"types\" , \"typing\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"uu\" , \"uuid\" , \"venv\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"winreg\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpc\" , \"zipapp\" , \"zipfile\" , \"zipimport\" , \"zlib\" , } Variables stdlib","title":"Py35"},{"location":"reference/isort/stdlibs/py35/#module-isortstdlibspy35","text":"File contains the standard library of Python 3.5. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 3.5. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"_dummy_thread\" , \"_thread\" , \"abc\" , \"aifc\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncio\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"builtins\" , \"bz2\" , \"cProfile\" , \"calendar\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"compileall\" , \"concurrent\" , \"configparser\" , \"contextlib\" , \"copy\" , \"copyreg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"datetime\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dis\" , \"distutils\" , \"doctest\" , \"dummy_threading\" , \"email\" , \"encodings\" , \"ensurepip\" , \"enum\" , \"errno\" , \"faulthandler\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"fnmatch\" , \"formatter\" , \"fpectl\" , \"fractions\" , \"ftplib\" , \"functools\" , \"gc\" , \"getopt\" , \"getpass\" , \"gettext\" , \"glob\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"html\" , \"http\" , \"imaplib\" , \"imghdr\" , \"imp\" , \"importlib\" , \"inspect\" , \"io\" , \"ipaddress\" , \"itertools\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"lzma\" , \"macpath\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"mimetypes\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multiprocessing\" , \"netrc\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pathlib\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"poplib\" , \"posix\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"queue\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"reprlib\" , \"resource\" , \"rlcompleter\" , \"runpy\" , \"sched\" , \"select\" , \"selectors\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"socketserver\" , \"spwd\" , \"sqlite3\" , \"sre_constants\" , \"ssl\" , \"stat\" , \"statistics\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"threading\" , \"time\" , \"timeit\" , \"tkinter\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"tracemalloc\" , \"tty\" , \"turtle\" , \"turtledemo\" , \"types\" , \"typing\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"uu\" , \"uuid\" , \"venv\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"winreg\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpc\" , \"zipapp\" , \"zipfile\" , \"zipimport\" , \"zlib\" , }","title":"Module isort.stdlibs.py35"},{"location":"reference/isort/stdlibs/py35/#variables","text":"stdlib","title":"Variables"},{"location":"reference/isort/stdlibs/py36/","text":"Module isort.stdlibs.py36 File contains the standard library of Python 3.6. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 3.6. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"_dummy_thread\" , \"_thread\" , \"abc\" , \"aifc\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncio\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"builtins\" , \"bz2\" , \"cProfile\" , \"calendar\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"compileall\" , \"concurrent\" , \"configparser\" , \"contextlib\" , \"copy\" , \"copyreg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"datetime\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dis\" , \"distutils\" , \"doctest\" , \"dummy_threading\" , \"email\" , \"encodings\" , \"ensurepip\" , \"enum\" , \"errno\" , \"faulthandler\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"fnmatch\" , \"formatter\" , \"fpectl\" , \"fractions\" , \"ftplib\" , \"functools\" , \"gc\" , \"getopt\" , \"getpass\" , \"gettext\" , \"glob\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"html\" , \"http\" , \"imaplib\" , \"imghdr\" , \"imp\" , \"importlib\" , \"inspect\" , \"io\" , \"ipaddress\" , \"itertools\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"lzma\" , \"macpath\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"mimetypes\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multiprocessing\" , \"netrc\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pathlib\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"poplib\" , \"posix\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"queue\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"reprlib\" , \"resource\" , \"rlcompleter\" , \"runpy\" , \"sched\" , \"secrets\" , \"select\" , \"selectors\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"socketserver\" , \"spwd\" , \"sqlite3\" , \"sre_constants\" , \"ssl\" , \"stat\" , \"statistics\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"threading\" , \"time\" , \"timeit\" , \"tkinter\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"tracemalloc\" , \"tty\" , \"turtle\" , \"turtledemo\" , \"types\" , \"typing\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"uu\" , \"uuid\" , \"venv\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"winreg\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpc\" , \"zipapp\" , \"zipfile\" , \"zipimport\" , \"zlib\" , } Variables stdlib","title":"Py36"},{"location":"reference/isort/stdlibs/py36/#module-isortstdlibspy36","text":"File contains the standard library of Python 3.6. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 3.6. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"_dummy_thread\" , \"_thread\" , \"abc\" , \"aifc\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncio\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"builtins\" , \"bz2\" , \"cProfile\" , \"calendar\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"compileall\" , \"concurrent\" , \"configparser\" , \"contextlib\" , \"copy\" , \"copyreg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"datetime\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dis\" , \"distutils\" , \"doctest\" , \"dummy_threading\" , \"email\" , \"encodings\" , \"ensurepip\" , \"enum\" , \"errno\" , \"faulthandler\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"fnmatch\" , \"formatter\" , \"fpectl\" , \"fractions\" , \"ftplib\" , \"functools\" , \"gc\" , \"getopt\" , \"getpass\" , \"gettext\" , \"glob\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"html\" , \"http\" , \"imaplib\" , \"imghdr\" , \"imp\" , \"importlib\" , \"inspect\" , \"io\" , \"ipaddress\" , \"itertools\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"lzma\" , \"macpath\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"mimetypes\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multiprocessing\" , \"netrc\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pathlib\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"poplib\" , \"posix\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"queue\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"reprlib\" , \"resource\" , \"rlcompleter\" , \"runpy\" , \"sched\" , \"secrets\" , \"select\" , \"selectors\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"socketserver\" , \"spwd\" , \"sqlite3\" , \"sre_constants\" , \"ssl\" , \"stat\" , \"statistics\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"threading\" , \"time\" , \"timeit\" , \"tkinter\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"tracemalloc\" , \"tty\" , \"turtle\" , \"turtledemo\" , \"types\" , \"typing\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"uu\" , \"uuid\" , \"venv\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"winreg\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpc\" , \"zipapp\" , \"zipfile\" , \"zipimport\" , \"zlib\" , }","title":"Module isort.stdlibs.py36"},{"location":"reference/isort/stdlibs/py36/#variables","text":"stdlib","title":"Variables"},{"location":"reference/isort/stdlibs/py37/","text":"Module isort.stdlibs.py37 File contains the standard library of Python 3.7. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 3.7. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"_dummy_thread\" , \"_thread\" , \"abc\" , \"aifc\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncio\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"builtins\" , \"bz2\" , \"cProfile\" , \"calendar\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"compileall\" , \"concurrent\" , \"configparser\" , \"contextlib\" , \"contextvars\" , \"copy\" , \"copyreg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"dataclasses\" , \"datetime\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dis\" , \"distutils\" , \"doctest\" , \"dummy_threading\" , \"email\" , \"encodings\" , \"ensurepip\" , \"enum\" , \"errno\" , \"faulthandler\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"fnmatch\" , \"formatter\" , \"fractions\" , \"ftplib\" , \"functools\" , \"gc\" , \"getopt\" , \"getpass\" , \"gettext\" , \"glob\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"html\" , \"http\" , \"imaplib\" , \"imghdr\" , \"imp\" , \"importlib\" , \"inspect\" , \"io\" , \"ipaddress\" , \"itertools\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"lzma\" , \"macpath\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"mimetypes\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multiprocessing\" , \"netrc\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pathlib\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"poplib\" , \"posix\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"queue\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"reprlib\" , \"resource\" , \"rlcompleter\" , \"runpy\" , \"sched\" , \"secrets\" , \"select\" , \"selectors\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"socketserver\" , \"spwd\" , \"sqlite3\" , \"sre_constants\" , \"ssl\" , \"stat\" , \"statistics\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"threading\" , \"time\" , \"timeit\" , \"tkinter\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"tracemalloc\" , \"tty\" , \"turtle\" , \"turtledemo\" , \"types\" , \"typing\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"uu\" , \"uuid\" , \"venv\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"winreg\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpc\" , \"zipapp\" , \"zipfile\" , \"zipimport\" , \"zlib\" , } Variables stdlib","title":"Py37"},{"location":"reference/isort/stdlibs/py37/#module-isortstdlibspy37","text":"File contains the standard library of Python 3.7. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 3.7. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"_dummy_thread\" , \"_thread\" , \"abc\" , \"aifc\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncio\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"builtins\" , \"bz2\" , \"cProfile\" , \"calendar\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"compileall\" , \"concurrent\" , \"configparser\" , \"contextlib\" , \"contextvars\" , \"copy\" , \"copyreg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"dataclasses\" , \"datetime\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dis\" , \"distutils\" , \"doctest\" , \"dummy_threading\" , \"email\" , \"encodings\" , \"ensurepip\" , \"enum\" , \"errno\" , \"faulthandler\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"fnmatch\" , \"formatter\" , \"fractions\" , \"ftplib\" , \"functools\" , \"gc\" , \"getopt\" , \"getpass\" , \"gettext\" , \"glob\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"html\" , \"http\" , \"imaplib\" , \"imghdr\" , \"imp\" , \"importlib\" , \"inspect\" , \"io\" , \"ipaddress\" , \"itertools\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"lzma\" , \"macpath\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"mimetypes\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multiprocessing\" , \"netrc\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pathlib\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"poplib\" , \"posix\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"queue\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"reprlib\" , \"resource\" , \"rlcompleter\" , \"runpy\" , \"sched\" , \"secrets\" , \"select\" , \"selectors\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"socketserver\" , \"spwd\" , \"sqlite3\" , \"sre_constants\" , \"ssl\" , \"stat\" , \"statistics\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"threading\" , \"time\" , \"timeit\" , \"tkinter\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"tracemalloc\" , \"tty\" , \"turtle\" , \"turtledemo\" , \"types\" , \"typing\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"uu\" , \"uuid\" , \"venv\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"winreg\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpc\" , \"zipapp\" , \"zipfile\" , \"zipimport\" , \"zlib\" , }","title":"Module isort.stdlibs.py37"},{"location":"reference/isort/stdlibs/py37/#variables","text":"stdlib","title":"Variables"},{"location":"reference/isort/stdlibs/py38/","text":"Module isort.stdlibs.py38 File contains the standard library of Python 3.8. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 3.8. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"_dummy_thread\" , \"_thread\" , \"abc\" , \"aifc\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncio\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"builtins\" , \"bz2\" , \"cProfile\" , \"calendar\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"compileall\" , \"concurrent\" , \"configparser\" , \"contextlib\" , \"contextvars\" , \"copy\" , \"copyreg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"dataclasses\" , \"datetime\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dis\" , \"distutils\" , \"doctest\" , \"dummy_threading\" , \"email\" , \"encodings\" , \"ensurepip\" , \"enum\" , \"errno\" , \"faulthandler\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"fnmatch\" , \"formatter\" , \"fractions\" , \"ftplib\" , \"functools\" , \"gc\" , \"getopt\" , \"getpass\" , \"gettext\" , \"glob\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"html\" , \"http\" , \"imaplib\" , \"imghdr\" , \"imp\" , \"importlib\" , \"inspect\" , \"io\" , \"ipaddress\" , \"itertools\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"lzma\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"mimetypes\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multiprocessing\" , \"netrc\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pathlib\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"poplib\" , \"posix\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"queue\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"reprlib\" , \"resource\" , \"rlcompleter\" , \"runpy\" , \"sched\" , \"secrets\" , \"select\" , \"selectors\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"socketserver\" , \"spwd\" , \"sqlite3\" , \"sre_constants\" , \"ssl\" , \"stat\" , \"statistics\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"threading\" , \"time\" , \"timeit\" , \"tkinter\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"tracemalloc\" , \"tty\" , \"turtle\" , \"turtledemo\" , \"types\" , \"typing\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"uu\" , \"uuid\" , \"venv\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"winreg\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpc\" , \"zipapp\" , \"zipfile\" , \"zipimport\" , \"zlib\" , } Variables stdlib","title":"Py38"},{"location":"reference/isort/stdlibs/py38/#module-isortstdlibspy38","text":"File contains the standard library of Python 3.8. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 3.8. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"_dummy_thread\" , \"_thread\" , \"abc\" , \"aifc\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncio\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"builtins\" , \"bz2\" , \"cProfile\" , \"calendar\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"compileall\" , \"concurrent\" , \"configparser\" , \"contextlib\" , \"contextvars\" , \"copy\" , \"copyreg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"dataclasses\" , \"datetime\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dis\" , \"distutils\" , \"doctest\" , \"dummy_threading\" , \"email\" , \"encodings\" , \"ensurepip\" , \"enum\" , \"errno\" , \"faulthandler\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"fnmatch\" , \"formatter\" , \"fractions\" , \"ftplib\" , \"functools\" , \"gc\" , \"getopt\" , \"getpass\" , \"gettext\" , \"glob\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"html\" , \"http\" , \"imaplib\" , \"imghdr\" , \"imp\" , \"importlib\" , \"inspect\" , \"io\" , \"ipaddress\" , \"itertools\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"lzma\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"mimetypes\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multiprocessing\" , \"netrc\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pathlib\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"poplib\" , \"posix\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"queue\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"reprlib\" , \"resource\" , \"rlcompleter\" , \"runpy\" , \"sched\" , \"secrets\" , \"select\" , \"selectors\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"socketserver\" , \"spwd\" , \"sqlite3\" , \"sre_constants\" , \"ssl\" , \"stat\" , \"statistics\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"threading\" , \"time\" , \"timeit\" , \"tkinter\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"tracemalloc\" , \"tty\" , \"turtle\" , \"turtledemo\" , \"types\" , \"typing\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"uu\" , \"uuid\" , \"venv\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"winreg\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpc\" , \"zipapp\" , \"zipfile\" , \"zipimport\" , \"zlib\" , }","title":"Module isort.stdlibs.py38"},{"location":"reference/isort/stdlibs/py38/#variables","text":"stdlib","title":"Variables"},{"location":"reference/isort/stdlibs/py39/","text":"Module isort.stdlibs.py39 File contains the standard library of Python 3.9. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 3.9. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"_thread\" , \"abc\" , \"aifc\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncio\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"builtins\" , \"bz2\" , \"cProfile\" , \"calendar\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"compileall\" , \"concurrent\" , \"configparser\" , \"contextlib\" , \"contextvars\" , \"copy\" , \"copyreg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"dataclasses\" , \"datetime\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dis\" , \"distutils\" , \"doctest\" , \"email\" , \"encodings\" , \"ensurepip\" , \"enum\" , \"errno\" , \"faulthandler\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"fnmatch\" , \"formatter\" , \"fractions\" , \"ftplib\" , \"functools\" , \"gc\" , \"getopt\" , \"getpass\" , \"gettext\" , \"glob\" , \"graphlib\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"html\" , \"http\" , \"imaplib\" , \"imghdr\" , \"imp\" , \"importlib\" , \"inspect\" , \"io\" , \"ipaddress\" , \"itertools\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"lzma\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"mimetypes\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multiprocessing\" , \"netrc\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pathlib\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"poplib\" , \"posix\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"queue\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"reprlib\" , \"resource\" , \"rlcompleter\" , \"runpy\" , \"sched\" , \"secrets\" , \"select\" , \"selectors\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"socketserver\" , \"spwd\" , \"sqlite3\" , \"sre_constants\" , \"ssl\" , \"stat\" , \"statistics\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"threading\" , \"time\" , \"timeit\" , \"tkinter\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"tracemalloc\" , \"tty\" , \"turtle\" , \"turtledemo\" , \"types\" , \"typing\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"uu\" , \"uuid\" , \"venv\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"winreg\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpc\" , \"zipapp\" , \"zipfile\" , \"zipimport\" , \"zlib\" , \"zoneinfo\" , } Variables stdlib","title":"Py39"},{"location":"reference/isort/stdlibs/py39/#module-isortstdlibspy39","text":"File contains the standard library of Python 3.9. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 3.9. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"_thread\" , \"abc\" , \"aifc\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncio\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"builtins\" , \"bz2\" , \"cProfile\" , \"calendar\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"compileall\" , \"concurrent\" , \"configparser\" , \"contextlib\" , \"contextvars\" , \"copy\" , \"copyreg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"dataclasses\" , \"datetime\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dis\" , \"distutils\" , \"doctest\" , \"email\" , \"encodings\" , \"ensurepip\" , \"enum\" , \"errno\" , \"faulthandler\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"fnmatch\" , \"formatter\" , \"fractions\" , \"ftplib\" , \"functools\" , \"gc\" , \"getopt\" , \"getpass\" , \"gettext\" , \"glob\" , \"graphlib\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"html\" , \"http\" , \"imaplib\" , \"imghdr\" , \"imp\" , \"importlib\" , \"inspect\" , \"io\" , \"ipaddress\" , \"itertools\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"lzma\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"mimetypes\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multiprocessing\" , \"netrc\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pathlib\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"poplib\" , \"posix\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"queue\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"reprlib\" , \"resource\" , \"rlcompleter\" , \"runpy\" , \"sched\" , \"secrets\" , \"select\" , \"selectors\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"socketserver\" , \"spwd\" , \"sqlite3\" , \"sre_constants\" , \"ssl\" , \"stat\" , \"statistics\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"threading\" , \"time\" , \"timeit\" , \"tkinter\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"tracemalloc\" , \"tty\" , \"turtle\" , \"turtledemo\" , \"types\" , \"typing\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"uu\" , \"uuid\" , \"venv\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"winreg\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpc\" , \"zipapp\" , \"zipfile\" , \"zipimport\" , \"zlib\" , \"zoneinfo\" , }","title":"Module isort.stdlibs.py39"},{"location":"reference/isort/stdlibs/py39/#variables","text":"stdlib","title":"Variables"}]}